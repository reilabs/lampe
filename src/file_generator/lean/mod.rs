//! This module contains functionality for generating lean files with specified
//! configuration, like: imports, namespaces, etc.

use std::{collections::HashMap, fmt::Write, fs, path::Path};

use itertools::Itertools;

use crate::file_generator::{
    Error,
    LeanFile,
    NoirPackageIdentifier,
    DEPENDENCIES_MODULE_NAME,
    EXTRACTED_MODULE_NAME,
    LAMPE_GENERATED_COMMENT,
};

pub mod error;
pub mod file;

struct FileGenerator {
    lampe_root_dir:          std::path::PathBuf,
    noir_package_identifier: NoirPackageIdentifier,
    local_dependencies:      Vec<NoirPackageIdentifier>,
    external_dependencies:   Vec<NoirPackageIdentifier>,
    overwrite:               bool,
}

impl FileGenerator {
    fn new(
        lampe_root_dir: &Path,
        noir_package_identifier: &NoirPackageIdentifier,
        local_dependencies: Vec<NoirPackageIdentifier>,
        external_dependencies: &[NoirPackageIdentifier],
        overwrite: bool,
    ) -> Self {
        Self {
            lampe_root_dir: lampe_root_dir.to_path_buf(),
            noir_package_identifier: noir_package_identifier.clone(),
            local_dependencies,
            external_dependencies: external_dependencies.to_vec(),
            overwrite,
        }
    }

    /// Generates Lean's entrypoint file ready for user's code.
    /// Example path: $(project)/lampe/Example-0.0.0.lean
    fn generate_lib_file(&self) -> Result<(), Error> {
        let output_file = self.lampe_root_dir.join(format!(
            "{}-{}.lean",
            &self.noir_package_identifier.name, &self.noir_package_identifier.version
        ));
        if output_file.exists() && !self.overwrite {
            return Ok(());
        }

        let mut result = String::new();

        writeln!(result, "-- {LAMPE_GENERATED_COMMENT}")?;
        writeln!(result)?;
        writeln!(
            result,
            "import «{}-{}».{}",
            &self.noir_package_identifier.name,
            &self.noir_package_identifier.version,
            EXTRACTED_MODULE_NAME
        )?;
        writeln!(result)?;

        fs::write(output_file, result)?;

        Ok(())
    }

    /// Generates extracted module file that groups all imports of extracted and
    /// generated code for simple usage.
    /// Example path: $(project)/lampe/Example-0.0.0/Extracted.lean
    fn generate_extracted_file(
        &self,
        lib_dir: &Path,
        extracted_code: &[LeanFile],
    ) -> Result<(), Error> {
        let output_file = lib_dir.join(format!("{EXTRACTED_MODULE_NAME}.lean"));

        if output_file.exists() {
            let file_contents = fs::read_to_string(&output_file)?;
            if !file_contents.contains(LAMPE_GENERATED_COMMENT) {
                eprintln!(
                    "Encountered file {:?} that does not appear to be generated by Lampe but \
                     would be overwritten; skipping",
                    &output_file
                );
                return Ok(());
            } else if !self.overwrite {
                return Ok(());
            }
        }

        if output_file.exists() && !self.overwrite {
            return Ok(());
        }

        if let Some(parent_dir) = output_file.parent() {
            fs::create_dir_all(parent_dir)?;
        }

        let mut result = String::new();

        writeln!(result, "-- {LAMPE_GENERATED_COMMENT}")?;
        writeln!(result)?;

        // Import all the files in this project
        for import in extracted_code
            .iter()
            .map(|file| file.file_path.to_lean_import())
            .sorted()
        {
            writeln!(
                result,
                "import «{}-{}».{}.{}",
                &self.noir_package_identifier.name,
                &self.noir_package_identifier.version,
                EXTRACTED_MODULE_NAME,
                import
            )?;
        }

        // Import the `Extracted` file for each of the dependencies
        for extracted_module in self.local_dependencies.iter().sorted() {
            writeln!(
                result,
                "import «{}-{}».{}",
                &extracted_module.name, &extracted_module.version, EXTRACTED_MODULE_NAME,
            )?;
        }

        result.push('\n');
        writeln!(
            result,
            "namespace «{}-{}»",
            &self.noir_package_identifier.name, &self.noir_package_identifier.version
        )?;
        result.push('\n');

        // Print the concatenated env
        write!(result, "def env := ")?;

        let extracted_env = extracted_code
            .iter()
            .filter(|file| !file.is_generated_types())
            .map(|file| file.file_path.to_lean_import())
            .sorted()
            .map(|import| format!("{import}.env"))
            .join("\n  ++ ");

        let dependency_env = self
            .local_dependencies
            .iter()
            .chain(&self.external_dependencies)
            .map(|extracted_module| {
                format!(
                    "«{}-{}».env",
                    &extracted_module.name, &extracted_module.version,
                )
            })
            .join("\n  ++ ");

        if dependency_env.is_empty() {
            result.push_str(&extracted_env);
        } else {
            result.push_str(&format!(
                "{}\n  ++ {}",
                extracted_env, dependency_env
            ));
        }

        writeln!(result)?;

        fs::write(output_file, result)?;

        Ok(())
    }

    /// Generates main extracted project's lean files using code generated by
    /// Lampe based on Noir's project. It keeps original names and relative
    /// path from Noir's project changing naming to CamelCase.
    fn generate_extracted_module_version_extracted_files(
        &self,
        extracted_module_dir: &Path,
        extracted_code: &[LeanFile],
    ) -> Result<(), Error> {
        for lean_file in extracted_code {
            self.generate_extracted_module_version_extracted_file(extracted_module_dir, lean_file)?;
        }

        Ok(())
    }

    /// Generates single main extracted project Lean's file out from passed
    /// generated code. Example paths:
    /// $(project)/lampe/Example-0.0.0/Extracted/Main.lean
    /// $(project)/lampe/Example-0.0.0/Extracted/GeneratedTypes.lean
    /// $(project)/lampe/Example-0.0.0/Extracted/CustomUserFile.lean
    /// $(project)/lampe/Example-0.0.0/Extracted/CustomDir/CustomUserFileInDir.lean
    fn generate_extracted_module_version_extracted_file(
        &self,
        extracted_module_dir: &Path,
        extracted_code: &LeanFile,
    ) -> Result<(), Error> {
        let output_file = extracted_module_dir.join(extracted_code.file_path.to_lean_path());
        if output_file.exists() && !self.overwrite {
            return Ok(());
        }

        if let Some(output_file_dir) = output_file.parent() {
            fs::create_dir_all(output_file_dir)?;
        }

        let mut result = String::new();

        writeln!(result, "-- {LAMPE_GENERATED_COMMENT}")?;
        writeln!(result)?;

        if extracted_code.is_generated_types() {
            let generated_types_imports = self.get_generated_types_imports();
            for import in generated_types_imports {
                writeln!(result, "import {import}")?;
            }
        } else {
            writeln!(
                result,
                "import «{}-{}».{}.GeneratedTypes",
                &self.noir_package_identifier.name,
                &self.noir_package_identifier.version,
                EXTRACTED_MODULE_NAME,
            )?;
        }

        writeln!(result, "import Lampe")?;
        writeln!(result)?;
        writeln!(result, "open Lampe")?;
        // writeln!(result)?;
        // writeln!(
        //     result,
        //     "namespace «{}-{}»",
        //     &self.noir_package_identifier.name, &self.noir_package_identifier.version
        // )?;
        writeln!(result)?;
        result.push_str(&extracted_code.content);

        fs::write(output_file, result)?;

        Ok(())
    }

    fn get_generated_types_imports(&self) -> Vec<String> {
        let mut imports = vec![];

        for dep in self.local_dependencies.iter().chain(&self.external_dependencies) {
            imports.push(format!("«{}-{}».{EXTRACTED_MODULE_NAME}.GeneratedTypes", dep.name, dep.version));
        }

        imports
    }

    /// Generates extracted dependency's Lean's module file that is used later
    /// to import everything easily.
    /// Example path:
    /// $(project)/ExampleDep-0.0.0.lean
    fn generate_extracted_dep_module_version_file(
        &self,
        extracted_module: &NoirPackageIdentifier,
        extracted_code: &[LeanFile],
    ) -> Result<(), Error> {
        let output_file = self.lampe_root_dir.join(format!(
            "{}-{}.lean",
            &extracted_module.name, &extracted_module.version
        ));
        if output_file.exists() && !self.overwrite {
            return Ok(());
        }

        let mut result = String::new();

        writeln!(result, "-- {LAMPE_GENERATED_COMMENT}")?;
        writeln!(result)?;
        for import in extracted_code
            .iter()
            .map(|file| file.file_path.to_lean_import())
            .sorted()
        {
            writeln!(
                result,
                "import «{}-{}».{}",
                &extracted_module.name, &extracted_module.version, import
            )?;
        }
        writeln!(result)?;
        // writeln!(
        //     result,
        //     "namespace «{}-{}»",
        //     &extracted_module.name, &extracted_module.version
        // )?;
        // writeln!(result)?;

        if !extracted_code.is_empty() {
            write!(result, "def env := ")?;
            let env = extracted_code
                .iter()
                .filter(|file| !file.is_generated_types())
                .map(|file| file.file_path.to_lean_import())
                .sorted()
                .map(|import| {
                    format!(
                        "«{}-{}».{}.{}.«{}-{}».{}.env",
                        &self.noir_package_identifier.name,
                        &self.noir_package_identifier.version,
                        EXTRACTED_MODULE_NAME,
                        DEPENDENCIES_MODULE_NAME,
                        &extracted_module.name,
                        &extracted_module.version,
                        import,
                    )
                })
                .join("\n  ++ ");
            result.push_str(&env);
        }
        writeln!(result)?;

        fs::write(output_file, result)?;

        Ok(())
    }

    /// Generates extracted dependency's lean files using code generated by
    /// Lampe based on Noir's project. It keeps original names and relative
    /// path from Noir's project changing naming to CamelCase. Example path:
    /// $(project)/ExampleDep-0.0.0/*
    fn generate_extracted_dep_module_version_extracted_files(
        &self,
        extracted_dep_module_dir: &Path,
        extracted_module: &NoirPackageIdentifier,
        extracted_code: &Vec<LeanFile>,
    ) -> Result<(), Error> {
        if !extracted_dep_module_dir.exists() {
            fs::create_dir(&extracted_dep_module_dir)?;
        }

        for lean_file in extracted_code {
            self.generate_extracted_dep_module_version_extracted_file(
                &extracted_dep_module_dir,
                extracted_module,
                lean_file,
            )?;
        }

        Ok(())
    }

    /// Generates single extracted dependency's lean file out from passed
    /// generated code. Example paths:
    /// $(project)/ExampleDep-0.0.0/Lib.lean 
    /// $(project)/ExampleDep-0.0.0/GeneratedTypes.lean 
    /// $(project)/ExampleDep-0.0.0/Main.lean 
    /// $(project)/ExampleDep-0.0.0/CustomUserFile.lean 
    /// $(project)/ExampleDep-0.0.0/CustomDir/CustomUserFileInDir.lean
    fn generate_extracted_dep_module_version_extracted_file(
        &self,
        extracted_dep_module_dir: &Path,
        extracted_module: &NoirPackageIdentifier,
        extracted_code: &LeanFile,
    ) -> Result<(), Error> {
        let output_file = extracted_dep_module_dir.join(extracted_code.file_path.to_lean_path());
        if output_file.exists() && !self.overwrite {
            return Ok(());
        }

        if let Some(output_file_dir) = output_file.parent() {
            fs::create_dir_all(output_file_dir)?;
        }

        let mut result = String::new();

        writeln!(result, "-- {LAMPE_GENERATED_COMMENT}")?;
        writeln!(result)?;

        if !extracted_code.is_generated_types() {
            writeln!(
                result,
                "import «{}-{}».GeneratedTypes",
                &extracted_module.name, &extracted_module.version,
            )?;
        }

        writeln!(result, "import Lampe")?;
        writeln!(result)?;
        writeln!(result, "open Lampe")?;
        // writeln!(result)?;
        // writeln!(
        //     result,
        //     "namespace «{}-{}»",
        //     &extracted_module.name, &extracted_module.version
        // )?;
        writeln!(result)?;
        result.push_str(&extracted_code.content);

        fs::write(output_file, result)?;

        Ok(())
    }
}

/// Generates all lean files from passed extracted code with project
/// configuration. Current lean files structure is (in pseudo description):
/// |--<Main package>
/// |  |-- Extracted
/// |  |  |--Noir extracted code matching file paths as created by user in Noir project
/// |  |-- Extracted.lean
/// |-- <Main package>.lean
/// |-- Dependency1/Extracted/*.lean
/// |-- Dependency1.lean
/// |-- Dependency2/Extracted/*.lean */
/// |-- Dependency2.lean
/// |-- ...
/// 
/// Example path: $(project)/lampe/*
///
/// # Errors
///
/// - If it cannot generate the Lean files.
pub fn generate_lean_files<H: std::hash::BuildHasher>(
    lampe_root_dir: &Path,
    noir_package_identifier: &NoirPackageIdentifier,
    extracted_code: &[LeanFile],
    extracted_dependencies: HashMap<NoirPackageIdentifier, Vec<LeanFile>, H>,
    external_dependencies: &[NoirPackageIdentifier],
) -> Result<(), Error> {
    let local_dependencies = extracted_dependencies.keys().cloned().collect::<Vec<_>>();

    let generator = FileGenerator::new(
        lampe_root_dir,
        noir_package_identifier,
        local_dependencies,
        external_dependencies,
        false,
    );

    generator.generate_lib_file()?;

    let lib_dir = generator.lampe_root_dir.join(format!(
        "{}-{}",
        &generator.noir_package_identifier.name, &generator.noir_package_identifier.version
    ));
    if !lib_dir.exists() {
        fs::create_dir(&lib_dir)?;
    }

    generator.generate_extracted_file(&lib_dir, extracted_code)?;

    let extracted_lib_dir = lib_dir.join(EXTRACTED_MODULE_NAME);
    if !extracted_lib_dir.exists() {
        fs::create_dir(&extracted_lib_dir)?;
    }

    generator
        .generate_extracted_module_version_extracted_files(&extracted_lib_dir, extracted_code)?;

    if !extracted_dependencies.is_empty() {
        for (extracted_dependency, lean_files) in extracted_dependencies {
            let extracted_dep_lib_dir = generator.lampe_root_dir.join(format!(
                "{}-{}",
                &extracted_dependency.name, &extracted_dependency.version
            ));

            if !extracted_dep_lib_dir.exists() {
                fs::create_dir(&extracted_dep_lib_dir)?;
            }

            let dep_generator = FileGenerator::new(
                &generator.lampe_root_dir,
                &generator.noir_package_identifier,
                generator.local_dependencies.clone(),
                &generator.external_dependencies,
                true,
            );

            dep_generator
                .generate_extracted_dep_module_version_file(&extracted_dependency, &lean_files)?;

            dep_generator.generate_extracted_dep_module_version_extracted_files(
                &extracted_dep_lib_dir,
                &extracted_dependency,
                &lean_files,
            )?;
        }
    }

    Ok(())
}
