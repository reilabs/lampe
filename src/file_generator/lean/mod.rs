//! This module contains functionality for generating lean files with specified
//! configuration, like: imports, namespaces, etc.

use std::{collections::HashMap, fmt::Write, fs, path::{self, Path}};

use itertools::Itertools;

use crate::file_generator::{
    self, lake::dependency::{LeanDependency, LeanDependencyPath}, Error, LeanFile, NoirPackageIdentifier, EXTRACTED_MODULE_NAME, LAMPE_GENERATED_COMMENT
};

pub mod error;
pub mod file;

struct FileGenerator {
    lampe_root_dir:          path::PathBuf,
    noir_package_identifier: NoirPackageIdentifier,
    local_dependencies:      Vec<NoirPackageIdentifier>,
    external_dependencies:   Vec<NoirPackageIdentifier>,
    overwrite:               bool,
}

impl FileGenerator {
    fn new(
        lampe_root_dir: &Path,
        noir_package_identifier: &NoirPackageIdentifier,
        local_dependencies: Vec<NoirPackageIdentifier>,
        external_dependencies: &[NoirPackageIdentifier],
        overwrite: bool,
    ) -> Self {
        Self {
            lampe_root_dir: lampe_root_dir.to_path_buf(),
            noir_package_identifier: noir_package_identifier.clone(),
            local_dependencies,
            external_dependencies: external_dependencies.to_vec(),
            overwrite,
        }
    }

    /// Generates Lean's entrypoint file ready for user's code.
    /// Example path: $(project)/lampe/Example-0.0.0.lean
    fn generate_lib_file(&self) -> Result<(), Error> {
        let output_file = self.lampe_root_dir.join(format!(
            "{}-{}.lean",
            &self.noir_package_identifier.name, &self.noir_package_identifier.version
        ));
        if output_file.exists() && !self.overwrite {
            return Ok(());
        }

        let mut result = String::new();

        writeln!(result, "-- {LAMPE_GENERATED_COMMENT}")?;
        writeln!(result)?;
        writeln!(
            result,
            "import «{}-{}».{}",
            &self.noir_package_identifier.name,
            &self.noir_package_identifier.version,
            EXTRACTED_MODULE_NAME
        )?;
        writeln!(result)?;

        fs::write(output_file, result)?;

        Ok(())
    }

    /// Generates extracted module file that groups all imports of extracted and
    /// generated code for simple usage.
    /// Example path: $(project)/lampe/Example-0.0.0/Extracted.lean
    fn generate_extracted_file(
        &self,
        lib_dir: &Path,
        extracted_code: &[LeanFile],
    ) -> Result<(), Error> {
        let output_file = lib_dir.join(format!("{EXTRACTED_MODULE_NAME}.lean"));

        if output_file.exists() {
            let file_contents = fs::read_to_string(&output_file)?;
            if !file_contents.contains(LAMPE_GENERATED_COMMENT) {
                eprintln!(
                    "Encountered file {:?} that does not appear to be generated by Lampe but \
                     would be overwritten; skipping",
                    &output_file
                );
                return Ok(());
            } else if !self.overwrite {
                return Ok(());
            }
        }

        if output_file.exists() && !self.overwrite {
            return Ok(());
        }

        if let Some(parent_dir) = output_file.parent() {
            fs::create_dir_all(parent_dir)?;
        }

        let mut result = String::new();

        writeln!(result, "-- {LAMPE_GENERATED_COMMENT}")?;
        writeln!(result)?;

        // Import all the files in this project
        for import in extracted_code
            .iter()
            .map(|file| file.file_path.to_lean_import())
            .sorted()
        {
            writeln!(
                result,
                "import «{}-{}».{}.{}",
                &self.noir_package_identifier.name,
                &self.noir_package_identifier.version,
                EXTRACTED_MODULE_NAME,
                import
            )?;
        }

        // Import the `Extracted` file for each of the dependencies
        for extracted_module in self.local_dependencies.iter().sorted() {
            writeln!(
                result,
                "import «{}-{}».{}",
                &extracted_module.name, &extracted_module.version, EXTRACTED_MODULE_NAME,
            )?;
        }

        result.push('\n');
        writeln!(
            result,
            "namespace «{}-{}»",
            &self.noir_package_identifier.name, &self.noir_package_identifier.version
        )?;
        result.push('\n');

        // Print the concatenated env
        write!(result, "def env := ")?;

        let extracted_env = extracted_code
            .iter()
            .filter(|file| !file.is_generated_types())
            .map(|file| file.file_path.to_lean_import())
            .sorted()
            .map(|import| format!("{import}.env"))
            .join("\n  ++ ");

        let dependency_env = self
            .external_dependencies
            .iter()
            .map(|extracted_module| {
                format!(
                    "«{}-{}».env",
                    &extracted_module.name, &extracted_module.version,
                )
            })
            .join("\n  ++ ");

        if dependency_env.is_empty() {
            result.push_str(&extracted_env);
        } else {
            result.push_str(&format!(
                "{}\n  ++ {}",
                extracted_env, dependency_env
            ));
        }

        writeln!(result)?;

        fs::write(output_file, result)?;

        Ok(())
    }

    /// Generates main extracted project's lean files using code generated by
    /// Lampe based on Noir's project. It keeps original names and relative
    /// path from Noir's project changing naming to CamelCase.
    fn generate_extracted_module_version_extracted_files(
        &self,
        extracted_module_dir: &Path,
        extracted_code: &[LeanFile],
    ) -> Result<(), Error> {
        for lean_file in extracted_code {
            self.generate_extracted_module_version_extracted_file(extracted_module_dir, lean_file)?;
        }

        Ok(())
    }

    /// Generates single main extracted project Lean's file out from passed
    /// generated code. Example paths:
    /// $(project)/lampe/Example-0.0.0/Extracted/Main.lean
    /// $(project)/lampe/Example-0.0.0/Extracted/GeneratedTypes.lean
    /// $(project)/lampe/Example-0.0.0/Extracted/CustomUserFile.lean
    /// $(project)/lampe/Example-0.0.0/Extracted/CustomDir/CustomUserFileInDir.lean
    fn generate_extracted_module_version_extracted_file(
        &self,
        extracted_module_dir: &Path,
        extracted_code: &LeanFile,
    ) -> Result<(), Error> {
        let output_file = extracted_module_dir.join(extracted_code.file_path.to_lean_path());
        if output_file.exists() && !self.overwrite {
            return Ok(());
        }

        if let Some(output_file_dir) = output_file.parent() {
            fs::create_dir_all(output_file_dir)?;
        }

        let mut result = String::new();

        writeln!(result, "-- {LAMPE_GENERATED_COMMENT}")?;
        writeln!(result)?;

        if extracted_code.is_generated_types() {
            let generated_types_imports = self.get_generated_types_imports();
            for import in generated_types_imports {
                writeln!(result, "import {import}")?;
            }
        } else {
            writeln!(
                result,
                "import «{}-{}».{}.GeneratedTypes",
                &self.noir_package_identifier.name,
                &self.noir_package_identifier.version,
                EXTRACTED_MODULE_NAME,
            )?;
        }

        writeln!(result, "import Lampe")?;
        writeln!(result)?;
        writeln!(result, "open Lampe")?;

        writeln!(result)?;
        result.push_str(&extracted_code.content);

        fs::write(output_file, result)?;

        Ok(())
    }

    fn get_generated_types_imports(&self) -> Vec<String> {
        let mut imports = vec![];

        // Only import from direct dependencies
        for dep in self.local_dependencies.iter() {
            imports.push(format!("«{}-{}».{EXTRACTED_MODULE_NAME}.GeneratedTypes", dep.name, dep.version));
        }

        imports
    }
}

/// Generates all lean files from passed extracted code with project
/// configuration. Current lean files structure is (in pseudo description):
/// |-- <Main package>
/// |  |-- Extracted
/// |  |   |-- GeneratedTypes.lean
/// |  |   |-- Noir extracted code matching file paths as created by user in Noir project
/// |  |-- Extracted.lean
/// |-- <Main package>.lean
/// |--deps
///    |--<Dependency1>
///    |  |-- Structure mirroring main package layout
///    |--<Dependency2>
///    |  |-- ...
///    |-- ...
///
/// # Errors
///
/// - If it cannot generate the Lean files.
pub fn generate_lean_files<H: std::hash::BuildHasher>(
    lampe_root_dir: &Path,
    noir_package_identifier: &NoirPackageIdentifier,
    extracted_code: &[LeanFile],
    extracted_dependencies: HashMap<NoirPackageIdentifier, Vec<LeanFile>, H>,
    external_dependencies: &[NoirPackageIdentifier],
    direct_dependencies: HashMap<NoirPackageIdentifier, Vec<LeanFile>, H>,
    direct_dependencies_with_lampe: Vec<NoirPackageIdentifier>,
    dependency_relationships: HashMap<NoirPackageIdentifier, (Vec<NoirPackageIdentifier>, Vec<NoirPackageIdentifier>)>,
) -> Result<(), Error> {
    let direct_local_dependencies = direct_dependencies.keys().cloned().collect::<Vec<_>>();

    let mut all_direct_dependencies = direct_local_dependencies.clone();
    all_direct_dependencies.extend(direct_dependencies_with_lampe.clone());

    let generator = FileGenerator::new(
        lampe_root_dir,
        noir_package_identifier,
        all_direct_dependencies,
        external_dependencies,
        false,
    );

    generator.generate_lib_file()?;

    let lib_dir = generator.lampe_root_dir.join(format!(
        "{}-{}",
        &generator.noir_package_identifier.name, &generator.noir_package_identifier.version
    ));
    if !lib_dir.exists() {
        fs::create_dir(&lib_dir)?;
    }

    generator.generate_extracted_file(&lib_dir, extracted_code)?;

    let extracted_lib_dir = lib_dir.join(EXTRACTED_MODULE_NAME);
    if !extracted_lib_dir.exists() {
        fs::create_dir(&extracted_lib_dir)?;
    }

    generator
        .generate_extracted_module_version_extracted_files(&extracted_lib_dir, extracted_code)?;

    if !extracted_dependencies.is_empty() {
        let deps_dir = generator.lampe_root_dir.join("deps");
        if !deps_dir.exists() {
            fs::create_dir(&deps_dir)?;
        }

        for (extracted_dependency, lean_files) in &extracted_dependencies {
            let extracted_dep_project_dir = deps_dir.join(format!(
                "{}-{}",
                &extracted_dependency.name, &extracted_dependency.version
            ));

            if !extracted_dep_project_dir.exists() {
                fs::create_dir(&extracted_dep_project_dir)?;
            }

            let extracted_dep_lampe_dir = extracted_dep_project_dir.join("lampe");
            if !extracted_dep_lampe_dir.exists() {
                fs::create_dir(&extracted_dep_lampe_dir)?;
            }

            let extracted_dep_lib_dir = extracted_dep_lampe_dir.join(format!(
                "{}-{}",
                &extracted_dependency.name, &extracted_dependency.version
            ));

            if !extracted_dep_lib_dir.exists() {
                fs::create_dir(&extracted_dep_lib_dir)?;
            }

            let (dep_direct_dep_ids, dep_deps_with_lampe) = dependency_relationships
                .get(&extracted_dependency)
                .cloned()
                .unwrap_or_default();

            let mut all_direct_deps_for_dep = dep_direct_dep_ids.clone();
            all_direct_deps_for_dep.extend(dep_deps_with_lampe.clone());

            let mut all_deps_for_dep = dep_direct_dep_ids.clone();
            all_deps_for_dep.extend(dep_deps_with_lampe.clone());

            let dep_generator = FileGenerator::new(
                &extracted_dep_lampe_dir,
                &extracted_dependency,
                all_direct_deps_for_dep,
                &[], // TODO: ugh
                true,
            );

            dep_generator.generate_lib_file()?;
            dep_generator.generate_extracted_file(&extracted_dep_lib_dir, &lean_files)?;

            let extracted_dep_extracted_dir = extracted_dep_lib_dir.join(EXTRACTED_MODULE_NAME);
            if !extracted_dep_extracted_dir.exists() {
                fs::create_dir(&extracted_dep_extracted_dir)?;
            }

            dep_generator.generate_extracted_module_version_extracted_files(&extracted_dep_extracted_dir, &lean_files)?;

            let mut dep_additional_dependencies: Vec<Box<dyn LeanDependency>> = vec![];

            for dep_direct_dep in &dep_direct_dep_ids {
                if extracted_dependencies.contains_key(dep_direct_dep) {
                    let dep_name = format!("{}-{}", dep_direct_dep.name, dep_direct_dep.version);
                    let dep_path = format!("../../{}/lampe", dep_name);

                    dep_additional_dependencies.push(Box::new(
                        LeanDependencyPath::builder(&dep_name)
                            .path(&dep_path)
                            .build(),
                    ));
                }
            }

            file_generator::lake::generate_lakefile_toml(
                &extracted_dep_lampe_dir,
                &extracted_dependency,
                &dep_additional_dependencies,
                true,
            )?;

            file_generator::lean_toolchain::generate_lean_toolchain(&extracted_dep_lampe_dir, true)?;
        }
    }

    Ok(())
}
