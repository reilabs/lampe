//! This module contains functionality for generating lean files with specified
//! configuration, like: imports, namespaces, etc.

use std::{
    fmt::Write,
    fs,
    path::{self, Path},
};

use itertools::Itertools;

use crate::file_generator::{
    self,
    lake::dependency::{LeanDependency, LeanDependencyPath},
    DependencyInfo,
    Error,
    LeanFile,
    NoirPackageIdentifier,
    EXTRACTED_MODULE_NAME,
    LAMPE_GENERATED_COMMENT,
};

pub mod error;
pub mod file;

/// A container for the context needed to generate Lean files for an extracted
/// Noir project
struct FileGenerator {
    /// The root directory of the Lampe project where files will be generated.
    lampe_root_dir:          path::PathBuf,
    /// The identifier of the Noir package being processed.
    noir_package_identifier: NoirPackageIdentifier,
    /// Information about the standard library, if applicable (if not the
    /// standard library itself)
    stdlib_info:             Option<NoirPackageIdentifier>,
    /// The local dependencies of the Noir package being processed.
    local_dependencies:      Vec<NoirPackageIdentifier>,
    /// The external dependencies of the Noir package being processed.
    external_dependencies:   Vec<NoirPackageIdentifier>,
    /// Configuration option on whether to overwrite existing files.
    overwrite:               bool,
}

impl FileGenerator {
    fn new(
        lampe_root_dir: &Path,
        noir_package_identifier: &NoirPackageIdentifier,
        stdlib_info: Option<NoirPackageIdentifier>,
        local_dependencies: Vec<NoirPackageIdentifier>,
        external_dependencies: &[NoirPackageIdentifier],
        overwrite: bool,
    ) -> Self {
        Self {
            lampe_root_dir: lampe_root_dir.to_path_buf(),
            noir_package_identifier: noir_package_identifier.clone(),
            stdlib_info,
            local_dependencies,
            external_dependencies: external_dependencies.to_vec(),
            overwrite,
        }
    }

    /// Generates Lean's entrypoint file ready for user's code.
    // Example path: $(project)/lampe/Example-0.0.0.lean
    fn generate_lib_file(&self) -> Result<(), Error> {
        let output_file = self.lampe_root_dir.join(format!(
            "{}-{}.lean",
            &self.noir_package_identifier.name, &self.noir_package_identifier.version
        ));
        if output_file.exists() && !self.overwrite {
            return Ok(());
        }

        let mut result = String::new();

        writeln!(result, "-- {LAMPE_GENERATED_COMMENT}")?;
        writeln!(result)?;
        writeln!(
            result,
            "import «{}-{}».{}",
            &self.noir_package_identifier.name,
            &self.noir_package_identifier.version,
            EXTRACTED_MODULE_NAME
        )?;
        writeln!(result)?;

        fs::write(output_file, result)?;

        Ok(())
    }

    /// Generates extracted module file that groups all imports of extracted and
    /// generated code for simple usage.
    // Example path: $(project)/lampe/Example-0.0.0/Extracted.lean
    fn generate_extracted_file(
        &self,
        lib_dir: &Path,
        extracted_code: &[LeanFile],
    ) -> Result<(), Error> {
        let output_file = lib_dir.join(format!("{EXTRACTED_MODULE_NAME}.lean"));

        if output_file.exists() {
            let file_contents = fs::read_to_string(&output_file)?;
            if !file_contents.contains(LAMPE_GENERATED_COMMENT) {
                eprintln!(
                    "Encountered file {} that does not appear to be generated by Lampe but would \
                     be overwritten; skipping",
                    &output_file.display()
                );
                return Ok(());
            } else if !self.overwrite {
                return Ok(());
            }
        }

        if output_file.exists() && !self.overwrite {
            return Ok(());
        }

        if let Some(parent_dir) = output_file.parent() {
            fs::create_dir_all(parent_dir)?;
        }

        let mut result = String::new();

        writeln!(result, "-- {LAMPE_GENERATED_COMMENT}")?;
        writeln!(result)?;

        // Import all the files in this project
        for import in extracted_code
            .iter()
            .map(|file| file.file_path.to_lean_import())
            .sorted()
        {
            writeln!(
                result,
                "import «{}-{}».{}.{}",
                &self.noir_package_identifier.name,
                &self.noir_package_identifier.version,
                EXTRACTED_MODULE_NAME,
                import
            )?;
        }

        // Import the `Extracted` file for each of the dependencies
        for extracted_module in self.local_dependencies.iter().sorted() {
            writeln!(
                result,
                "import «{}-{}».{}",
                &extracted_module.name, &extracted_module.version, EXTRACTED_MODULE_NAME,
            )?;
        }

        // Import the stdlib `Extracted` file (if we ar enot stdlib)
        if let Some(stdlib_info) = &self.stdlib_info {
            writeln!(
                result,
                "import «{}-{}».{}",
                stdlib_info.name, stdlib_info.version, EXTRACTED_MODULE_NAME,
            )?;
        }

        result.push('\n');
        writeln!(
            result,
            "namespace «{}-{}»",
            &self.noir_package_identifier.name, &self.noir_package_identifier.version
        )?;
        result.push('\n');

        // Print the concatenated env
        write!(result, "def env := ")?;

        let extracted_env = extracted_code
            .iter()
            .filter(|file| !file.is_generated_types())
            .map(|file| file.file_path.to_lean_import())
            .map(|import| format!("{import}.env"))
            .sorted()
            .join("\n  ++ ");

        let dependency_env = self
            .external_dependencies
            .iter()
            .sorted()
            .map(|extracted_module| {
                format!(
                    "«{}-{}».env",
                    &extracted_module.name, &extracted_module.version,
                )
            })
            .join("\n  ++ ");

        let std_env = if let Some(stdlib_info) = &self.stdlib_info {
            format!("«{}-{}».env", &stdlib_info.name, &stdlib_info.version)
        } else {
            String::new()
        };

        let mut env_parts = [extracted_env, dependency_env, std_env]
            .into_iter()
            .filter(|s| !s.is_empty());

        write!(result, "{}", env_parts.join("\n  ++ "))?;

        writeln!(result)?;

        fs::write(output_file, result)?;

        Ok(())
    }

    /// Generates main extracted project's lean files using code generated by
    /// Lampe based on Noir's project. It keeps original names and relative
    /// path from Noir's project changing naming to CamelCase.
    fn generate_extracted_module_version_extracted_files(
        &self,
        extracted_module_dir: &Path,
        extracted_code: &[LeanFile],
    ) -> Result<(), Error> {
        for lean_file in extracted_code {
            self.generate_extracted_module_version_extracted_file(extracted_module_dir, lean_file)?;
        }

        Ok(())
    }

    /// Generates single main extracted project Lean's file out from passed
    /// generated code.
    // Example paths:
    // $(project)/lampe/Example-0.0.0/Extracted/Main.lean
    // $(project)/lampe/Example-0.0.0/Extracted/GeneratedTypes.lean
    // $(project)/lampe/Example-0.0.0/Extracted/CustomUserFile.lean
    // $(project)/lampe/Example-0.0.0/Extracted/CustomDir/CustomUserFileInDir.lean
    fn generate_extracted_module_version_extracted_file(
        &self,
        extracted_module_dir: &Path,
        extracted_code: &LeanFile,
    ) -> Result<(), Error> {
        let output_file = extracted_module_dir.join(extracted_code.file_path.to_lean_path());
        if output_file.exists() && !self.overwrite {
            return Ok(());
        }

        if let Some(output_file_dir) = output_file.parent() {
            fs::create_dir_all(output_file_dir)?;
        }

        let mut result = String::new();

        writeln!(result, "-- {LAMPE_GENERATED_COMMENT}")?;
        writeln!(result)?;

        if extracted_code.is_generated_types() {
            let generated_types_imports = self.get_generated_types_imports();
            for import in generated_types_imports {
                writeln!(result, "import {import}")?;
            }
        } else {
            writeln!(
                result,
                "import «{}-{}».{}.GeneratedTypes",
                &self.noir_package_identifier.name,
                &self.noir_package_identifier.version,
                EXTRACTED_MODULE_NAME,
            )?;
        }

        writeln!(result, "import Lampe")?;
        writeln!(result)?;
        writeln!(result, "open Lampe")?;

        writeln!(result)?;
        result.push_str(&extracted_code.content);

        fs::write(output_file, result)?;

        Ok(())
    }

    fn get_generated_types_imports(&self) -> Vec<String> {
        let mut imports = vec![];

        if let Some(stdlib_info) = &self.stdlib_info {
            imports.push(format!(
                "«{}-{}».{EXTRACTED_MODULE_NAME}.GeneratedTypes",
                stdlib_info.name, stdlib_info.version
            ));
        }

        // Only import from direct dependencies
        for dep in self.local_dependencies.iter().sorted() {
            imports.push(format!(
                "«{}-{}».{EXTRACTED_MODULE_NAME}.GeneratedTypes",
                dep.name, dep.version
            ));
        }

        imports
    }
}

/// Creates directory if it doesn't exist
fn ensure_directory_exists(dir: &Path) -> Result<(), Error> {
    if !dir.exists() {
        fs::create_dir(dir)?;
    }
    Ok(())
}

/// Generates main package files and directories
fn process_root_package(
    generator: &FileGenerator,
    extracted_code: &[LeanFile],
) -> Result<(), Error> {
    generator.generate_lib_file()?;

    let lib_dir = generator.lampe_root_dir.join(format!(
        "{}-{}",
        &generator.noir_package_identifier.name, &generator.noir_package_identifier.version
    ));
    ensure_directory_exists(&lib_dir)?;

    generator.generate_extracted_file(&lib_dir, extracted_code)?;

    let extracted_lib_dir = lib_dir.join(EXTRACTED_MODULE_NAME);
    ensure_directory_exists(&extracted_lib_dir)?;

    generator
        .generate_extracted_module_version_extracted_files(&extracted_lib_dir, extracted_code)?;

    Ok(())
}

/// Processes a single dependency and generates its files
fn process_dependency<H: std::hash::BuildHasher>(
    deps_dir: &Path,
    extracted_dependency: &NoirPackageIdentifier,
    stdlib_info: Option<&NoirPackageIdentifier>,
    lean_files: &[LeanFile],
    dependency_info: &DependencyInfo<H>,
    overwrite: bool,
) -> Result<(), Error> {
    let extracted_dep_project_dir = deps_dir.join(format!(
        "{}-{}",
        &extracted_dependency.name, &extracted_dependency.version
    ));
    ensure_directory_exists(&extracted_dep_project_dir)?;

    let extracted_dep_lampe_dir = extracted_dep_project_dir.join("lampe");
    ensure_directory_exists(&extracted_dep_lampe_dir)?;

    let extracted_dep_lib_dir = extracted_dep_lampe_dir.join(format!(
        "{}-{}",
        &extracted_dependency.name, &extracted_dependency.version
    ));
    ensure_directory_exists(&extracted_dep_lib_dir)?;

    let (dep_direct_dep_ids, dep_deps_with_lampe) = dependency_info
        .dependency_relationships
        .get(extracted_dependency)
        .cloned()
        .unwrap_or_default();

    let mut all_direct_deps_for_dep = dep_direct_dep_ids.clone();
    all_direct_deps_for_dep.extend(dep_deps_with_lampe.clone());

    let dep_generator = FileGenerator::new(
        &extracted_dep_lampe_dir,
        extracted_dependency,
        stdlib_info.cloned(),
        all_direct_deps_for_dep,
        &dep_deps_with_lampe,
        overwrite,
    );

    dep_generator.generate_lib_file()?;
    dep_generator.generate_extracted_file(&extracted_dep_lib_dir, lean_files)?;

    let extracted_dep_extracted_dir = extracted_dep_lib_dir.join(EXTRACTED_MODULE_NAME);
    ensure_directory_exists(&extracted_dep_extracted_dir)?;

    dep_generator.generate_extracted_module_version_extracted_files(
        &extracted_dep_extracted_dir,
        lean_files,
    )?;

    generate_dependency_additional_files(
        &extracted_dep_lampe_dir,
        stdlib_info,
        extracted_dependency,
        &dep_direct_dep_ids,
        dependency_info,
    )?;

    Ok(())
}

/// Generates additional dependency files (lakefile and lean-toolchain)
fn generate_dependency_additional_files<H: std::hash::BuildHasher>(
    extracted_dep_lampe_dir: &Path,
    stdlib_info: Option<&NoirPackageIdentifier>,
    extracted_dependency: &NoirPackageIdentifier,
    dep_direct_dep_ids: &[NoirPackageIdentifier],
    dependency_info: &DependencyInfo<H>,
) -> Result<(), Error> {
    let mut dep_additional_dependencies: Vec<Box<dyn LeanDependency>> = vec![];

    for dep_direct_dep in dep_direct_dep_ids {
        if dependency_info.extracted_dependencies.contains_key(dep_direct_dep) {
            let dep_name = format!("{}-{}", dep_direct_dep.name, dep_direct_dep.version);
            let dep_path = format!("../../{dep_name}/lampe");

            dep_additional_dependencies.push(Box::new(
                LeanDependencyPath::builder(&dep_name).path(&dep_path).build(),
            ));
        }
    }

    file_generator::lake::generate_lakefile_toml(
        extracted_dep_lampe_dir,
        stdlib_info,
        extracted_dependency,
        &dep_additional_dependencies,
        true,
    )?;

    file_generator::lean_toolchain::generate_lean_toolchain(extracted_dep_lampe_dir, true)?;

    Ok(())
}

/// Processes all dependencies and generates their files
fn process_dependencies<H: std::hash::BuildHasher>(
    lampe_root_dir: &Path,
    stdlib_info: Option<&NoirPackageIdentifier>,
    dependency_info: &DependencyInfo<H>,
    overwrite: bool,
) -> Result<(), Error> {
    if dependency_info.extracted_dependencies.is_empty() {
        return Ok(());
    }

    let deps_dir = lampe_root_dir.join("deps");
    ensure_directory_exists(&deps_dir)?;

    for (extracted_dependency, lean_files) in &dependency_info.extracted_dependencies {
        process_dependency(
            &deps_dir,
            extracted_dependency,
            stdlib_info,
            lean_files,
            dependency_info,
            overwrite,
        )?;
    }

    Ok(())
}

/// Generates all lean files from passed extracted code with project
/// configuration.
///
/// # Errors
///
/// - If it cannot generate the Lean files.
// Current lean files structure is (in pseudo description):
// |-- <Main package>
// |  |-- Extracted
// |  |   |-- GeneratedTypes.lean
// |  |   |-- Noir extracted code matching file paths as created by user in Noir project
// |  |-- Extracted.lean
// |-- <Main package>.lean
// |--deps
//    |--<Dependency1>
//    |  |-- Structure mirroring main package layout
//    |--<Dependency2>
//    |  |-- ...
//    |-- ...
pub fn generate_lean_files<H: std::hash::BuildHasher>(
    lampe_root_dir: &Path,
    noir_package_identifier: &NoirPackageIdentifier,
    stdlib_info: Option<&NoirPackageIdentifier>,
    extracted_code: &[LeanFile],
    dependency_info: &DependencyInfo<H>,
    external_dependencies: &[NoirPackageIdentifier],
    overwrite: bool,
) -> Result<(), Error> {
    let direct_local_dependencies = dependency_info
        .direct_dependencies
        .keys()
        .cloned()
        .collect::<Vec<_>>();

    let mut all_direct_dependencies = direct_local_dependencies.clone();
    all_direct_dependencies.extend(dependency_info.direct_dependencies_with_lampe.clone());

    let generator = FileGenerator::new(
        lampe_root_dir,
        noir_package_identifier,
        stdlib_info.cloned(),
        all_direct_dependencies,
        external_dependencies,
        overwrite,
    );

    process_root_package(&generator, extracted_code)?;
    process_dependencies(lampe_root_dir, stdlib_info, dependency_info, overwrite)?;

    Ok(())
}
