//! This module contains functionality for interacting with the Lampe output.

use crate::file_generator::error::{Error, Result};
use convert_case::{Case, Casing};
use itertools::Itertools;
use nargo::package::Package;
use std::collections::HashMap;
use std::fs;
use std::path::{Path, PathBuf};

pub mod error;
mod lake;
mod lean;
mod lean_toolchain;

const LAMPE_DIR_NAME: &str = "lampe";
const EXTRACTED_LIB_NAME: &str = "Extracted";
const LAMPE_GENERATED_COMMENT: &str = "Generated by lampe";

#[derive(Eq, Hash, PartialEq)]
pub struct LeanFilePath {
    noir_segments: Vec<String>,
}

impl LeanFilePath {
    pub fn from_noir_path(path: &Path) -> Self {
        let components = path.components().map(|c| c.as_os_str().to_string_lossy().to_string());
        let mut segments: Vec<String> = components
            .skip_while(|c| c != "src")
            .skip(1) // Skip the "src" part itself
            .collect();

        if let Some(last) = segments.last_mut() {
            *last = last.trim_end_matches(".nr").to_owned();
        }

        Self {
            noir_segments: segments,
        }
    }

    pub fn type_path() -> Self {
        Self {
            noir_segments: vec!["generated_types".to_string()],
        }
    }

    pub fn is_type_path(&self) -> bool {
        self.noir_segments.len() == 1 && self.noir_segments[0] == "generated_types"
    }

    pub fn to_lean_path(&self) -> PathBuf {
        self.noir_segments
            .iter()
            .map(|segment| segment.to_case(Case::Pascal))
            .collect::<PathBuf>()
            .with_extension("lean")
    }

    pub fn to_lean_import(&self) -> String {
        self.noir_segments
            .iter()
            .map(|segment| segment.to_case(Case::Pascal))
            .join(".")
    }
}

type LeanFileContent = String;

pub fn lampe_project(
    noir_root_dir: &Path,
    package: &Package,
    extracted_files: &HashMap<LeanFilePath, LeanFileContent>,
) -> Result<()> {
    let lampe_root_dir = noir_root_dir.join(LAMPE_DIR_NAME);

    if !lampe_root_dir.exists() {
        fs::create_dir(&lampe_root_dir)?;
    }

    generate_package_structure(&lampe_root_dir, package, extracted_files)?;

    Ok(())
}

fn generate_package_structure(
    lampe_root_dir: &Path,
    package: &Package,
    extracted_files: &HashMap<LeanFilePath, LeanFileContent>,
) -> Result<()> {
    lake::generate_lakefile_toml(lampe_root_dir, package, false)?;
    lean_toolchain::generate_lean_toolchain(lampe_root_dir, false)?;

    lean::generate_lean_files(lampe_root_dir, package, extracted_files)?;

    Ok(())
}
