//! This module contains functionality for generating files by Lampe tool. It is
//! using content extracted out of Noir project.

use std::{collections::HashMap, fs, path::Path};

use nargo::package::Package;
use nargo_toml::DependencyConfig;

use crate::{
    file_generator::{
        error::{Error, Result},
        lake::dependency::{LeanDependency, LeanDependencyGit, LeanDependencyPath},
    },
    file_generator_error::Error::LakeRequireGeneration,
};

pub mod error;
pub mod lake;
pub mod lean;
mod lean_toolchain;

pub use crate::file_generator::lean::file::{to_import_from_noir_path, LeanFile};

const LAMPE_DIR_NAME: &str = "lampe";
const EXTRACTED_MODULE_NAME: &str = "Extracted";
const DEPENDENCIES_MODULE_NAME: &str = "Dependencies";
const LAMPE_GENERATED_COMMENT: &str = "Generated by lampe";

#[derive(Hash, Eq, PartialEq, Ord, PartialOrd, Clone, Debug)]
pub struct NoirPackageIdentifier {
    pub name:    String,
    pub version: String,
}

/// This function generates whole `lampe` directory with Lampe's structure.
pub fn lampe_project(
    target_dir: &Path,
    noir_package_identifier: &NoirPackageIdentifier,
    additional_dependencies: &[Box<dyn LeanDependency>],
    extracted_code: &[LeanFile],
    extracted_dependencies: HashMap<NoirPackageIdentifier, Vec<LeanFile>>,
) -> Result<()> {
    let lampe_root_dir = target_dir.join(LAMPE_DIR_NAME);

    if !lampe_root_dir.exists() {
        fs::create_dir(&lampe_root_dir)?;
    }

    lake::generate_lakefile_toml(
        &lampe_root_dir,
        noir_package_identifier,
        additional_dependencies,
        false,
    )?;
    lean_toolchain::generate_lean_toolchain(&lampe_root_dir, false)?;
    lean::generate_lean_files(
        &lampe_root_dir,
        noir_package_identifier,
        extracted_code,
        extracted_dependencies,
    )?;

    Ok(())
}

/// Convert passed Noir's dependency into Lean's dependency
pub fn get_lean_dependency(
    dependency_name: &str,
    dependency_config: &DependencyConfig,
) -> Result<Box<dyn LeanDependency>> {
    match dependency_config {
        DependencyConfig::Github {
            git,
            tag,
            directory,
        } => {
            let directory = directory.clone().unwrap_or(String::new());
            let path = Path::new(&directory).join(LAMPE_DIR_NAME);
            let subdir = path.to_str().ok_or(LakeRequireGeneration(format!(
                "Error preparing subdir: {path:?}"
            )))?;

            Ok(Box::new(
                LeanDependencyGit::builder(dependency_name)
                    .git(git)
                    .rev(tag)
                    .subdir(subdir)
                    .build(),
            ))
        }
        DependencyConfig::Path { path } => {
            let path = Path::new(path);
            let path = if path.is_relative() {
                // If the path is relative we need to get parent dir as Nargo.toml is there
                Path::new("..").join(path)
            } else {
                path.into()
            };
            let path = path.join(LAMPE_DIR_NAME);
            let path = path.to_str().ok_or(LakeRequireGeneration(format!(
                "Error preparing path: {path:?}"
            )))?;

            Ok(Box::new(
                LeanDependencyPath::builder(dependency_name).path(path).build(),
            ))
        }
    }
}

/// Checks if Noir's package is also Lampe's project.
pub fn has_lampe(package: &Package) -> bool {
    let package_lampe_dir = package.root_dir.join(LAMPE_DIR_NAME);
    package_lampe_dir.exists() && package_lampe_dir.is_dir()
}

/// Returns name of the generated Lean's package in Lampe's project.
pub fn read_lampe_package_name(package: &Package) -> Result<String> {
    let package_lampe_dir = package.root_dir.join(LAMPE_DIR_NAME);
    lake::read_package_name(&package_lampe_dir)
}
