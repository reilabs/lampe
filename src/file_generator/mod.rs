//! This module contains functionality for generating files by Lampe tool. It is
//! using content extracted out of Noir project.

use std::{collections::HashMap, fs, path::Path};

use nargo::package::Package;
use nargo_toml::DependencyConfig;

use crate::{
    constants::{NOIR_STDLIB_PACKAGE_NAME, NONE_DEPENDENCY_VERSION, STDLIB_TOML},
    file_generator::{
        error::{Error, Result},
        lake::dependency::{LeanDependency, LeanDependencyGit, LeanDependencyPath},
    },
    file_generator_error::Error::LakeRequireGeneration,
    lean::{LEAN_QUOTE_END, LEAN_QUOTE_START},
};

pub mod error;
pub mod lake;
pub mod lean;
mod lean_toolchain;

pub use crate::file_generator::lean::file::{to_import_from_noir_path, LeanFile};

const LAMPE_DIR_NAME: &str = "lampe";
const EXTRACTED_MODULE_NAME: &str = "Extracted";
const LAMPE_GENERATED_COMMENT: &str = "Generated by lampe";

#[derive(Hash, Eq, PartialEq, Ord, PartialOrd, Clone, Debug)]
pub struct NoirPackageIdentifier {
    pub name:    String,
    pub version: String,
}

/// Stores the information about dependencies needed for generating Lampe's
/// project.
pub struct DependencyInfo<H: std::hash::BuildHasher> {
    /// The list of all dependencies (including transitive ones)
    pub all_dependencies:               Vec<Box<dyn LeanDependency>>,
    /// The list of all dependencies that did not already have Lampe extracted
    pub extracted_dependencies:         HashMap<NoirPackageIdentifier, Vec<LeanFile>, H>,
    /// The list of all direct dependencies (not including the standard library)
    pub direct_dependencies:            HashMap<NoirPackageIdentifier, Vec<LeanFile>, H>,
    /// A list of direct dependencies (not including the standard library) that
    /// have Lampe already extracted
    pub direct_dependencies_with_lampe: Vec<NoirPackageIdentifier>,
    /// A graph containing the relationships between dependencies
    pub dependency_relationships:
        HashMap<NoirPackageIdentifier, (Vec<NoirPackageIdentifier>, Vec<NoirPackageIdentifier>), H>,
}

impl NoirPackageIdentifier {
    /// Formats the package identifier as `name-version`.
    #[must_use]
    pub fn formatted(&self, use_quotes: bool) -> String {
        if use_quotes {
            format!(
                "{}{}-{}{}",
                LEAN_QUOTE_START, self.name, self.version, LEAN_QUOTE_END
            )
        } else {
            format!("{}-{}", self.name, self.version)
        }
    }
}

/// This function generates whole `lampe` directory with Lampe's structure.
///
/// # Errors
///
/// - If the lampe project cannot be loaded.
pub fn lampe_project<H: std::hash::BuildHasher>(
    target_dir: &Path,
    noir_package_identifier: &NoirPackageIdentifier,
    dependency_info: &DependencyInfo<H>,
    extracted_code: &[LeanFile],
) -> Result<()> {
    let lampe_root_dir = target_dir.join(LAMPE_DIR_NAME);

    if !lampe_root_dir.exists() {
        fs::create_dir(&lampe_root_dir)?;
    }

    let stdlib_info = get_stdlib_info(noir_package_identifier);

    lake::generate_lakefile_toml(
        &lampe_root_dir,
        stdlib_info.as_ref(),
        noir_package_identifier,
        &dependency_info.all_dependencies,
        false,
    )?;
    lean_toolchain::generate_lean_toolchain(&lampe_root_dir, false)?;

    let external_dependencies = &dependency_info
        .all_dependencies
        .iter()
        .map(|x| x.noir_package_identifier())
        .collect::<Result<Vec<_>>>()?;

    lean::generate_lean_files(
        &lampe_root_dir,
        noir_package_identifier,
        stdlib_info.as_ref(),
        extracted_code,
        dependency_info,
        external_dependencies,
    )?;

    Ok(())
}

#[must_use]
pub fn get_stdlib_info(
    noir_package_identifier: &NoirPackageIdentifier,
) -> Option<NoirPackageIdentifier> {
    if noir_package_identifier.name == NOIR_STDLIB_PACKAGE_NAME {
        None
    } else if let Ok(toml_content) = STDLIB_TOML.parse::<toml::Table>() {
        if let toml::Value::Table(package_info) = &toml_content["package"] {
            if let toml::Value::String(name) = &package_info["name"] {
                let version = package_info["version"].as_str().unwrap_or(NONE_DEPENDENCY_VERSION);

                Some(NoirPackageIdentifier {
                    name:    name.clone(),
                    version: version.to_string(),
                })
            } else {
                None
            }
        } else {
            None
        }
    } else {
        eprintln!(
            "Could not read standard library config; not including standard library as dependency"
        );
        None
    }
}

/// Convert passed Noir's dependency into Lean's dependency
///
/// # Errors
///
/// - If the lean dependency cannot be loaded.
pub fn get_lean_dependency(
    dependency_name: &str,
    dependency_config: &DependencyConfig,
) -> Result<Box<dyn LeanDependency>> {
    match dependency_config {
        DependencyConfig::Github {
            git,
            tag,
            directory,
        } => {
            let directory = directory.clone().unwrap_or(String::new());
            let path = Path::new(&directory).join(LAMPE_DIR_NAME);
            let subdir = path.to_str().ok_or(LakeRequireGeneration(format!(
                "Error preparing subdir: {}",
                path.display()
            )))?;

            Ok(Box::new(
                LeanDependencyGit::builder(dependency_name)
                    .git(git)
                    .rev(tag)
                    .subdir(subdir)
                    .build(),
            ))
        }
        DependencyConfig::Path { path } => {
            let path = Path::new(path);
            let path = if path.is_relative() {
                Path::new("..").join(path)
            } else {
                path.into()
            };
            let path = path.join(LAMPE_DIR_NAME);
            let path = path.to_str().ok_or(LakeRequireGeneration(format!(
                "Error preparing path: {}",
                path.display()
            )))?;

            Ok(Box::new(
                LeanDependencyPath::builder(dependency_name).path(path).build(),
            ))
        }
    }
}

/// Checks if Noir's package is also Lampe's project.
#[must_use]
pub fn has_lampe(package: &Package) -> bool {
    let package_lampe_dir = package.root_dir.join(LAMPE_DIR_NAME);
    package_lampe_dir.exists() && package_lampe_dir.is_dir()
}

/// Returns name of the generated Lean's package in Lampe's project.
///
/// # Errors
///
/// - If the lake package name cannot be read.
pub fn read_lampe_package_name(package: &Package) -> Result<String> {
    let package_lampe_dir = package.root_dir.join(LAMPE_DIR_NAME);
    lake::read_package_name(&package_lampe_dir)
}
