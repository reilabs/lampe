//! A utility for extracting [Noir](https://noir-lang.org) programs to
//! equivalent definitions in the [Lean](https://lean-lang.org) theorem prover
//! and programming language.
//!
//! # Limitations
//!
//! It currently only supports single-file programs, pending further expansion
//! to support full Noir projects. The stdlib functions properly at this stage.

#![warn(clippy::all, clippy::cargo, clippy::pedantic)]
// These occur in our Noir dependencies and cannot be avoided.
#![allow(clippy::multiple_crate_versions)]

use std::{
    collections::HashSet,
    fs,
    panic,
    path::{Path, PathBuf},
    process::ExitCode,
};

use clap::{arg, Parser};
use lampe::{noir_error, noir_error::file, Error, Project};
use toml::Value;

/// The default Noir project path for the CLI to extract from.
const DEFAULT_NOIR_PROJECT_PATH: &str = "./";

/// A utility to extract Noir code to Lean in order to enable the formal
/// verification of Noir programs.
#[derive(Clone, Debug, Parser)]
pub struct ProgramOptions {
    /// The root of the Noir project to extract.
    #[arg(long, value_name = "PATH", default_value = DEFAULT_NOIR_PROJECT_PATH, value_parser = parse_path)]
    pub root: PathBuf,

    /// The root of the Lampe project output.
    #[arg(long, value_name = "TARGET", value_parser = parse_path)]
    pub target: Option<PathBuf>,

    /// Testing mode?
    #[arg(long)]
    pub test_mode: bool,

    /// Overwrite all files if they exist, even if they were not generated by
    /// Lampe. Note that generated files are overwritten by default, even
    /// without the flag set.
    #[arg(long)]
    pub overwrite: bool,
}

/// The main function for the CLI utility, responsible for parsing program
/// options and handing them off to the actual execution of the tool.
fn main() -> ExitCode {
    // Parse args and hand-off immediately.
    let args = ProgramOptions::parse();
    if args.test_mode {
        run_test_mode(&args).unwrap_or_else(|err| {
            eprintln!("Error Encountered: {err}");
            ExitCode::FAILURE
        })
    } else {
        run(&args).unwrap_or_else(|err| {
            eprintln!("Error Encountered: {err:?}");
            ExitCode::FAILURE
        })
    }
}

/// A particular testing mode for the main function used to run through Noir
/// frontend tests
///
/// # Errors
///
/// - [`Error`] If the source directory is not readable
pub fn run_test_mode(args: &ProgramOptions) -> Result<ExitCode, Error> {
    let list = fs::read_dir(&args.root).map_err(|_| {
        file::Error::Other(format!(
            "Unable to read directory {}",
            args.root.as_os_str().display()
        ))
    })?;

    for entry in list {
        let entry =
            entry.map_err(|err| file::Error::Other(format!("Unable to read entry: {err:?}")))?;
        if !entry
            .metadata()
            .map_err(|_| {
                file::Error::Other(format!(
                    "Unable to read metadata of {}",
                    entry.file_name().display()
                ))
            })?
            .is_dir()
        {
            continue;
        }

        let result = panic::catch_unwind(|| {
            Project::new(entry.path(), entry.path())?.extract(args.overwrite)
        });

        match result {
            Err(panic) => {
                println!(
                    "游댮 Panic                 {}\t{}",
                    entry.path().to_str().unwrap_or(""),
                    panic
                        .downcast::<String>()
                        .unwrap_or(Box::new("<no info>".to_string()))
                );
            }
            Ok(Err(Error::EmitError(noir_error::emit::Error::UnsupportedFeature(feature)))) => {
                println!(
                    "游리 Unsupported           {}\t{}",
                    entry.path().to_str().unwrap_or(""),
                    feature
                );
            }
            Ok(Err(Error::EmitError(err))) => {
                println!(
                    "游댮 Emit Error            {}\t{:?}",
                    entry.path().to_str().unwrap_or(""),
                    err
                );
            }
            Ok(Err(Error::CompilationError(_))) => {
                println!(
                    "游리 Compile Error         {}",
                    entry.path().to_str().unwrap_or("")
                );
            }
            Ok(Err(Error::FileError(err))) => {
                println!(
                    "游리 IO Error              {}\t{:?}",
                    entry.path().to_str().unwrap_or(""),
                    err
                );
            }
            Ok(Err(Error::FileGenerationError(err))) => {
                println!(
                    "游리 File generating error {}\t{:?}",
                    entry.path().to_str().unwrap_or(""),
                    err
                );
            }
            Ok(Err(Error::NoirProjectError(err))) => {
                println!(
                    "游리 Noir project error    {}\t{:?}",
                    entry.path().to_str().unwrap_or(""),
                    err
                );
            }
            Ok(Err(err)) => {
                println!("游리 Error                 {err:?}");
            }
            Ok(Ok(_)) => {
                println!(
                    "游릭 Pass                  {}",
                    entry.path().to_str().unwrap_or("")
                );
            }
        }
    }
    Ok(ExitCode::SUCCESS)
}

/// The main execution of the CLI utility. Should be called directly from the
/// `main` function of the application.
///
/// # Errors
///
/// - [`Error`] if the extraction process fails for any reason.
pub fn run(args: &ProgramOptions) -> Result<ExitCode, Error> {
    let noir_root_path = args.root.clone();
    if is_workspace_root(&noir_root_path)? {
        return run_workspace_root(&noir_root_path, args);
    }

    let target_path = args.target.clone().unwrap_or(noir_root_path.clone());
    extract_project(noir_root_path, target_path, args.overwrite, None)?;

    Ok(ExitCode::SUCCESS)
}

// Copied from: https://github.com/noir-lang/noir/blob/5071093f9b51e111a49a5f78d827774ef8e80c74/tooling/nargo_cli/src/cli/mod.rs#L301
/// Parses a path and turns it into an absolute one by joining to the current
/// directory.
fn parse_path(path: &str) -> Result<PathBuf, String> {
    use fm::NormalizePath;
    let mut path: PathBuf = path.parse().map_err(|e| format!("failed to parse path: {e}"))?;
    if !path.is_absolute() {
        path = std::env::current_dir().unwrap().join(path).normalize();
    }
    Ok(path)
}

fn extract_project(
    noir_root_path: PathBuf,
    target_path: PathBuf,
    overwrite: bool,
    lampe_targets: Option<&HashSet<PathBuf>>,
) -> Result<(), Error> {
    let project = Project::new(noir_root_path, target_path)?;
    let project = if let Some(targets) = lampe_targets {
        project.with_lampe_targets(targets.clone())
    } else {
        project
    };
    let result = project.extract(overwrite)?;

    if result.has_warnings() {
        for warning in &result.warnings {
            eprintln!("{warning:?}");
        }
    }

    Ok(())
}

fn is_workspace_root(root: &Path) -> Result<bool, Error> {
    if has_workspace_manifest(root)? {
        return Ok(true);
    }

    if root.join("Nargo.toml").is_file() || root.join("lampe").is_dir() {
        return Ok(false);
    }

    Ok(!list_workspace_crates(root)?.is_empty())
}

fn has_workspace_manifest(root: &Path) -> Result<bool, Error> {
    let manifest_path = root.join("Nargo.toml");
    if !manifest_path.is_file() {
        return Ok(false);
    }

    let contents = fs::read_to_string(&manifest_path).map_err(|err| {
        file::Error::Other(format!(
            "Unable to read workspace manifest {}: {err:?}",
            manifest_path.as_os_str().display()
        ))
    })?;
    let parsed: Value = toml::from_str(&contents).map_err(|err| {
        file::Error::Other(format!(
            "Unable to parse workspace manifest {}: {err:?}",
            manifest_path.as_os_str().display()
        ))
    })?;

    Ok(parsed.get("workspace").is_some())
}

fn list_workspace_crates(root: &Path) -> Result<Vec<PathBuf>, Error> {
    let list = fs::read_dir(root).map_err(|_| {
        file::Error::Other(format!(
            "Unable to read directory {}",
            root.as_os_str().display()
        ))
    })?;

    let mut crates = Vec::new();
    for entry in list {
        let entry =
            entry.map_err(|err| file::Error::Other(format!("Unable to read entry: {err:?}")))?;
        if !entry
            .metadata()
            .map_err(|_| {
                file::Error::Other(format!(
                    "Unable to read metadata of {}",
                    entry.file_name().display()
                ))
            })?
            .is_dir()
        {
            continue;
        }

        let path = entry.path();
        if path.join("Nargo.toml").is_file() {
            crates.push(path);
        }
    }

    crates.sort();
    Ok(crates)
}

fn select_workspace_crates(root: &Path) -> Result<Vec<PathBuf>, Error> {
    let crates = list_workspace_crates(root)?;
    if crates.is_empty() {
        return Err(file::Error::Other(format!(
            "No Nargo.toml files found under {}",
            root.as_os_str().display()
        ))
        .into());
    }

    // If any crates already have Lampe output, only re-extract those.
    let crates_with_lampe: Vec<PathBuf> = crates
        .iter()
        .filter(|path| path.join("lampe").is_dir())
        .cloned()
        .collect();

    if crates_with_lampe.is_empty() {
        return Err(file::Error::Other(format!(
            "No workspace crates with lampe output found under {}",
            root.as_os_str().display()
        ))
        .into());
    }

    Ok(crates_with_lampe)
}

fn run_workspace_root(root: &Path, args: &ProgramOptions) -> Result<ExitCode, Error> {
    use fm::NormalizePath;

    let crates = select_workspace_crates(root)?;

    let lampe_targets: HashSet<PathBuf> = crates.iter().map(NormalizePath::normalize).collect();

    for crate_root in crates {
        let target_path = match &args.target {
            Some(base) => {
                let crate_name = crate_root.file_name().ok_or_else(|| {
                    file::Error::Other(format!(
                        "Unable to resolve crate directory name for {}",
                        crate_root.as_os_str().display()
                    ))
                })?;
                let target = base.join(crate_name);
                if !target.exists() {
                    fs::create_dir_all(&target).map_err(|err| {
                        file::Error::Other(format!(
                            "Unable to create target directory {}: {err:?}",
                            target.as_os_str().display()
                        ))
                    })?;
                }
                target
            }
            None => crate_root.clone(),
        };

        extract_project(
            crate_root,
            target_path,
            args.overwrite,
            Some(&lampe_targets),
        )?;
    }

    Ok(ExitCode::SUCCESS)
}

#[cfg(test)]
mod tests {
    use std::{
        fs,
        path::{Path, PathBuf},
    };

    use tempfile::TempDir;

    use super::{is_workspace_root, list_workspace_crates, select_workspace_crates};

    fn write_nargo_toml(dir: &Path, contents: &str) {
        fs::write(dir.join("Nargo.toml"), contents).expect("write Nargo.toml");
    }

    fn create_crate(root: &Path, name: &str, with_lampe: bool) -> PathBuf {
        let crate_path = root.join(name);
        fs::create_dir_all(&crate_path).expect("create crate dir");
        write_nargo_toml(&crate_path, "[package]\nname = \"test\"\ntype = \"bin\"\n");
        if with_lampe {
            fs::create_dir_all(crate_path.join("lampe")).expect("create lampe dir");
        }
        crate_path
    }

    #[test]
    fn list_workspace_crates_finds_subdirs_with_nargo() {
        let temp = TempDir::new().expect("tempdir");
        let root = temp.path();

        let crate_b = create_crate(root, "b", false);
        let crate_a = create_crate(root, "a", false);
        fs::create_dir_all(root.join("c")).expect("create non-crate dir");

        let crates = list_workspace_crates(root).expect("list crates");
        assert_eq!(crates, vec![crate_a, crate_b]);
    }

    #[test]
    fn is_workspace_root_false_for_package_manifest() {
        let temp = TempDir::new().expect("tempdir");
        write_nargo_toml(temp.path(), "[package]\nname = \"root\"\ntype = \"bin\"\n");

        assert!(!is_workspace_root(temp.path()).expect("workspace check"));
    }

    #[test]
    fn is_workspace_root_true_for_workspace_manifest() {
        let temp = TempDir::new().expect("tempdir");
        write_nargo_toml(temp.path(), "[workspace]\nmembers = [\"a\"]\n");

        assert!(is_workspace_root(temp.path()).expect("workspace check"));
    }

    #[test]
    fn select_workspace_crates_filters_without_lampe() {
        let temp = TempDir::new().expect("tempdir");
        let root = temp.path();

        let crate_a = create_crate(root, "a", true);
        create_crate(root, "b", false);

        let crates = select_workspace_crates(root).expect("select crates");
        assert_eq!(crates, vec![crate_a]);
    }

    #[test]
    fn select_workspace_crates_errors_without_lampe_crates() {
        let temp = TempDir::new().expect("tempdir");
        let root = temp.path();

        create_crate(root, "a", false);
        create_crate(root, "b", false);

        assert!(select_workspace_crates(root).is_err());
    }
}
