-- Generated by lampe

import «Merkle-0.0.0».Extracted.GeneratedTypes
import Lampe

open Lampe

namespace «Merkle-0.0.0»
namespace Extracted

nr_def «utils»::«rl»<>(u : u8) -> u8 {
    let top_bit = #uShr(u, 7 : u8) : u8;
    #uOr(#uShl(u, 1 : u8) : u8, top_bit) : u8;
}

nr_def «utils»::«rotate_left»<>(u : u8, N : u8) -> u8 {
    let mut result = u;
    for _? in 0 : u8 .. N {
            result = (@utils::rl<> as λ(u8) → u8)(result);
        skip;
    };
    result;
}

nr_def «utils»::«sbox»<>(v : u8) -> u8 {
    let x1 = #uNot(v) : u8;
    let x2 = (@utils::rotate_left<> as λ(u8, u8) → u8)(x1, 1 : u8);
    let x3 = (@utils::rotate_left<> as λ(u8, u8) → u8)(v, 2 : u8);
    let x4 = (@utils::rotate_left<> as λ(u8, u8) → u8)(v, 3 : u8);
    let x5 = #uAnd(#uAnd(x2, x3) : u8, x4) : u8;
    let x6 = (@utils::rotate_left<> as λ(u8, u8) → u8)(x5, 1 : u8);
    #uXor(v, x6) : u8;
}

nr_def «utils»::«sgn0»<>(self : Field) -> u1 {
    #cast(self) : u1;
}

nr_def «utils»::«as_array»<>(self : [u8]) -> [u8; 32] {
    let mut array = [0 : u8 ; 32];
    for i in 0 : u32 .. 32 : u32 {
            array[#cast(i) : u32] = #sliceIndex(self, #cast(i) : u32) : u8;
        skip;
    };
    array;
}

nr_def «utils»::«square»<>(a : Field) -> Field {
    #fMul(#fMul(a, a) : Field, (@SIGMA<> as λ() → Field)()) : Field;
}


def Utils.Mod.env := Lampe.Env.mk [«utils::as_array», «utils::rl», «utils::rotate_left», «utils::sbox», «utils::sgn0», «utils::square»] []