-- Generated by lampe

import «std-1.0.0-beta.11».Extracted.GeneratedTypes
import Lampe

open Lampe

namespace «std-1.0.0-beta.11»
namespace Extracted

noir_def std::slice::test::map_empty<>() -> Unit := {
  (#_assert returning Unit)(((Slice<Field> as Eq<>)::eq<> as λ(Slice<Field>, Slice<Field>) -> bool)((std::slice::map<Field, Unit> as λ(Slice<Field>, λ(Field) -> Field) -> Slice<Field>)((#_mkSlice returning Slice<Field>)(), (fn((x: Field)): Field := (#_fAdd returning Field)(x, (1: Field)))), (#_mkSlice returning Slice<Field>)()));
  #_skip
}

noir_def std::slice::test::mapi_empty<>() -> Unit := {
  (#_assert returning Unit)(((Slice<u32> as Eq<>)::eq<> as λ(Slice<u32>, Slice<u32>) -> bool)((std::slice::mapi<u32, Unit> as λ(Slice<u32>, λ(u32, u32) -> u32) -> Slice<u32>)((#_mkSlice returning Slice<u32>)(), (fn((i: u32), (x: u32)): u32 := (#_uAdd returning u32)((#_uMul returning u32)(i, x), (1: u32)))), (#_mkSlice returning Slice<u32>)()));
  #_skip
}

noir_def std::slice::test::for_each_empty<>() -> Unit := {
  let (empty_slice: Slice<Field>) = (#_mkSlice returning Slice<Field>)();
  (std::slice::for_each<Field, Unit> as λ(Slice<Field>, λ(Field) -> Unit) -> Unit)(empty_slice, (fn((_x: Field)): Unit := (#_assert returning Unit)(#_false)));
  #_skip
}

noir_def std::slice::test::for_eachi_empty<>() -> Unit := {
  let (empty_slice: Slice<Field>) = (#_mkSlice returning Slice<Field>)();
  (std::slice::for_eachi<Field, Unit> as λ(Slice<Field>, λ(u32, Field) -> Unit) -> Unit)(empty_slice, (fn((_i: u32), (_x: Field)): Unit := (#_assert returning Unit)(#_false)));
  #_skip
}

noir_def std::slice::test::map_example<>() -> Unit := {
  let (a: Slice<Field>) = (#_mkSlice returning Slice<Field>)((1: Field), (2: Field), (3: Field));
  let (b: Slice<Field>) = (std::slice::map<Field, Unit> as λ(Slice<Field>, λ(Field) -> Field) -> Slice<Field>)(a, (fn((a: Field)): Field := (#_fMul returning Field)(a, (2: Field))));
  (#_assert returning Unit)(((Slice<Field> as Eq<>)::eq<> as λ(Slice<Field>, Slice<Field>) -> bool)(b, (#_mkSlice returning Slice<Field>)((2: Field), (4: Field), (6: Field))));
  #_skip
}

noir_def std::slice::test::mapi_example<>() -> Unit := {
  let (a: Slice<u32>) = (#_mkSlice returning Slice<u32>)((1: u32), (2: u32), (3: u32));
  let (b: Slice<u32>) = (std::slice::mapi<u32, Unit> as λ(Slice<u32>, λ(u32, u32) -> u32) -> Slice<u32>)(a, (fn((i: u32), (a: u32)): u32 := (#_uAdd returning u32)(i, (#_uMul returning u32)(a, (2: u32)))));
  (#_assert returning Unit)(((Slice<u32> as Eq<>)::eq<> as λ(Slice<u32>, Slice<u32>) -> bool)(b, (#_mkSlice returning Slice<u32>)((2: u32), (5: u32), (8: u32))));
  #_skip
}

noir_def std::slice::test::for_each_example<>() -> Unit := {
  let (a: Slice<Field>) = (#_mkSlice returning Slice<Field>)((1: Field), (2: Field), (3: Field));
  let mut (b: Slice<Field>) = (#_mkSlice returning Slice<Field>)();
  let (b_ref: & Slice<Field>) = (#_ref returning & Slice<Field>)(b);
  (std::slice::for_each<Field, Tuple<& Slice<Field> > > as λ(Slice<Field>, λ(Field) -> Unit) -> Unit)(a, (fn((a: Field)): Unit := {
    (*b_ref: Slice<Field>) = (#_slicePushBack returning Slice<Field>)((#_readRef returning Slice<Field>)(b_ref), (#_fMul returning Field)(a, (2: Field)));
    #_skip
  }));
  (#_assert returning Unit)(((Slice<Field> as Eq<>)::eq<> as λ(Slice<Field>, Slice<Field>) -> bool)(b, (#_mkSlice returning Slice<Field>)((2: Field), (4: Field), (6: Field))));
  #_skip
}

noir_def std::slice::test::for_eachi_example<>() -> Unit := {
  let (a: Slice<u32>) = (#_mkSlice returning Slice<u32>)((1: u32), (2: u32), (3: u32));
  let mut (b: Slice<u32>) = (#_mkSlice returning Slice<u32>)();
  let (b_ref: & Slice<u32>) = (#_ref returning & Slice<u32>)(b);
  (std::slice::for_eachi<u32, Tuple<& Slice<u32> > > as λ(Slice<u32>, λ(u32, u32) -> Unit) -> Unit)(a, (fn((i: u32), (a: u32)): Unit := {
    (*b_ref: Slice<u32>) = (#_slicePushBack returning Slice<u32>)((#_readRef returning Slice<u32>)(b_ref), (#_uAdd returning u32)(i, (#_uMul returning u32)(a, (2: u32))));
    #_skip
  }));
  (#_assert returning Unit)(((Slice<u32> as Eq<>)::eq<> as λ(Slice<u32>, Slice<u32>) -> bool)(b, (#_mkSlice returning Slice<u32>)((2: u32), (5: u32), (8: u32))));
  #_skip
}


def Slice.env : Env := Env.mk
  [«std::slice::test::map_empty», «std::slice::test::mapi_empty», «std::slice::test::for_each_empty», «std::slice::test::for_eachi_empty», «std::slice::test::map_example», «std::slice::test::mapi_example», «std::slice::test::for_each_example», «std::slice::test::for_eachi_example»]
  []
