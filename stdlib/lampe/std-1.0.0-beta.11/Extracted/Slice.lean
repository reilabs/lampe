-- Generated by lampe

import «std-1.0.0-beta.11».Extracted.GeneratedTypes
import Lampe

open Lampe

namespace «std-1.0.0-beta.11»
namespace Extracted

noir_def std::slice::append<T: Type>(mut self: Slice<T>, other: Slice<T>) -> Slice<T> := {
  {
    let ζi0 = other;
    for ζi1 in (0: u32) .. (#_arrayLen returning u32)(ζi0) do {
      let elem = (#_sliceIndex returning T)(ζi0, (#_cast returning u32)(ζi1));
      {
        self = (#_slicePushBack returning Slice<T>)(self, elem);
        #_skip
      }
    };
    #_skip
  };
  self
}

noir_def std::slice::as_array<T: Type, N: u32>(self: Slice<T>) -> Array<T, N: u32> := {
  (#_assert returning Unit)((#_uEq returning bool)((#_arrayLen returning u32)(self), uConst!(N: u32)));
  let mut array = (#_mkRepeatedArray returning Array<T, N: u32>)((#_zeroed returning T)());
  for i in (0: u32) .. uConst!(N: u32) do {
    (array[i]: T) = (#_sliceIndex returning T)(self, (#_cast returning u32)(i));
    #_skip
  };
  array
}

noir_def std::slice::map<T: Type, U: Type, Env: Type>(self: Slice<T>, f: λ(T) -> U) -> Slice<U> := {
  let mut ret = (#_mkSlice returning Slice<U>)();
  {
    let ζi0 = self;
    for ζi1 in (0: u32) .. (#_arrayLen returning u32)(ζi0) do {
      let elem = (#_sliceIndex returning T)(ζi0, (#_cast returning u32)(ζi1));
      {
        ret = (#_slicePushBack returning Slice<U>)(ret, (f as λ(T) -> U)(elem));
        #_skip
      }
    };
    #_skip
  };
  ret
}

noir_def std::slice::mapi<T: Type, U: Type, Env: Type>(self: Slice<T>, f: λ(u32, T) -> U) -> Slice<U> := {
  let mut ret = (#_mkSlice returning Slice<U>)();
  let mut index = (0: u32);
  {
    let ζi0 = self;
    for ζi1 in (0: u32) .. (#_arrayLen returning u32)(ζi0) do {
      let elem = (#_sliceIndex returning T)(ζi0, (#_cast returning u32)(ζi1));
      {
        ret = (#_slicePushBack returning Slice<U>)(ret, (f as λ(u32, T) -> U)(index, elem));
        index = (#_uAdd returning u32)(index, (1: u32));
        #_skip
      }
    };
    #_skip
  };
  ret
}

noir_def std::slice::for_each<T: Type, Env: Type>(self: Slice<T>, f: λ(T) -> Unit) -> Unit := {
  let ζi0 = self;
  for ζi1 in (0: u32) .. (#_arrayLen returning u32)(ζi0) do {
    let elem = (#_sliceIndex returning T)(ζi0, (#_cast returning u32)(ζi1));
    {
      (f as λ(T) -> Unit)(elem);
      #_skip
    }
  };
  #_skip
}

noir_def std::slice::for_eachi<T: Type, Env: Type>(self: Slice<T>, f: λ(u32, T) -> Unit) -> Unit := {
  let mut index = (0: u32);
  {
    let ζi0 = self;
    for ζi1 in (0: u32) .. (#_arrayLen returning u32)(ζi0) do {
      let elem = (#_sliceIndex returning T)(ζi0, (#_cast returning u32)(ζi1));
      {
        (f as λ(u32, T) -> Unit)(index, elem);
        index = (#_uAdd returning u32)(index, (1: u32));
        #_skip
      }
    };
    #_skip
  }
}

noir_def std::slice::fold<T: Type, U: Type, Env: Type>(self: Slice<T>, mut accumulator: U, f: λ(U, T) -> U) -> U := {
  {
    let ζi0 = self;
    for ζi1 in (0: u32) .. (#_arrayLen returning u32)(ζi0) do {
      let elem = (#_sliceIndex returning T)(ζi0, (#_cast returning u32)(ζi1));
      {
        accumulator = (f as λ(U, T) -> U)(accumulator, elem);
        #_skip
      }
    };
    #_skip
  };
  accumulator
}

noir_def std::slice::reduce<T: Type, Env: Type>(self: Slice<T>, f: λ(T, T) -> T) -> T := {
  let mut accumulator = (#_sliceIndex returning T)(self, (0: u32));
  for i in (1: u32) .. (#_arrayLen returning u32)(self) do {
    accumulator = (f as λ(T, T) -> T)(accumulator, (#_sliceIndex returning T)(self, (#_cast returning u32)(i)));
    #_skip
  };
  accumulator
}

noir_def std::slice::filter<T: Type, Env: Type>(self: Slice<T>, predicate: λ(T) -> bool) -> Slice<T> := {
  let mut ret = (#_mkSlice returning Slice<T>)();
  {
    let ζi0 = self;
    for ζi1 in (0: u32) .. (#_arrayLen returning u32)(ζi0) do {
      let elem = (#_sliceIndex returning T)(ζi0, (#_cast returning u32)(ζi1));
      {
        if (predicate as λ(T) -> bool)(elem) then {
          ret = (#_slicePushBack returning Slice<T>)(ret, elem);
          #_skip
        }
      }
    };
    #_skip
  };
  ret
}

noir_def std::slice::join<T: Type>(self: Slice<T>, separator: T) -> T := {
  let mut ret = ((T as std::append::Append<>)::empty<> as λ() -> T)();
  if (#_uNeq returning bool)((#_arrayLen returning u32)(self), (0: u32)) then {
    ret = (#_sliceIndex returning T)(self, (0: u32));
    for i in (1: u32) .. (#_arrayLen returning u32)(self) do {
      ret = ((T as std::append::Append<>)::append<> as λ(T, T) -> T)(((T as std::append::Append<>)::append<> as λ(T, T) -> T)(ret, separator), (#_sliceIndex returning T)(self, (#_cast returning u32)(i)));
      #_skip
    };
    #_skip
  };
  ret
}

noir_def std::slice::all<T: Type, Env: Type>(self: Slice<T>, predicate: λ(T) -> bool) -> bool := {
  let mut ret = #_true;
  {
    let ζi0 = self;
    for ζi1 in (0: u32) .. (#_arrayLen returning u32)(ζi0) do {
      let elem = (#_sliceIndex returning T)(ζi0, (#_cast returning u32)(ζi1));
      {
        ret = (#_bAnd returning bool)(ret, (predicate as λ(T) -> bool)(elem));
        #_skip
      }
    };
    #_skip
  };
  ret
}

noir_def std::slice::any<T: Type, Env: Type>(self: Slice<T>, predicate: λ(T) -> bool) -> bool := {
  let mut ret = #_false;
  {
    let ζi0 = self;
    for ζi1 in (0: u32) .. (#_arrayLen returning u32)(ζi0) do {
      let elem = (#_sliceIndex returning T)(ζi0, (#_cast returning u32)(ζi1));
      {
        ret = (#_bOr returning bool)(ret, (predicate as λ(T) -> bool)(elem));
        #_skip
      }
    };
    #_skip
  };
  ret
}

noir_def std::slice::test::map_empty<>() -> Unit := {
  (#_assert returning Unit)(((Slice<Field> as Eq<>)::eq<> as λ(Slice<Field>, Slice<Field>) -> bool)((std::slice::map<Field, Unit> as λ(Slice<Field>, λ(Field) -> Field) -> Slice<Field>)((#_mkSlice returning Slice<Field>)(), (fn(x: Field): Field := (#_fAdd returning Field)(x, (1: Field)))), (#_mkSlice returning Slice<Field>)()));
  #_skip
}

noir_def std::slice::test::mapi_empty<>() -> Unit := {
  (#_assert returning Unit)(((Slice<u32> as Eq<>)::eq<> as λ(Slice<u32>, Slice<u32>) -> bool)((std::slice::mapi<u32, Unit> as λ(Slice<u32>, λ(u32, u32) -> u32) -> Slice<u32>)((#_mkSlice returning Slice<u32>)(), (fn(i: u32, x: u32): u32 := (#_uAdd returning u32)((#_uMul returning u32)(i, x), (1: u32)))), (#_mkSlice returning Slice<u32>)()));
  #_skip
}

noir_def std::slice::test::for_each_empty<>() -> Unit := {
  let empty_slice = (#_mkSlice returning Slice<Field>)();
  (std::slice::for_each<Field, Unit> as λ(Slice<Field>, λ(Field) -> Unit) -> Unit)(empty_slice, (fn(_x: Field): Unit := (#_assert returning Unit)(#_false)));
  #_skip
}

noir_def std::slice::test::for_eachi_empty<>() -> Unit := {
  let empty_slice = (#_mkSlice returning Slice<Field>)();
  (std::slice::for_eachi<Field, Unit> as λ(Slice<Field>, λ(u32, Field) -> Unit) -> Unit)(empty_slice, (fn(_i: u32, _x: Field): Unit := (#_assert returning Unit)(#_false)));
  #_skip
}

noir_def std::slice::test::map_example<>() -> Unit := {
  let a = (#_mkSlice returning Slice<Field>)((1: Field), (2: Field), (3: Field));
  let b = (std::slice::map<Field, Unit> as λ(Slice<Field>, λ(Field) -> Field) -> Slice<Field>)(a, (fn(a: Field): Field := (#_fMul returning Field)(a, (2: Field))));
  (#_assert returning Unit)(((Slice<Field> as Eq<>)::eq<> as λ(Slice<Field>, Slice<Field>) -> bool)(b, (#_mkSlice returning Slice<Field>)((2: Field), (4: Field), (6: Field))));
  #_skip
}

noir_def std::slice::test::mapi_example<>() -> Unit := {
  let a = (#_mkSlice returning Slice<u32>)((1: u32), (2: u32), (3: u32));
  let b = (std::slice::mapi<u32, Unit> as λ(Slice<u32>, λ(u32, u32) -> u32) -> Slice<u32>)(a, (fn(i: u32, a: u32): u32 := (#_uAdd returning u32)(i, (#_uMul returning u32)(a, (2: u32)))));
  (#_assert returning Unit)(((Slice<u32> as Eq<>)::eq<> as λ(Slice<u32>, Slice<u32>) -> bool)(b, (#_mkSlice returning Slice<u32>)((2: u32), (5: u32), (8: u32))));
  #_skip
}

noir_def std::slice::test::for_each_example<>() -> Unit := {
  let a = (#_mkSlice returning Slice<Field>)((1: Field), (2: Field), (3: Field));
  let mut b = (#_mkSlice returning Slice<Field>)();
  let b_ref = (#_ref returning & Slice<Field>)(b);
  (std::slice::for_each<Field, Tuple<& Slice<Field> > > as λ(Slice<Field>, λ(Field) -> Unit) -> Unit)(a, (fn(a: Field): Unit := {
    (*b_ref: Slice<Field>) = (#_slicePushBack returning Slice<Field>)((#_readRef returning Slice<Field>)(b_ref), (#_fMul returning Field)(a, (2: Field)));
    #_skip
  }));
  (#_assert returning Unit)(((Slice<Field> as Eq<>)::eq<> as λ(Slice<Field>, Slice<Field>) -> bool)(b, (#_mkSlice returning Slice<Field>)((2: Field), (4: Field), (6: Field))));
  #_skip
}

noir_def std::slice::test::for_eachi_example<>() -> Unit := {
  let a = (#_mkSlice returning Slice<u32>)((1: u32), (2: u32), (3: u32));
  let mut b = (#_mkSlice returning Slice<u32>)();
  let b_ref = (#_ref returning & Slice<u32>)(b);
  (std::slice::for_eachi<u32, Tuple<& Slice<u32> > > as λ(Slice<u32>, λ(u32, u32) -> Unit) -> Unit)(a, (fn(i: u32, a: u32): Unit := {
    (*b_ref: Slice<u32>) = (#_slicePushBack returning Slice<u32>)((#_readRef returning Slice<u32>)(b_ref), (#_uAdd returning u32)(i, (#_uMul returning u32)(a, (2: u32))));
    #_skip
  }));
  (#_assert returning Unit)(((Slice<u32> as Eq<>)::eq<> as λ(Slice<u32>, Slice<u32>) -> bool)(b, (#_mkSlice returning Slice<u32>)((2: u32), (5: u32), (8: u32))));
  #_skip
}

def Slice.env : Env := Env.mk
  [«std::slice::append», «std::slice::as_array», «std::slice::map», «std::slice::mapi», «std::slice::for_each», «std::slice::for_eachi», «std::slice::fold», «std::slice::reduce», «std::slice::filter», «std::slice::join», «std::slice::all», «std::slice::any», «std::slice::test::map_empty», «std::slice::test::mapi_empty», «std::slice::test::for_each_empty», «std::slice::test::for_eachi_empty», «std::slice::test::map_example», «std::slice::test::mapi_example», «std::slice::test::for_each_example», «std::slice::test::for_eachi_example»]
  []
