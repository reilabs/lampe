-- Generated by lampe

import «std-1.0.0-beta.11».Extracted.GeneratedTypes
import Lampe

open Lampe

namespace «std-1.0.0-beta.11»
namespace Extracted

noir_def std::hash::keccak::keccakf1600<>(input: Array<u64, 25: u32>) -> Array<u64, 25: u32> := {
  (#_keccakf1600 returning Array<u64, 25: u32>)(input)
}

noir_def std::hash::blake3<N: u32>(input: Array<u8, N: u32>) -> Array<u8, 32: u32> := {
  if (#_isUnconstrained returning bool)() then {
    (#_staticAssert returning Unit)((#_uLeq returning bool)(uConst!(N: u32), (1024: u32)), "Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes");
    #_skip
  };
  (#_blake3 returning Array<u8, 32: u32>)(input)
}

noir_def std::hash::pedersen_commitment<N: u32>(input: Array<Field, N: u32>) -> std::embedded_curve_ops::EmbeddedCurvePoint<> := {
  (std::hash::pedersen_commitment_with_separator<N: u32> as λ(Array<Field, N: u32>, u32) -> std::embedded_curve_ops::EmbeddedCurvePoint<>)(input, (0: u32))
}

noir_def std::hash::pedersen_commitment_with_separator<N: u32>(input: Array<Field, N: u32>, separator: u32) -> std::embedded_curve_ops::EmbeddedCurvePoint<> := {
  let mut (points: Array<std::embedded_curve_ops::EmbeddedCurveScalar<>, N: u32>) = (#_mkRepeatedArray returning Array<std::embedded_curve_ops::EmbeddedCurveScalar<>, N: u32>)((#_makeData returning std::embedded_curve_ops::EmbeddedCurveScalar<>)((0: Field), (0: Field)));
  for i in (0: u32) .. uConst!(N: u32) do {
    (points[i]: std::embedded_curve_ops::EmbeddedCurveScalar<>) = (std::hash::from_field_unsafe<> as λ(Field) -> std::embedded_curve_ops::EmbeddedCurveScalar<>)((#_arrayIndex returning Field)(input, (#_cast returning u32)(i)));
    #_skip
  };
  let (generators: Array<std::embedded_curve_ops::EmbeddedCurvePoint<>, N: u32>) = (std::hash::derive_generators<N: u32, 24: u32> as λ(Array<u8, 24: u32>, u32) -> Array<std::embedded_curve_ops::EmbeddedCurvePoint<>, N: u32>)((#_strAsBytes returning Array<u8, 24: u32>)("DEFAULT_DOMAIN_SEPARATOR"), separator);
  (std::embedded_curve_ops::multi_scalar_mul<N: u32> as λ(Array<std::embedded_curve_ops::EmbeddedCurvePoint<>, N: u32>, Array<std::embedded_curve_ops::EmbeddedCurveScalar<>, N: u32>) -> std::embedded_curve_ops::EmbeddedCurvePoint<>)(generators, points)
}

noir_def std::hash::pedersen_hash<N: u32>(input: Array<Field, N: u32>) -> Field := {
  (std::hash::pedersen_hash_with_separator<N: u32> as λ(Array<Field, N: u32>, u32) -> Field)(input, (0: u32))
}

noir_def std::hash::pedersen_hash_with_separator<N: u32>(input: Array<Field, N: u32>, separator: u32) -> Field := {
  let mut (scalars: Array<std::embedded_curve_ops::EmbeddedCurveScalar<>, (N + 1): u32>) = (#_mkRepeatedArray returning Array<std::embedded_curve_ops::EmbeddedCurveScalar<>, (N + 1): u32>)((#_makeData returning std::embedded_curve_ops::EmbeddedCurveScalar<>)((0: Field), (0: Field)));
  let mut (generators: Array<std::embedded_curve_ops::EmbeddedCurvePoint<>, (N + 1): u32>) = (#_mkRepeatedArray returning Array<std::embedded_curve_ops::EmbeddedCurvePoint<>, (N + 1): u32>)((std::embedded_curve_ops::EmbeddedCurvePoint::point_at_infinity<> as λ() -> std::embedded_curve_ops::EmbeddedCurvePoint<>)());
  let (domain_generators: Array<std::embedded_curve_ops::EmbeddedCurvePoint<>, N: u32>) = (std::hash::derive_generators<N: u32, 24: u32> as λ(Array<u8, 24: u32>, u32) -> Array<std::embedded_curve_ops::EmbeddedCurvePoint<>, N: u32>)((#_strAsBytes returning Array<u8, 24: u32>)("DEFAULT_DOMAIN_SEPARATOR"), separator);
  for i in (0: u32) .. uConst!(N: u32) do {
    (scalars[i]: std::embedded_curve_ops::EmbeddedCurveScalar<>) = (std::hash::from_field_unsafe<> as λ(Field) -> std::embedded_curve_ops::EmbeddedCurveScalar<>)((#_arrayIndex returning Field)(input, (#_cast returning u32)(i)));
    (generators[i]: std::embedded_curve_ops::EmbeddedCurvePoint<>) = (#_arrayIndex returning std::embedded_curve_ops::EmbeddedCurvePoint<>)(domain_generators, (#_cast returning u32)(i));
    #_skip
  };
  (scalars[uConst!(N: u32)]: std::embedded_curve_ops::EmbeddedCurveScalar<>) = (#_makeData returning std::embedded_curve_ops::EmbeddedCurveScalar<>)((#_cast returning Field)(uConst!(N: u32)), (#_cast returning Field)((0: Field)));
  let (length_generator: Array<std::embedded_curve_ops::EmbeddedCurvePoint<>, 1: u32>) = (std::hash::derive_generators<1: u32, 20: u32> as λ(Array<u8, 20: u32>, u32) -> Array<std::embedded_curve_ops::EmbeddedCurvePoint<>, 1: u32>)((#_strAsBytes returning Array<u8, 20: u32>)("pedersen_hash_length"), (0: u32));
  (generators[uConst!(N: u32)]: std::embedded_curve_ops::EmbeddedCurvePoint<>) = (#_arrayIndex returning std::embedded_curve_ops::EmbeddedCurvePoint<>)(length_generator, (0: u32));
  (#_arrayIndex returning std::embedded_curve_ops::EmbeddedCurvePoint<>)((#_multiScalarMul returning Array<std::embedded_curve_ops::EmbeddedCurvePoint<>, 1: u32>)(generators, scalars), (0: u32)).0
}

noir_def std::hash::derive_generators<N: u32, M: u32>(domain_separator_bytes: Array<u8, M: u32>, starting_index: u32) -> Array<std::embedded_curve_ops::EmbeddedCurvePoint<>, N: u32> := {
  (#_assertConstant returning Unit)(domain_separator_bytes);
  (#_derivePedersenGenerators returning Array<std::embedded_curve_ops::EmbeddedCurvePoint<>, N: u32>)(domain_separator_bytes, starting_index)
}

noir_def std::hash::from_field_unsafe<>(scalar: Field) -> std::embedded_curve_ops::EmbeddedCurveScalar<> := {
  let ((xlo: Field), (xhi: Field)) = {
    (std::field::bn254::decompose_hint<> as λ(Field) -> Tuple<Field, Field>)(scalar)
  };
  (#_assert returning Unit)((#_fEq returning bool)(scalar, (#_fAdd returning Field)(xlo, (#_fMul returning Field)((TWO_POW_128<> as λ() -> Field)(), xhi))));
  (#_makeData returning std::embedded_curve_ops::EmbeddedCurveScalar<>)(xlo, xhi)
}

noir_trait_impl[impl_2]<H: Type> std::hash::BuildHasher<> for std::hash::BuildHasherDefault<H> where [H: std::hash::Hasher<>, H: std::default::Default<>] := {
  noir_def build_hasher<>(_self: std::hash::BuildHasherDefault<H>) -> H := {
    ((H as std::default::Default<>)::default<> as λ() -> H)()
  };
}

noir_trait_impl[impl_3]<H: Type> std::default::Default<> for std::hash::BuildHasherDefault<H> where [H: std::hash::Hasher<>, H: std::default::Default<>] := {
  noir_def default<>() -> std::hash::BuildHasherDefault<H> := {
    (#_makeData returning std::hash::BuildHasherDefault<H>)()
  };
}

noir_trait_impl[impl_4]<> std::hash::Hash<> for Field where [] := {
  noir_def hash<H: Type>(self: Field, state: & H) -> Unit := {
    ((H as std::hash::Hasher<>)::write<> as λ(& H, Field) -> Unit)(state, self);
    #_skip
  };
}

noir_trait_impl[impl_5]<> std::hash::Hash<> for u1 where [] := {
  noir_def hash<H: Type>(self: u1, state: & H) -> Unit := {
    ((H as std::hash::Hasher<>)::write<> as λ(& H, Field) -> Unit)(state, (#_cast returning Field)(self));
    #_skip
  };
}

noir_trait_impl[impl_6]<> std::hash::Hash<> for u8 where [] := {
  noir_def hash<H: Type>(self: u8, state: & H) -> Unit := {
    ((H as std::hash::Hasher<>)::write<> as λ(& H, Field) -> Unit)(state, (#_cast returning Field)(self));
    #_skip
  };
}

noir_trait_impl[impl_7]<> std::hash::Hash<> for u16 where [] := {
  noir_def hash<H: Type>(self: u16, state: & H) -> Unit := {
    ((H as std::hash::Hasher<>)::write<> as λ(& H, Field) -> Unit)(state, (#_cast returning Field)(self));
    #_skip
  };
}

noir_trait_impl[impl_8]<> std::hash::Hash<> for u32 where [] := {
  noir_def hash<H: Type>(self: u32, state: & H) -> Unit := {
    ((H as std::hash::Hasher<>)::write<> as λ(& H, Field) -> Unit)(state, (#_cast returning Field)(self));
    #_skip
  };
}

noir_trait_impl[impl_9]<> std::hash::Hash<> for u64 where [] := {
  noir_def hash<H: Type>(self: u64, state: & H) -> Unit := {
    ((H as std::hash::Hasher<>)::write<> as λ(& H, Field) -> Unit)(state, (#_cast returning Field)(self));
    #_skip
  };
}

noir_trait_impl[impl_10]<> std::hash::Hash<> for u128 where [] := {
  noir_def hash<H: Type>(self: u128, state: & H) -> Unit := {
    ((H as std::hash::Hasher<>)::write<> as λ(& H, Field) -> Unit)(state, (#_cast returning Field)(self));
    #_skip
  };
}

noir_trait_impl[impl_11]<> std::hash::Hash<> for i8 where [] := {
  noir_def hash<H: Type>(self: i8, state: & H) -> Unit := {
    ((H as std::hash::Hasher<>)::write<> as λ(& H, Field) -> Unit)(state, (#_cast returning Field)((#_cast returning u8)(self)));
    #_skip
  };
}

noir_trait_impl[impl_12]<> std::hash::Hash<> for i16 where [] := {
  noir_def hash<H: Type>(self: i16, state: & H) -> Unit := {
    ((H as std::hash::Hasher<>)::write<> as λ(& H, Field) -> Unit)(state, (#_cast returning Field)((#_cast returning u16)(self)));
    #_skip
  };
}

noir_trait_impl[impl_13]<> std::hash::Hash<> for i32 where [] := {
  noir_def hash<H: Type>(self: i32, state: & H) -> Unit := {
    ((H as std::hash::Hasher<>)::write<> as λ(& H, Field) -> Unit)(state, (#_cast returning Field)((#_cast returning u32)(self)));
    #_skip
  };
}

noir_trait_impl[impl_14]<> std::hash::Hash<> for i64 where [] := {
  noir_def hash<H: Type>(self: i64, state: & H) -> Unit := {
    ((H as std::hash::Hasher<>)::write<> as λ(& H, Field) -> Unit)(state, (#_cast returning Field)((#_cast returning u64)(self)));
    #_skip
  };
}

noir_trait_impl[impl_15]<> std::hash::Hash<> for bool where [] := {
  noir_def hash<H: Type>(self: bool, state: & H) -> Unit := {
    ((H as std::hash::Hasher<>)::write<> as λ(& H, Field) -> Unit)(state, (#_cast returning Field)(self));
    #_skip
  };
}

noir_trait_impl[impl_16]<> std::hash::Hash<> for Unit where [] := {
  noir_def hash<H: Type>(_self: Unit, _state: & H) -> Unit := {
    #_skip
  };
}

noir_trait_impl[impl_17]<N: u32, T: Type> std::hash::Hash<> for Array<T, N: u32> where [T: std::hash::Hash<>] := {
  noir_def hash<H: Type>(self: Array<T, N: u32>, state: & H) -> Unit := {
    let (ζi0: Array<T, N: u32>) = self;
    for ζi1 in (0: u32) .. (#_arrayLen returning u32)(ζi0) do {
      let (elem: T) = (#_arrayIndex returning T)(ζi0, (#_cast returning u32)(ζi1));
      {
        ((T as std::hash::Hash<>)::hash<H> as λ(T, & H) -> Unit)(elem, state);
        #_skip
      }
    };
    #_skip
  };
}

noir_trait_impl[impl_18]<T: Type> std::hash::Hash<> for Slice<T> where [T: std::hash::Hash<>] := {
  noir_def hash<H: Type>(self: Slice<T>, state: & H) -> Unit := {
    ((u32 as std::hash::Hash<>)::hash<H> as λ(u32, & H) -> Unit)((#_arrayLen returning u32)(self), state);
    {
      let (ζi0: Slice<T>) = self;
      for ζi1 in (0: u32) .. (#_arrayLen returning u32)(ζi0) do {
        let (elem: T) = (#_sliceIndex returning T)(ζi0, (#_cast returning u32)(ζi1));
        {
          ((T as std::hash::Hash<>)::hash<H> as λ(T, & H) -> Unit)(elem, state);
          #_skip
        }
      };
      #_skip
    }
  };
}

noir_trait_impl[impl_19]<A: Type, B: Type> std::hash::Hash<> for Tuple<A, B> where [A: std::hash::Hash<>, B: std::hash::Hash<>] := {
  noir_def hash<H: Type>(self: Tuple<A, B>, state: & H) -> Unit := {
    ((A as std::hash::Hash<>)::hash<H> as λ(A, & H) -> Unit)(self.0, state);
    ((B as std::hash::Hash<>)::hash<H> as λ(B, & H) -> Unit)(self.1, state);
    #_skip
  };
}

noir_trait_impl[impl_20]<A: Type, B: Type, C: Type> std::hash::Hash<> for Tuple<A, B, C> where [A: std::hash::Hash<>, B: std::hash::Hash<>, C: std::hash::Hash<>] := {
  noir_def hash<H: Type>(self: Tuple<A, B, C>, state: & H) -> Unit := {
    ((A as std::hash::Hash<>)::hash<H> as λ(A, & H) -> Unit)(self.0, state);
    ((B as std::hash::Hash<>)::hash<H> as λ(B, & H) -> Unit)(self.1, state);
    ((C as std::hash::Hash<>)::hash<H> as λ(C, & H) -> Unit)(self.2, state);
    #_skip
  };
}

noir_trait_impl[impl_21]<A: Type, B: Type, C: Type, D: Type> std::hash::Hash<> for Tuple<A, B, C, D> where [A: std::hash::Hash<>, B: std::hash::Hash<>, C: std::hash::Hash<>, D: std::hash::Hash<>] := {
  noir_def hash<H: Type>(self: Tuple<A, B, C, D>, state: & H) -> Unit := {
    ((A as std::hash::Hash<>)::hash<H> as λ(A, & H) -> Unit)(self.0, state);
    ((B as std::hash::Hash<>)::hash<H> as λ(B, & H) -> Unit)(self.1, state);
    ((C as std::hash::Hash<>)::hash<H> as λ(C, & H) -> Unit)(self.2, state);
    ((D as std::hash::Hash<>)::hash<H> as λ(D, & H) -> Unit)(self.3, state);
    #_skip
  };
}

noir_trait_impl[impl_22]<A: Type, B: Type, C: Type, D: Type, E: Type> std::hash::Hash<> for Tuple<A, B, C, D, E> where [A: std::hash::Hash<>, B: std::hash::Hash<>, C: std::hash::Hash<>, D: std::hash::Hash<>, E: std::hash::Hash<>] := {
  noir_def hash<H: Type>(self: Tuple<A, B, C, D, E>, state: & H) -> Unit := {
    ((A as std::hash::Hash<>)::hash<H> as λ(A, & H) -> Unit)(self.0, state);
    ((B as std::hash::Hash<>)::hash<H> as λ(B, & H) -> Unit)(self.1, state);
    ((C as std::hash::Hash<>)::hash<H> as λ(C, & H) -> Unit)(self.2, state);
    ((D as std::hash::Hash<>)::hash<H> as λ(D, & H) -> Unit)(self.3, state);
    ((E as std::hash::Hash<>)::hash<H> as λ(E, & H) -> Unit)(self.4, state);
    #_skip
  };
}

noir_def std::hash::assert_pedersen<>() -> Unit := {
  (#_assert returning Unit)((#_fEq returning bool)((std::hash::pedersen_hash_with_separator<1: u32> as λ(Array<Field, 1: u32>, u32) -> Field)((#_mkArray returning Array<Field, 1: u32>)((1: Field)), (1: u32)), (-9563966249275741675388072609438711537348680428347819854678797696612266004386: Field)));
  (#_assert returning Unit)(((std::embedded_curve_ops::EmbeddedCurvePoint<> as Eq<>)::eq<> as λ(std::embedded_curve_ops::EmbeddedCurvePoint<>, std::embedded_curve_ops::EmbeddedCurvePoint<>) -> bool)((std::hash::pedersen_commitment_with_separator<1: u32> as λ(Array<Field, 1: u32>, u32) -> std::embedded_curve_ops::EmbeddedCurvePoint<>)((#_mkArray returning Array<Field, 1: u32>)((1: Field)), (1: u32)), (#_makeData returning std::embedded_curve_ops::EmbeddedCurvePoint<>)((2393473289045184898987089634332637236754766663897650125720167164137088869378: Field), (-7135402912423807765050323395026152633898511180575289670895350565966806597339: Field), #_false)));
  (#_assert returning Unit)((#_fEq returning bool)((std::hash::pedersen_hash_with_separator<2: u32> as λ(Array<Field, 2: u32>, u32) -> Field)((#_mkArray returning Array<Field, 2: u32>)((1: Field), (2: Field)), (2: u32)), (-4514641934080458214240751313245257091597283372119704256508270041112972328364: Field)));
  (#_assert returning Unit)(((std::embedded_curve_ops::EmbeddedCurvePoint<> as Eq<>)::eq<> as λ(std::embedded_curve_ops::EmbeddedCurvePoint<>, std::embedded_curve_ops::EmbeddedCurvePoint<>) -> bool)((std::hash::pedersen_commitment_with_separator<2: u32> as λ(Array<Field, 2: u32>, u32) -> std::embedded_curve_ops::EmbeddedCurvePoint<>)((#_mkArray returning Array<Field, 2: u32>)((1: Field), (2: Field)), (2: u32)), (#_makeData returning std::embedded_curve_ops::EmbeddedCurvePoint<>)((-1005469533000889117657666498472954572857833872027279582301287737791321798830: Field), (-197930408253518363600434091261593976805802346006803044607495721019065268361: Field), #_false)));
  (#_assert returning Unit)((#_fEq returning bool)((std::hash::pedersen_hash_with_separator<3: u32> as λ(Array<Field, 3: u32>, u32) -> Field)((#_mkArray returning Array<Field, 3: u32>)((1: Field), (2: Field), (3: Field)), (3: u32)), (5326303462429251635333445553787815334884504473158538697533567972354818497508: Field)));
  (#_assert returning Unit)(((std::embedded_curve_ops::EmbeddedCurvePoint<> as Eq<>)::eq<> as λ(std::embedded_curve_ops::EmbeddedCurvePoint<>, std::embedded_curve_ops::EmbeddedCurvePoint<>) -> bool)((std::hash::pedersen_commitment_with_separator<3: u32> as λ(Array<Field, 3: u32>, u32) -> std::embedded_curve_ops::EmbeddedCurvePoint<>)((#_mkArray returning Array<Field, 3: u32>)((1: Field), (2: Field), (3: Field)), (3: u32)), (#_makeData returning std::embedded_curve_ops::EmbeddedCurvePoint<>)((-7445492827528947374509602945629683494533192071041804482180938699494227714940: Field), (-346969586742294743999106690738565516862306986837138292504091779330690805808: Field), #_false)));
  (#_assert returning Unit)((#_fEq returning bool)((std::hash::pedersen_hash_with_separator<4: u32> as λ(Array<Field, 4: u32>, u32) -> Field)((#_mkArray returning Array<Field, 4: u32>)((1: Field), (2: Field), (3: Field), (4: Field)), (4: u32)), (386725976317305842536127973743796063021078557104668993698335256486699462108: Field)));
  (#_assert returning Unit)(((std::embedded_curve_ops::EmbeddedCurvePoint<> as Eq<>)::eq<> as λ(std::embedded_curve_ops::EmbeddedCurvePoint<>, std::embedded_curve_ops::EmbeddedCurvePoint<>) -> bool)((std::hash::pedersen_commitment_with_separator<4: u32> as λ(Array<Field, 4: u32>, u32) -> std::embedded_curve_ops::EmbeddedCurvePoint<>)((#_mkArray returning Array<Field, 4: u32>)((1: Field), (2: Field), (3: Field), (4: Field)), (4: u32)), (#_makeData returning std::embedded_curve_ops::EmbeddedCurvePoint<>)((3474050104565946163748262682994355436071725368663608454945085151569694677961: Field), (4969143737471383592015577254419974288705429190161323890019554309538525237268: Field), #_false)));
  (#_assert returning Unit)((#_fEq returning bool)((std::hash::pedersen_hash_with_separator<5: u32> as λ(Array<Field, 5: u32>, u32) -> Field)((#_mkArray returning Array<Field, 5: u32>)((1: Field), (2: Field), (3: Field), (4: Field), (5: Field)), (5: u32)), (445627510378474786942205982382342880084933256779806571759234109296077544482: Field)));
  (#_assert returning Unit)(((std::embedded_curve_ops::EmbeddedCurvePoint<> as Eq<>)::eq<> as λ(std::embedded_curve_ops::EmbeddedCurvePoint<>, std::embedded_curve_ops::EmbeddedCurvePoint<>) -> bool)((std::hash::pedersen_commitment_with_separator<5: u32> as λ(Array<Field, 5: u32>, u32) -> std::embedded_curve_ops::EmbeddedCurvePoint<>)((#_mkArray returning Array<Field, 5: u32>)((1: Field), (2: Field), (3: Field), (4: Field), (5: Field)), (5: u32)), (#_makeData returning std::embedded_curve_ops::EmbeddedCurvePoint<>)((10552833461612204383225982278685649771700648236894998952452362214619168226089: Field), (-1251131729610909206337824637802607977413231765663205492654376476649374713610: Field), #_false)));
  (#_assert returning Unit)((#_fEq returning bool)((std::hash::pedersen_hash_with_separator<6: u32> as λ(Array<Field, 6: u32>, u32) -> Field)((#_mkArray returning Array<Field, 6: u32>)((1: Field), (2: Field), (3: Field), (4: Field), (5: Field), (6: Field)), (6: u32)), (10217545977856619241380062255630350521414270790482717416408002401121937565042: Field)));
  (#_assert returning Unit)(((std::embedded_curve_ops::EmbeddedCurvePoint<> as Eq<>)::eq<> as λ(std::embedded_curve_ops::EmbeddedCurvePoint<>, std::embedded_curve_ops::EmbeddedCurvePoint<>) -> bool)((std::hash::pedersen_commitment_with_separator<6: u32> as λ(Array<Field, 6: u32>, u32) -> std::embedded_curve_ops::EmbeddedCurvePoint<>)((#_mkArray returning Array<Field, 6: u32>)((1: Field), (2: Field), (3: Field), (4: Field), (5: Field), (6: Field)), (6: u32)), (#_makeData returning std::embedded_curve_ops::EmbeddedCurvePoint<>)((11335069702571578236117888955050736139682779524214984889155721704928197387927: Field), (-7733361908666485801415200275635877656445756448956549185022038133647049615622: Field), #_false)));
  (#_assert returning Unit)((#_fEq returning bool)((std::hash::pedersen_hash_with_separator<7: u32> as λ(Array<Field, 7: u32>, u32) -> Field)((#_mkArray returning Array<Field, 7: u32>)((1: Field), (2: Field), (3: Field), (4: Field), (5: Field), (6: Field), (7: Field)), (7: u32)), (8389099894375185114295483291630893019224023442848409888108611454294869536227: Field)));
  (#_assert returning Unit)(((std::embedded_curve_ops::EmbeddedCurvePoint<> as Eq<>)::eq<> as λ(std::embedded_curve_ops::EmbeddedCurvePoint<>, std::embedded_curve_ops::EmbeddedCurvePoint<>) -> bool)((std::hash::pedersen_commitment_with_separator<7: u32> as λ(Array<Field, 7: u32>, u32) -> std::embedded_curve_ops::EmbeddedCurvePoint<>)((#_mkArray returning Array<Field, 7: u32>)((1: Field), (2: Field), (3: Field), (4: Field), (5: Field), (6: Field), (7: Field)), (7: u32)), (#_makeData returning std::embedded_curve_ops::EmbeddedCurvePoint<>)((601182919381464537093882307577577658521785998356796832152269409048770009401: Field), (-8704984668101593449807889537070046830501821124601109099832679891796819531525: Field), #_false)));
  (#_assert returning Unit)((#_fEq returning bool)((std::hash::pedersen_hash_with_separator<8: u32> as λ(Array<Field, 8: u32>, u32) -> Field)((#_mkArray returning Array<Field, 8: u32>)((1: Field), (2: Field), (3: Field), (4: Field), (5: Field), (6: Field), (7: Field), (8: Field)), (8: u32)), (-364414833671337260860436705614307386127212237115043515297237560718972836517: Field)));
  (#_assert returning Unit)(((std::embedded_curve_ops::EmbeddedCurvePoint<> as Eq<>)::eq<> as λ(std::embedded_curve_ops::EmbeddedCurvePoint<>, std::embedded_curve_ops::EmbeddedCurvePoint<>) -> bool)((std::hash::pedersen_commitment_with_separator<8: u32> as λ(Array<Field, 8: u32>, u32) -> std::embedded_curve_ops::EmbeddedCurvePoint<>)((#_mkArray returning Array<Field, 8: u32>)((1: Field), (2: Field), (3: Field), (4: Field), (5: Field), (6: Field), (7: Field), (8: Field)), (8: u32)), (#_makeData returning std::embedded_curve_ops::EmbeddedCurvePoint<>)((10105395258059943854471547573391327707179901153940064586773125525172385465411: Field), (-7764172381957047914625405480055519449068901615240110013280942913930205438090: Field), #_false)));
  (#_assert returning Unit)((#_fEq returning bool)((std::hash::pedersen_hash_with_separator<9: u32> as λ(Array<Field, 9: u32>, u32) -> Field)((#_mkArray returning Array<Field, 9: u32>)((1: Field), (2: Field), (3: Field), (4: Field), (5: Field), (6: Field), (7: Field), (8: Field), (9: Field)), (9: u32)), (5694292929090063810102755351119629986122166830204542196709417013467308391399: Field)));
  (#_assert returning Unit)(((std::embedded_curve_ops::EmbeddedCurvePoint<> as Eq<>)::eq<> as λ(std::embedded_curve_ops::EmbeddedCurvePoint<>, std::embedded_curve_ops::EmbeddedCurvePoint<>) -> bool)((std::hash::pedersen_commitment_with_separator<9: u32> as λ(Array<Field, 9: u32>, u32) -> std::embedded_curve_ops::EmbeddedCurvePoint<>)((#_mkArray returning Array<Field, 9: u32>)((1: Field), (2: Field), (3: Field), (4: Field), (5: Field), (6: Field), (7: Field), (8: Field), (9: Field)), (9: u32)), (#_makeData returning std::embedded_curve_ops::EmbeddedCurvePoint<>)((4630760469979870165820917922898436050077118370325830990580986530746633543789: Field), (445421188486227550820408419830973545028032672242093648088931561027838255858: Field), #_false)));
  (#_assert returning Unit)((#_fEq returning bool)((std::hash::pedersen_hash_with_separator<10: u32> as λ(Array<Field, 10: u32>, u32) -> Field)((#_mkArray returning Array<Field, 10: u32>)((1: Field), (2: Field), (3: Field), (4: Field), (5: Field), (6: Field), (7: Field), (8: Field), (9: Field), (10: Field)), (10: u32)), (-1612865150156425111011383725280441289912228955196006102547487828548180279661: Field)));
  (#_assert returning Unit)(((std::embedded_curve_ops::EmbeddedCurvePoint<> as Eq<>)::eq<> as λ(std::embedded_curve_ops::EmbeddedCurvePoint<>, std::embedded_curve_ops::EmbeddedCurvePoint<>) -> bool)((std::hash::pedersen_commitment_with_separator<10: u32> as λ(Array<Field, 10: u32>, u32) -> std::embedded_curve_ops::EmbeddedCurvePoint<>)((#_mkArray returning Array<Field, 10: u32>)((1: Field), (2: Field), (3: Field), (4: Field), (5: Field), (6: Field), (7: Field), (8: Field), (9: Field), (10: Field)), (10: u32)), (#_makeData returning std::embedded_curve_ops::EmbeddedCurvePoint<>)((-311556882567474412576811669014419164866085063813982345701073780395111226613: Field), (-163948955461070038478898748306472919392980231474444415480716967232318545340: Field), #_false)));
  #_skip
}

def Hash.Mod.env : Env := Env.mk
  [«std::hash::keccak::keccakf1600», «std::hash::blake3», «std::hash::pedersen_commitment», «std::hash::pedersen_commitment_with_separator», «std::hash::pedersen_hash», «std::hash::pedersen_hash_with_separator», «std::hash::derive_generators», «std::hash::from_field_unsafe», «std::hash::assert_pedersen»]
  [impl_2, impl_3, impl_4, impl_5, impl_6, impl_7, impl_8, impl_9, impl_10, impl_11, impl_12, impl_13, impl_14, impl_15, impl_16, impl_17, impl_18, impl_19, impl_20, impl_21, impl_22]
