-- Generated by lampe

import «std-1.0.0-beta.11».Extracted.GeneratedTypes
import Lampe

open Lampe

namespace «std-1.0.0-beta.11»
namespace Extracted

noir_def std::option::Option::none<T: Type>() -> std::option::Option<T> := {
  (#_makeData returning std::option::Option<T>)(#_false, (#_zeroed returning T)())
}

noir_def std::option::Option::some<T: Type>(_value: T) -> std::option::Option<T> := {
  (#_makeData returning std::option::Option<T>)(#_true, _value)
}

noir_def std::option::Option::is_none<T: Type>(self: std::option::Option<T>) -> bool := {
  (#_bNot returning bool)(self.0)
}

noir_def std::option::Option::is_some<T: Type>(self: std::option::Option<T>) -> bool := {
  self.0
}

noir_def std::option::Option::unwrap<T: Type>(self: std::option::Option<T>) -> T := {
  (#_assert returning Unit)(self.0);
  self.1
}

noir_def std::option::Option::unwrap_unchecked<T: Type>(self: std::option::Option<T>) -> T := {
  self.1
}

noir_def std::option::Option::unwrap_or<T: Type>(self: std::option::Option<T>, default: T) -> T := {
  if self.0 then {
    self.1
  } else {
    default
  }
}

noir_def std::option::Option::unwrap_or_else<T: Type, Env: Type>(self: std::option::Option<T>, default: λ() -> T) -> T := {
  if self.0 then {
    self.1
  } else {
    (default as λ() -> T)()
  }
}

noir_def std::option::Option::expect<T: Type, N: u32, MessageTypes: Type>(self: std::option::Option<T>, message: FmtString<N: u32, MessageTypes>) -> T := {
  (#_assert returning Unit)((std::option::Option::is_some<T> as λ(std::option::Option<T>) -> bool)(self));
  self.1
}

noir_def std::option::Option::map<T: Type, U: Type, Env: Type>(self: std::option::Option<T>, f: λ(T) -> U) -> std::option::Option<U> := {
  if self.0 then {
    (std::option::Option::some<U> as λ(U) -> std::option::Option<U>)((f as λ(T) -> U)(self.1))
  } else {
    (std::option::Option::none<U> as λ() -> std::option::Option<U>)()
  }
}

noir_def std::option::Option::map_or<T: Type, U: Type, Env: Type>(self: std::option::Option<T>, default: U, f: λ(T) -> U) -> U := {
  if self.0 then {
    (f as λ(T) -> U)(self.1)
  } else {
    default
  }
}

noir_def std::option::Option::map_or_else<T: Type, U: Type, Env1: Type, Env2: Type>(self: std::option::Option<T>, default: λ() -> U, f: λ(T) -> U) -> U := {
  if self.0 then {
    (f as λ(T) -> U)(self.1)
  } else {
    (default as λ() -> U)()
  }
}

noir_def std::option::Option::and<T: Type>(self: std::option::Option<T>, other: std::option::Option<T>) -> std::option::Option<T> := {
  if (std::option::Option::is_none<T> as λ(std::option::Option<T>) -> bool)(self) then {
    (std::option::Option::none<T> as λ() -> std::option::Option<T>)()
  } else {
    other
  }
}

noir_def std::option::Option::and_then<T: Type, U: Type, Env: Type>(self: std::option::Option<T>, f: λ(T) -> std::option::Option<U>) -> std::option::Option<U> := {
  if self.0 then {
    (f as λ(T) -> std::option::Option<U>)(self.1)
  } else {
    (std::option::Option::none<U> as λ() -> std::option::Option<U>)()
  }
}

noir_def std::option::Option::or<T: Type>(self: std::option::Option<T>, other: std::option::Option<T>) -> std::option::Option<T> := {
  if self.0 then {
    self
  } else {
    other
  }
}

noir_def std::option::Option::or_else<T: Type, Env: Type>(self: std::option::Option<T>, default: λ() -> std::option::Option<T>) -> std::option::Option<T> := {
  if self.0 then {
    self
  } else {
    (default as λ() -> std::option::Option<T>)()
  }
}

noir_def std::option::Option::xor<T: Type>(self: std::option::Option<T>, other: std::option::Option<T>) -> std::option::Option<T> := {
  if self.0 then {
    if other.0 then {
      (std::option::Option::none<T> as λ() -> std::option::Option<T>)()
    } else {
      self
    }
  } else if other.0 then {
    other
  } else {
    (std::option::Option::none<T> as λ() -> std::option::Option<T>)()
  }
}

noir_def std::option::Option::filter<T: Type, Env: Type>(self: std::option::Option<T>, predicate: λ(T) -> bool) -> std::option::Option<T> := {
  if self.0 then {
    if (predicate as λ(T) -> bool)(self.1) then {
      self
    } else {
      (std::option::Option::none<T> as λ() -> std::option::Option<T>)()
    }
  } else {
    (std::option::Option::none<T> as λ() -> std::option::Option<T>)()
  }
}

noir_def std::option::Option::flatten<T: Type>(option: std::option::Option<std::option::Option<T> >) -> std::option::Option<T> := {
  if option.0 then {
    option.1
  } else {
    (std::option::Option::none<T> as λ() -> std::option::Option<T>)()
  }
}

noir_trait_impl[impl_73]<T: Type> std::default::Default<> for std::option::Option<T> where [] := {
  noir_def default<>() -> std::option::Option<T> := {
    (std::option::Option::none<T> as λ() -> std::option::Option<T>)()
  };
}

noir_trait_impl[impl_74]<T: Type> std::cmp::Eq<> for std::option::Option<T> where [T: std::cmp::Eq<>] := {
  noir_def eq<>(self: std::option::Option<T>, other: std::option::Option<T>) -> bool := {
    if (#_bEq returning bool)(self.0, other.0) then {
      if self.0 then {
        ((T as Eq<>)::eq<> as λ(T, T) -> bool)(self.1, other.1)
      } else {
        #_true
      }
    } else {
      #_false
    }
  };
}

noir_trait_impl[impl_75]<T: Type> std::hash::Hash<> for std::option::Option<T> where [T: std::hash::Hash<>] := {
  noir_def hash<H: Type>(self: std::option::Option<T>, state: & H) -> Unit := {
    ((bool as std::hash::Hash<>)::hash<H> as λ(bool, & H) -> Unit)(self.0, state);
    if self.0 then {
      ((T as std::hash::Hash<>)::hash<H> as λ(T, & H) -> Unit)(self.1, state);
      #_skip
    }
  };
}

noir_trait_impl[impl_76]<T: Type> std::cmp::Ord<> for std::option::Option<T> where [T: std::cmp::Ord<>] := {
  noir_def cmp<>(self: std::option::Option<T>, other: std::option::Option<T>) -> std::cmp::Ordering<> := {
    if self.0 then {
      if other.0 then {
        ((T as std::cmp::Ord<>)::cmp<> as λ(T, T) -> std::cmp::Ordering<>)(self.1, other.1)
      } else {
        (std::cmp::Ordering::greater<> as λ() -> std::cmp::Ordering<>)()
      }
    } else if other.0 then {
      (std::cmp::Ordering::less<> as λ() -> std::cmp::Ordering<>)()
    } else {
      (std::cmp::Ordering::equal<> as λ() -> std::cmp::Ordering<>)()
    }
  };
}

def Option.env : Env := Env.mk
  [«std::option::Option::none», «std::option::Option::some», «std::option::Option::is_none», «std::option::Option::is_some», «std::option::Option::unwrap», «std::option::Option::unwrap_unchecked», «std::option::Option::unwrap_or», «std::option::Option::unwrap_or_else», «std::option::Option::expect», «std::option::Option::map», «std::option::Option::map_or», «std::option::Option::map_or_else», «std::option::Option::and», «std::option::Option::and_then», «std::option::Option::or», «std::option::Option::or_else», «std::option::Option::xor», «std::option::Option::filter», «std::option::Option::flatten»]
  [impl_73, impl_74, impl_75, impl_76]
