-- Generated by lampe

import «std-1.0.0-beta.11».Extracted.GeneratedTypes
import Lampe

open Lampe

namespace «std-1.0.0-beta.11»
namespace Extracted

noir_def std::collections::vec::Vec::new<T: Type>() -> std::collections::vec::Vec<T> := {
  (#_makeData returning std::collections::vec::Vec<T>)((#_mkSlice returning Slice<T>)())
}

noir_def std::collections::vec::Vec::from_slice<T: Type>(slice: Slice<T>) -> std::collections::vec::Vec<T> := {
  (#_makeData returning std::collections::vec::Vec<T>)(slice)
}

noir_def std::collections::vec::Vec::get<T: Type>(self: std::collections::vec::Vec<T>, index: u32) -> T := {
  (#_sliceIndex returning T)(self.0, (#_cast returning u32)(index))
}

noir_def std::collections::vec::Vec::set<T: Type>(self: & std::collections::vec::Vec<T>, index: u32, value: T) -> Unit := {
  (((*self: std::collections::vec::Vec<T>).0: Slice<T>)[[index]]: T) = value;
  #_skip
}

noir_def std::collections::vec::Vec::push<T: Type>(self: & std::collections::vec::Vec<T>, elem: T) -> Unit := {
  ((*self: std::collections::vec::Vec<T>).0: Slice<T>) = (#_slicePushBack returning Slice<T>)((#_readRef returning std::collections::vec::Vec<T>)(self).0, elem);
  #_skip
}

noir_def std::collections::vec::Vec::pop<T: Type>(self: & std::collections::vec::Vec<T>) -> T := {
  let ((popped_slice: Slice<T>), (last_elem: T)) = (#_slicePopBack returning Tuple<Slice<T>, T>)((#_readRef returning std::collections::vec::Vec<T>)(self).0);
  ((*self: std::collections::vec::Vec<T>).0: Slice<T>) = popped_slice;
  last_elem
}

noir_def std::collections::vec::Vec::insert<T: Type>(self: & std::collections::vec::Vec<T>, index: u32, elem: T) -> Unit := {
  ((*self: std::collections::vec::Vec<T>).0: Slice<T>) = (#_sliceInsert returning Slice<T>)((#_readRef returning std::collections::vec::Vec<T>)(self).0, index, elem);
  #_skip
}

noir_def std::collections::vec::Vec::remove<T: Type>(self: & std::collections::vec::Vec<T>, index: u32) -> T := {
  let ((new_slice: Slice<T>), (elem: T)) = (#_sliceRemove returning Tuple<Slice<T>, T>)((#_readRef returning std::collections::vec::Vec<T>)(self).0, index);
  ((*self: std::collections::vec::Vec<T>).0: Slice<T>) = new_slice;
  elem
}

noir_def std::collections::vec::Vec::len<T: Type>(self: std::collections::vec::Vec<T>) -> u32 := {
  (#_arrayLen returning u32)(self.0)
}

noir_def std::collections::vec::tests::set_updates_values_properly<>() -> Unit := {
  let mut (vec: std::collections::vec::Vec<Field>) = (#_makeData returning std::collections::vec::Vec<Field>)((#_mkSlice returning Slice<Field>)((0: Field), (0: Field), (0: Field), (0: Field), (0: Field)));
  (std::collections::vec::Vec::set<Field> as λ(& std::collections::vec::Vec<Field>, u32, Field) -> Unit)((#_ref returning & std::collections::vec::Vec<Field>)(vec), (0: u32), (42: Field));
  (#_assert returning Unit)(((Slice<Field> as Eq<>)::eq<> as λ(Slice<Field>, Slice<Field>) -> bool)(vec.0, (#_mkSlice returning Slice<Field>)((42: Field), (0: Field), (0: Field), (0: Field), (0: Field))));
  (std::collections::vec::Vec::set<Field> as λ(& std::collections::vec::Vec<Field>, u32, Field) -> Unit)((#_ref returning & std::collections::vec::Vec<Field>)(vec), (1: u32), (43: Field));
  (#_assert returning Unit)(((Slice<Field> as Eq<>)::eq<> as λ(Slice<Field>, Slice<Field>) -> bool)(vec.0, (#_mkSlice returning Slice<Field>)((42: Field), (43: Field), (0: Field), (0: Field), (0: Field))));
  (std::collections::vec::Vec::set<Field> as λ(& std::collections::vec::Vec<Field>, u32, Field) -> Unit)((#_ref returning & std::collections::vec::Vec<Field>)(vec), (2: u32), (44: Field));
  (#_assert returning Unit)(((Slice<Field> as Eq<>)::eq<> as λ(Slice<Field>, Slice<Field>) -> bool)(vec.0, (#_mkSlice returning Slice<Field>)((42: Field), (43: Field), (44: Field), (0: Field), (0: Field))));
  (std::collections::vec::Vec::set<Field> as λ(& std::collections::vec::Vec<Field>, u32, Field) -> Unit)((#_ref returning & std::collections::vec::Vec<Field>)(vec), (1: u32), (10: Field));
  (#_assert returning Unit)(((Slice<Field> as Eq<>)::eq<> as λ(Slice<Field>, Slice<Field>) -> bool)(vec.0, (#_mkSlice returning Slice<Field>)((42: Field), (10: Field), (44: Field), (0: Field), (0: Field))));
  (std::collections::vec::Vec::set<Field> as λ(& std::collections::vec::Vec<Field>, u32, Field) -> Unit)((#_ref returning & std::collections::vec::Vec<Field>)(vec), (0: u32), (0: Field));
  (#_assert returning Unit)(((Slice<Field> as Eq<>)::eq<> as λ(Slice<Field>, Slice<Field>) -> bool)(vec.0, (#_mkSlice returning Slice<Field>)((0: Field), (10: Field), (44: Field), (0: Field), (0: Field))));
  #_skip
}

noir_def std::collections::vec::tests::panics_when_writing_elements_past_end_of_vec<>() -> Unit := {
  let mut (vec: std::collections::vec::Vec<Field>) = (std::collections::vec::Vec::new<Field> as λ() -> std::collections::vec::Vec<Field>)();
  (std::collections::vec::Vec::set<Field> as λ(& std::collections::vec::Vec<Field>, u32, Field) -> Unit)((#_ref returning & std::collections::vec::Vec<Field>)(vec), (0: u32), (42: Field));
  let (_: Field) = (std::collections::vec::Vec::get<Field> as λ(std::collections::vec::Vec<Field>, u32) -> Field)(vec, (0: u32));
  #_skip
}

def Collections.Vec.env : Env := Env.mk
  [«std::collections::vec::Vec::new», «std::collections::vec::Vec::from_slice», «std::collections::vec::Vec::get», «std::collections::vec::Vec::set», «std::collections::vec::Vec::push», «std::collections::vec::Vec::pop», «std::collections::vec::Vec::insert», «std::collections::vec::Vec::remove», «std::collections::vec::Vec::len», «std::collections::vec::tests::set_updates_values_properly», «std::collections::vec::tests::panics_when_writing_elements_past_end_of_vec»]
  []
