-- Generated by lampe

import «std-1.0.0-beta.12».Extracted.GeneratedTypes
import Lampe

open Lampe

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::new<T: Type, MaxLen: u32>() -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32> := {
  let zeroed = (#_zeroed returning T)();
  (#_makeData returning «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32>)((#_mkRepeatedArray returning Array<T, MaxLen: u32>)(zeroed), (0: u32))
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::get<T: Type, MaxLen: u32>(self: «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32>, index: u32) -> T := {
  (#_assert returning Unit)((#_uLt returning bool)(index, self.1));
  («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::get_unchecked<T, MaxLen: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32>, u32) -> T)(self, index)
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::get_unchecked<T: Type, MaxLen: u32>(self: «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32>, index: u32) -> T := {
  (#_arrayIndex returning T)(self.0, (#_cast returning u32)(index))
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::set<T: Type, MaxLen: u32>(self: & «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32>, index: u32, value: T) -> Unit := {
  (#_assert returning Unit)((#_uLt returning bool)(index, (#_readRef returning «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32>)(self).1));
  («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::set_unchecked<T, MaxLen: u32> as λ(& «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32>, u32, T) -> Unit)(self, index, value)
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::set_unchecked<T: Type, MaxLen: u32>(self: & «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32>, index: u32, value: T) -> Unit := {
  (((*self: «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32>).0: Array<T, MaxLen: u32>)[index]: T) = value;
  #_skip
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::push<T: Type, MaxLen: u32>(self: & «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32>, elem: T) -> Unit := {
  (#_assert returning Unit)((#_uLt returning bool)((#_readRef returning «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32>)(self).1, uConst!(MaxLen: u32)));
  {
    let i_3622 = (#_readRef returning «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32>)(self).1;
    (((*self: «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32>).0: Array<T, MaxLen: u32>)[i_3622]: T) = elem;
    #_skip
  };
  ((*self: «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32>).1: u32) = (#_uAdd returning u32)((#_readRef returning «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32>)(self).1, (1: u32));
  #_skip
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::len<T: Type, MaxLen: u32>(self: «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32>) -> u32 := {
  self.1
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::max_len<T: Type, MaxLen: u32>(_self: «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32>) -> u32 := {
  uConst!(MaxLen: u32)
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::storage<T: Type, MaxLen: u32>(self: «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32>) -> Array<T, MaxLen: u32> := {
  self.0
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::extend_from_array<T: Type, MaxLen: u32, Len: u32>(self: & «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32>, array: Array<T, Len: u32>) -> Unit := {
  let new_len = (#_uAdd returning u32)((#_readRef returning «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32>)(self).1, (#_arrayLen returning u32)(array));
  (#_assert returning Unit)((#_uLeq returning bool)(new_len, uConst!(MaxLen: u32)));
  for i in (0: u32) .. (#_arrayLen returning u32)(array) do {
    let i_3630 = (#_uAdd returning u32)((#_readRef returning «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32>)(self).1, i);
    (((*self: «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32>).0: Array<T, MaxLen: u32>)[i_3630]: T) = (#_arrayIndex returning T)(array, (#_cast returning u32)(i));
    #_skip
  };
  ((*self: «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32>).1: u32) = new_len;
  #_skip
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::extend_from_slice<T: Type, MaxLen: u32>(self: & «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32>, slice: Slice<T>) -> Unit := {
  let new_len = (#_uAdd returning u32)((#_readRef returning «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32>)(self).1, (#_arrayLen returning u32)(slice));
  (#_assert returning Unit)((#_uLeq returning bool)(new_len, uConst!(MaxLen: u32)));
  for i in (0: u32) .. (#_arrayLen returning u32)(slice) do {
    let i_3634 = (#_uAdd returning u32)((#_readRef returning «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32>)(self).1, i);
    (((*self: «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32>).0: Array<T, MaxLen: u32>)[i_3634]: T) = (#_sliceIndex returning T)(slice, (#_cast returning u32)(i));
    #_skip
  };
  ((*self: «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32>).1: u32) = new_len;
  #_skip
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::extend_from_bounded_vec<T: Type, MaxLen: u32, Len: u32>(self: & «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32>, vec: «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, Len: u32>) -> Unit := {
  let append_len = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::len<T, Len: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, Len: u32>) -> u32)(vec);
  let new_len = (#_uAdd returning u32)((#_readRef returning «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32>)(self).1, append_len);
  (#_assert returning Unit)((#_uLeq returning bool)(new_len, uConst!(MaxLen: u32)));
  if (#_isUnconstrained returning bool)() then {
    for i in (0: u32) .. append_len do {
      let i_3640 = (#_uAdd returning u32)((#_readRef returning «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32>)(self).1, i);
      (((*self: «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32>).0: Array<T, MaxLen: u32>)[i_3640]: T) = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::get_unchecked<T, Len: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, Len: u32>, u32) -> T)(vec, i);
      #_skip
    };
    #_skip
  } else {
    let mut exceeded_len = #_false;
    for i in (0: u32) .. uConst!(Len: u32) do {
      exceeded_len = (#_bOr returning bool)(exceeded_len, (#_uEq returning bool)(i, append_len));
      if (#_bNot returning bool)(exceeded_len) then {
        let i_3643 = (#_uAdd returning u32)((#_readRef returning «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32>)(self).1, i);
        (((*self: «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32>).0: Array<T, MaxLen: u32>)[i_3643]: T) = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::get_unchecked<T, Len: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, Len: u32>, u32) -> T)(vec, i);
        #_skip
      }
    };
    #_skip
  };
  ((*self: «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32>).1: u32) = new_len;
  #_skip
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::from_array<T: Type, MaxLen: u32, Len: u32>(array: Array<T, Len: u32>) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32> := {
  (#_staticAssert returning Unit)((#_uLeq returning bool)(uConst!(Len: u32), uConst!(MaxLen: u32)), "from array out of bounds");
  let mut vec = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::new<T, MaxLen: u32> as λ() -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32>)();
  («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::extend_from_array<T, MaxLen: u32, Len: u32> as λ(& «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32>, Array<T, Len: u32>) -> Unit)((#_ref returning & «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32>)(vec), array);
  vec
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::pop<T: Type, MaxLen: u32>(self: & «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32>) -> T := {
  (#_assert returning Unit)((#_uGt returning bool)((#_readRef returning «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32>)(self).1, (0: u32)));
  ((*self: «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32>).1: u32) = (#_uSub returning u32)((#_readRef returning «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32>)(self).1, (1: u32));
  let elem = (#_arrayIndex returning T)((#_readRef returning «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32>)(self).0, (#_cast returning u32)((#_readRef returning «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32>)(self).1));
  {
    let i_3649 = (#_readRef returning «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32>)(self).1;
    (((*self: «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32>).0: Array<T, MaxLen: u32>)[i_3649]: T) = (#_zeroed returning T)();
    #_skip
  };
  elem
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::any<T: Type, MaxLen: u32, Env: Type>(self: «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32>, predicate: λ(T) -> bool) -> bool := {
  let mut ret = #_false;
  if (#_isUnconstrained returning bool)() then {
    for i in (0: u32) .. self.1 do {
      ret = (#_bOr returning bool)(ret, (predicate as λ(T) -> bool)((#_arrayIndex returning T)(self.0, (#_cast returning u32)(i))));
      #_skip
    };
    #_skip
  } else {
    let mut exceeded_len = #_false;
    for i in (0: u32) .. uConst!(MaxLen: u32) do {
      exceeded_len = (#_bOr returning bool)(exceeded_len, (#_uEq returning bool)(i, self.1));
      if (#_bNot returning bool)(exceeded_len) then {
        ret = (#_bOr returning bool)(ret, (predicate as λ(T) -> bool)((#_arrayIndex returning T)(self.0, (#_cast returning u32)(i))));
        #_skip
      }
    };
    #_skip
  };
  ret
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::map<T: Type, MaxLen: u32, U: Type, Env: Type>(self: «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32>, f: λ(T) -> U) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<U, MaxLen: u32> := {
  let mut ret = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::new<U, MaxLen: u32> as λ() -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<U, MaxLen: u32>)();
  (ret.1: u32) = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::len<T, MaxLen: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32>) -> u32)(self);
  if (#_isUnconstrained returning bool)() then {
    for i in (0: u32) .. («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::len<T, MaxLen: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32>) -> u32)(self) do {
      ((ret.0: Array<U, MaxLen: u32>)[i]: U) = (f as λ(T) -> U)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::get_unchecked<T, MaxLen: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32>, u32) -> T)(self, i));
      #_skip
    };
    #_skip
  } else {
    for i in (0: u32) .. uConst!(MaxLen: u32) do {
      if (#_uLt returning bool)(i, («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::len<T, MaxLen: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32>) -> u32)(self)) then {
        ((ret.0: Array<U, MaxLen: u32>)[i]: U) = (f as λ(T) -> U)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::get_unchecked<T, MaxLen: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32>, u32) -> T)(self, i));
        #_skip
      }
    };
    #_skip
  };
  ret
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::mapi<T: Type, MaxLen: u32, U: Type, Env: Type>(self: «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32>, f: λ(u32, T) -> U) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<U, MaxLen: u32> := {
  let mut ret = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::new<U, MaxLen: u32> as λ() -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<U, MaxLen: u32>)();
  (ret.1: u32) = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::len<T, MaxLen: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32>) -> u32)(self);
  if (#_isUnconstrained returning bool)() then {
    for i in (0: u32) .. («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::len<T, MaxLen: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32>) -> u32)(self) do {
      ((ret.0: Array<U, MaxLen: u32>)[i]: U) = (f as λ(u32, T) -> U)(i, («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::get_unchecked<T, MaxLen: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32>, u32) -> T)(self, i));
      #_skip
    };
    #_skip
  } else {
    for i in (0: u32) .. uConst!(MaxLen: u32) do {
      if (#_uLt returning bool)(i, («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::len<T, MaxLen: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32>) -> u32)(self)) then {
        ((ret.0: Array<U, MaxLen: u32>)[i]: U) = (f as λ(u32, T) -> U)(i, («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::get_unchecked<T, MaxLen: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32>, u32) -> T)(self, i));
        #_skip
      }
    };
    #_skip
  };
  ret
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::for_each<T: Type, MaxLen: u32, Env: Type>(self: «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32>, f: λ(T) -> Unit) -> Unit := {
  if (#_isUnconstrained returning bool)() then {
    for i in (0: u32) .. («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::len<T, MaxLen: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32>) -> u32)(self) do {
      (f as λ(T) -> Unit)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::get_unchecked<T, MaxLen: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32>, u32) -> T)(self, i));
      #_skip
    };
    #_skip
  } else {
    for i in (0: u32) .. uConst!(MaxLen: u32) do {
      if (#_uLt returning bool)(i, («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::len<T, MaxLen: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32>) -> u32)(self)) then {
        (f as λ(T) -> Unit)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::get_unchecked<T, MaxLen: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32>, u32) -> T)(self, i));
        #_skip
      }
    };
    #_skip
  }
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::for_eachi<T: Type, MaxLen: u32, Env: Type>(self: «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32>, f: λ(u32, T) -> Unit) -> Unit := {
  if (#_isUnconstrained returning bool)() then {
    for i in (0: u32) .. («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::len<T, MaxLen: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32>) -> u32)(self) do {
      (f as λ(u32, T) -> Unit)(i, («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::get_unchecked<T, MaxLen: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32>, u32) -> T)(self, i));
      #_skip
    };
    #_skip
  } else {
    for i in (0: u32) .. uConst!(MaxLen: u32) do {
      if (#_uLt returning bool)(i, («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::len<T, MaxLen: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32>) -> u32)(self)) then {
        (f as λ(u32, T) -> Unit)(i, («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::get_unchecked<T, MaxLen: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32>, u32) -> T)(self, i));
        #_skip
      }
    };
    #_skip
  }
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::from_parts<T: Type, MaxLen: u32>(mut array: Array<T, MaxLen: u32>, len: u32) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32> := {
  (#_assert returning Unit)((#_uLeq returning bool)(len, uConst!(MaxLen: u32)));
  let zeroed = (#_zeroed returning T)();
  if (#_isUnconstrained returning bool)() then {
    for i in len .. uConst!(MaxLen: u32) do {
      (array[i]: T) = zeroed;
      #_skip
    };
    #_skip
  } else {
    for i in (0: u32) .. uConst!(MaxLen: u32) do {
      if (#_uGeq returning bool)(i, len) then {
        (array[i]: T) = zeroed;
        #_skip
      }
    };
    #_skip
  };
  (#_makeData returning «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32>)(array, len)
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::from_parts_unchecked<T: Type, MaxLen: u32>(array: Array<T, MaxLen: u32>, len: u32) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32> := {
  (#_assert returning Unit)((#_uLeq returning bool)(len, uConst!(MaxLen: u32)));
  (#_makeData returning «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32>)(array, len)
}

noir_trait_impl[«std-1.0.0-beta.12».impl_32]<T: Type, MaxLen: u32> «std-1.0.0-beta.12»::cmp::Eq<> for «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32> where [T: «std-1.0.0-beta.12»::cmp::Eq<>] := {
  noir_def eq<>(self: «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32>, other: «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32>) -> bool := {
    if (#_uEq returning bool)(self.1, other.1) then {
      ((Array<T, MaxLen: u32> as «std-1.0.0-beta.12»::cmp::Eq<>)::eq<> as λ(Array<T, MaxLen: u32>, Array<T, MaxLen: u32>) -> bool)(self.0, other.0)
    } else {
      #_false
    }
  };
}

noir_trait_impl[«std-1.0.0-beta.12».impl_33]<Len: u32, T: Type, MaxLen: u32> «std-1.0.0-beta.12»::convert::From<Array<T, Len: u32> > for «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32> where [] := {
  noir_def «from»<>(array: Array<T, Len: u32>) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32> := {
    («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::from_array<T, MaxLen: u32, Len: u32> as λ(Array<T, Len: u32>) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32>)(array)
  };
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::bounded_vec_tests::get::panics_when_reading_elements_past_end_of_vec<>() -> Unit := {
  let vec = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::new<Field, 5: u32> as λ() -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<Field, 5: u32>)();
  let __0 = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::get<Field, 5: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<Field, 5: u32>, u32) -> Field)(vec, (0: u32));
  #_skip
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::bounded_vec_tests::get::panics_when_reading_beyond_length<>() -> Unit := {
  let vec = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::from_array<u32, 5: u32, 3: u32> as λ(Array<u32, 3: u32>) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>)((#_mkArray returning Array<u32, 3: u32>)((1: u32), (2: u32), (3: u32)));
  let __0 = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::get<u32, 5: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>, u32) -> u32)(vec, (3: u32));
  #_skip
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::bounded_vec_tests::get::get_works_within_bounds<>() -> Unit := {
  let vec = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::from_array<u32, 5: u32> as λ(Array<u32, 5: u32>) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>)((#_mkArray returning Array<u32, 5: u32>)((1: u32), (2: u32), (3: u32), (4: u32), (5: u32)));
  (#_assert returning Unit)((#_uEq returning bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::get<u32, 5: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>, u32) -> u32)(vec, (0: u32)), (1: u32)));
  (#_assert returning Unit)((#_uEq returning bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::get<u32, 5: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>, u32) -> u32)(vec, (2: u32)), (3: u32)));
  (#_assert returning Unit)((#_uEq returning bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::get<u32, 5: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>, u32) -> u32)(vec, (4: u32)), (5: u32)));
  #_skip
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::bounded_vec_tests::get::get_unchecked_works<>() -> Unit := {
  let vec = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::from_array<u32, 5: u32, 3: u32> as λ(Array<u32, 3: u32>) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>)((#_mkArray returning Array<u32, 3: u32>)((1: u32), (2: u32), (3: u32)));
  (#_assert returning Unit)((#_uEq returning bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::get_unchecked<u32, 5: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>, u32) -> u32)(vec, (0: u32)), (1: u32)));
  (#_assert returning Unit)((#_uEq returning bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::get_unchecked<u32, 5: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>, u32) -> u32)(vec, (2: u32)), (3: u32)));
  #_skip
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::bounded_vec_tests::get::get_unchecked_works_past_len<>() -> Unit := {
  let vec = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::from_array<u32, 5: u32, 3: u32> as λ(Array<u32, 3: u32>) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>)((#_mkArray returning Array<u32, 3: u32>)((1: u32), (2: u32), (3: u32)));
  (#_assert returning Unit)((#_uEq returning bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::get_unchecked<u32, 5: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>, u32) -> u32)(vec, (4: u32)), (0: u32)));
  #_skip
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::bounded_vec_tests::set::set_updates_values_properly<>() -> Unit := {
  let mut vec = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::from_array<Field, 5: u32> as λ(Array<Field, 5: u32>) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<Field, 5: u32>)((#_mkArray returning Array<Field, 5: u32>)((0: Field), (0: Field), (0: Field), (0: Field), (0: Field)));
  («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::set<Field, 5: u32> as λ(& «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<Field, 5: u32>, u32, Field) -> Unit)((#_ref returning & «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<Field, 5: u32>)(vec), (0: u32), (42: Field));
  (#_assert returning Unit)(((Array<Field, 5: u32> as «std-1.0.0-beta.12»::cmp::Eq<>)::eq<> as λ(Array<Field, 5: u32>, Array<Field, 5: u32>) -> bool)(vec.0, (#_mkArray returning Array<Field, 5: u32>)((42: Field), (0: Field), (0: Field), (0: Field), (0: Field))));
  («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::set<Field, 5: u32> as λ(& «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<Field, 5: u32>, u32, Field) -> Unit)((#_ref returning & «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<Field, 5: u32>)(vec), (1: u32), (43: Field));
  (#_assert returning Unit)(((Array<Field, 5: u32> as «std-1.0.0-beta.12»::cmp::Eq<>)::eq<> as λ(Array<Field, 5: u32>, Array<Field, 5: u32>) -> bool)(vec.0, (#_mkArray returning Array<Field, 5: u32>)((42: Field), (43: Field), (0: Field), (0: Field), (0: Field))));
  («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::set<Field, 5: u32> as λ(& «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<Field, 5: u32>, u32, Field) -> Unit)((#_ref returning & «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<Field, 5: u32>)(vec), (2: u32), (44: Field));
  (#_assert returning Unit)(((Array<Field, 5: u32> as «std-1.0.0-beta.12»::cmp::Eq<>)::eq<> as λ(Array<Field, 5: u32>, Array<Field, 5: u32>) -> bool)(vec.0, (#_mkArray returning Array<Field, 5: u32>)((42: Field), (43: Field), (44: Field), (0: Field), (0: Field))));
  («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::set<Field, 5: u32> as λ(& «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<Field, 5: u32>, u32, Field) -> Unit)((#_ref returning & «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<Field, 5: u32>)(vec), (1: u32), (10: Field));
  (#_assert returning Unit)(((Array<Field, 5: u32> as «std-1.0.0-beta.12»::cmp::Eq<>)::eq<> as λ(Array<Field, 5: u32>, Array<Field, 5: u32>) -> bool)(vec.0, (#_mkArray returning Array<Field, 5: u32>)((42: Field), (10: Field), (44: Field), (0: Field), (0: Field))));
  («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::set<Field, 5: u32> as λ(& «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<Field, 5: u32>, u32, Field) -> Unit)((#_ref returning & «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<Field, 5: u32>)(vec), (0: u32), (0: Field));
  (#_assert returning Unit)(((Array<Field, 5: u32> as «std-1.0.0-beta.12»::cmp::Eq<>)::eq<> as λ(Array<Field, 5: u32>, Array<Field, 5: u32>) -> bool)(vec.0, (#_mkArray returning Array<Field, 5: u32>)((0: Field), (10: Field), (44: Field), (0: Field), (0: Field))));
  #_skip
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::bounded_vec_tests::set::panics_when_writing_elements_past_end_of_vec<>() -> Unit := {
  let mut vec = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::new<Field, 5: u32> as λ() -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<Field, 5: u32>)();
  («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::set<Field, 5: u32> as λ(& «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<Field, 5: u32>, u32, Field) -> Unit)((#_ref returning & «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<Field, 5: u32>)(vec), (0: u32), (42: Field));
  #_skip
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::bounded_vec_tests::set::panics_when_setting_beyond_length<>() -> Unit := {
  let mut vec = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::from_array<u32, 5: u32, 3: u32> as λ(Array<u32, 3: u32>) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>)((#_mkArray returning Array<u32, 3: u32>)((1: u32), (2: u32), (3: u32)));
  («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::set<u32, 5: u32> as λ(& «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>, u32, u32) -> Unit)((#_ref returning & «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>)(vec), (3: u32), (4: u32));
  #_skip
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::bounded_vec_tests::set::set_unchecked_operations<>() -> Unit := {
  let mut vec = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::new<u32, 5: u32> as λ() -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>)();
  («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::push<u32, 5: u32> as λ(& «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>, u32) -> Unit)((#_ref returning & «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>)(vec), (1: u32));
  («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::push<u32, 5: u32> as λ(& «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>, u32) -> Unit)((#_ref returning & «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>)(vec), (2: u32));
  («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::set_unchecked<u32, 5: u32> as λ(& «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>, u32, u32) -> Unit)((#_ref returning & «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>)(vec), (0: u32), (10: u32));
  (#_assert returning Unit)((#_uEq returning bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::get<u32, 5: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>, u32) -> u32)(vec, (0: u32)), (10: u32)));
  #_skip
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::bounded_vec_tests::set::set_unchecked_operations_past_len<>() -> Unit := {
  let mut vec = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::new<u32, 5: u32> as λ() -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>)();
  («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::push<u32, 5: u32> as λ(& «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>, u32) -> Unit)((#_ref returning & «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>)(vec), (1: u32));
  («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::push<u32, 5: u32> as λ(& «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>, u32) -> Unit)((#_ref returning & «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>)(vec), (2: u32));
  («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::set_unchecked<u32, 5: u32> as λ(& «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>, u32, u32) -> Unit)((#_ref returning & «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>)(vec), (3: u32), (40: u32));
  (#_assert returning Unit)((#_uEq returning bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::get<u32, 5: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>, u32) -> u32)(vec, (3: u32)), (40: u32)));
  #_skip
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::bounded_vec_tests::set::set_preserves_other_elements<>() -> Unit := {
  let mut vec = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::from_array<u32, 5: u32> as λ(Array<u32, 5: u32>) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>)((#_mkArray returning Array<u32, 5: u32>)((1: u32), (2: u32), (3: u32), (4: u32), (5: u32)));
  («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::set<u32, 5: u32> as λ(& «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>, u32, u32) -> Unit)((#_ref returning & «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>)(vec), (2: u32), (30: u32));
  (#_assert returning Unit)((#_uEq returning bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::get<u32, 5: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>, u32) -> u32)(vec, (0: u32)), (1: u32)));
  (#_assert returning Unit)((#_uEq returning bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::get<u32, 5: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>, u32) -> u32)(vec, (1: u32)), (2: u32)));
  (#_assert returning Unit)((#_uEq returning bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::get<u32, 5: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>, u32) -> u32)(vec, (2: u32)), (30: u32)));
  (#_assert returning Unit)((#_uEq returning bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::get<u32, 5: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>, u32) -> u32)(vec, (3: u32)), (4: u32)));
  (#_assert returning Unit)((#_uEq returning bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::get<u32, 5: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>, u32) -> u32)(vec, (4: u32)), (5: u32)));
  #_skip
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::bounded_vec_tests::any::returns_false_if_predicate_not_satisfied<>() -> Unit := {
  let vec = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::from_array<bool, 4: u32> as λ(Array<bool, 4: u32>) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<bool, 4: u32>)((#_mkArray returning Array<bool, 4: u32>)(#_false, #_false, #_false, #_false));
  let result = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::any<bool, 4: u32, Unit> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<bool, 4: u32>, λ(bool) -> bool) -> bool)(vec, (fn(value: bool): bool := value));
  (#_assert returning Unit)((#_bNot returning bool)(result));
  #_skip
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::bounded_vec_tests::any::returns_true_if_predicate_satisfied<>() -> Unit := {
  let vec = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::from_array<bool, 4: u32> as λ(Array<bool, 4: u32>) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<bool, 4: u32>)((#_mkArray returning Array<bool, 4: u32>)(#_false, #_false, #_true, #_true));
  let result = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::any<bool, 4: u32, Unit> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<bool, 4: u32>, λ(bool) -> bool) -> bool)(vec, (fn(value: bool): bool := value));
  (#_assert returning Unit)(result);
  #_skip
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::bounded_vec_tests::any::returns_false_on_empty_boundedvec<>() -> Unit := {
  let vec = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::new<bool, 0: u32> as λ() -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<bool, 0: u32>)();
  let result = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::any<bool, 0: u32, Unit> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<bool, 0: u32>, λ(bool) -> bool) -> bool)(vec, (fn(value: bool): bool := value));
  (#_assert returning Unit)((#_bNot returning bool)(result));
  #_skip
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::bounded_vec_tests::any::any_with_complex_predicates<>() -> Unit := {
  let vec = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::from_array<u32, 5: u32> as λ(Array<u32, 5: u32>) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>)((#_mkArray returning Array<u32, 5: u32>)((1: u32), (2: u32), (3: u32), (4: u32), (5: u32)));
  (#_assert returning Unit)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::any<u32, 5: u32, Unit> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>, λ(u32) -> bool) -> bool)(vec, (fn(x: u32): bool := (#_uGt returning bool)(x, (3: u32)))));
  (#_assert returning Unit)((#_bNot returning bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::any<u32, 5: u32, Unit> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>, λ(u32) -> bool) -> bool)(vec, (fn(x: u32): bool := (#_uGt returning bool)(x, (10: u32))))));
  (#_assert returning Unit)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::any<u32, 5: u32, Unit> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>, λ(u32) -> bool) -> bool)(vec, (fn(x: u32): bool := (#_uEq returning bool)((#_uRem returning u32)(x, (2: u32)), (0: u32)))));
  (#_assert returning Unit)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::any<u32, 5: u32, Unit> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>, λ(u32) -> bool) -> bool)(vec, (fn(x: u32): bool := (#_uEq returning bool)(x, (3: u32)))));
  #_skip
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::bounded_vec_tests::any::any_with_partial_vector<>() -> Unit := {
  let mut vec = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::new<u32, 5: u32> as λ() -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>)();
  («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::push<u32, 5: u32> as λ(& «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>, u32) -> Unit)((#_ref returning & «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>)(vec), (1: u32));
  («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::push<u32, 5: u32> as λ(& «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>, u32) -> Unit)((#_ref returning & «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>)(vec), (2: u32));
  (#_assert returning Unit)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::any<u32, 5: u32, Unit> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>, λ(u32) -> bool) -> bool)(vec, (fn(x: u32): bool := (#_uEq returning bool)(x, (1: u32)))));
  (#_assert returning Unit)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::any<u32, 5: u32, Unit> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>, λ(u32) -> bool) -> bool)(vec, (fn(x: u32): bool := (#_uEq returning bool)(x, (2: u32)))));
  (#_assert returning Unit)((#_bNot returning bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::any<u32, 5: u32, Unit> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>, λ(u32) -> bool) -> bool)(vec, (fn(x: u32): bool := (#_uEq returning bool)(x, (3: u32))))));
  #_skip
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::bounded_vec_tests::map::applies_function_correctly<>() -> Unit := {
  let vec = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::from_array<u32, 4: u32> as λ(Array<u32, 4: u32>) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 4: u32>)((#_mkArray returning Array<u32, 4: u32>)((1: u32), (2: u32), (3: u32), (4: u32)));
  let result = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::map<u32, 4: u32, Unit> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 4: u32>, λ(u32) -> u32) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 4: u32>)(vec, (fn(value: u32): u32 := (#_uMul returning u32)(value, (2: u32))));
  let expected = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::from_array<u32, 4: u32> as λ(Array<u32, 4: u32>) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 4: u32>)((#_mkArray returning Array<u32, 4: u32>)((2: u32), (4: u32), (6: u32), (8: u32)));
  (#_assert returning Unit)(((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 4: u32> as «std-1.0.0-beta.12»::cmp::Eq<>)::eq<> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 4: u32>, «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 4: u32>) -> bool)(result, expected));
  #_skip
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::bounded_vec_tests::map::applies_function_that_changes_return_type<>() -> Unit := {
  let vec = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::from_array<u32, 4: u32> as λ(Array<u32, 4: u32>) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 4: u32>)((#_mkArray returning Array<u32, 4: u32>)((1: u32), (2: u32), (3: u32), (4: u32)));
  let result = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::map<u32, 4: u32, Field, Unit> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 4: u32>, λ(u32) -> Field) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<Field, 4: u32>)(vec, (fn(value: u32): Field := (#_cast returning Field)((#_uMul returning u32)(value, (2: u32)))));
  let expected = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::from_array<Field, 4: u32> as λ(Array<Field, 4: u32>) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<Field, 4: u32>)((#_mkArray returning Array<Field, 4: u32>)((2: Field), (4: Field), (6: Field), (8: Field)));
  (#_assert returning Unit)(((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<Field, 4: u32> as «std-1.0.0-beta.12»::cmp::Eq<>)::eq<> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<Field, 4: u32>, «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<Field, 4: u32>) -> bool)(result, expected));
  #_skip
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::bounded_vec_tests::map::does_not_apply_function_past_len<>() -> Unit := {
  let vec = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::from_array<u32, 3: u32, 2: u32> as λ(Array<u32, 2: u32>) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>)((#_mkArray returning Array<u32, 2: u32>)((0: u32), (1: u32)));
  let result = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::map<u32, 3: u32, Unit> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>, λ(u32) -> u32) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>)(vec, (fn(value: u32): u32 := if (#_uEq returning bool)(value, (0: u32)) then {
    (5: u32)
  } else {
    value
  }));
  let expected = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::from_array<u32, 3: u32, 2: u32> as λ(Array<u32, 2: u32>) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>)((#_mkArray returning Array<u32, 2: u32>)((5: u32), (1: u32)));
  (#_assert returning Unit)(((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32> as «std-1.0.0-beta.12»::cmp::Eq<>)::eq<> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>, «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>) -> bool)(result, expected));
  (#_assert returning Unit)((#_uEq returning bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::get_unchecked<u32, 3: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>, u32) -> u32)(result, (2: u32)), (0: u32)));
  #_skip
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::bounded_vec_tests::map::map_with_conditional_logic<>() -> Unit := {
  let vec = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::from_array<u32, 4: u32> as λ(Array<u32, 4: u32>) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 4: u32>)((#_mkArray returning Array<u32, 4: u32>)((1: u32), (2: u32), (3: u32), (4: u32)));
  let result = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::map<u32, 4: u32, Unit> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 4: u32>, λ(u32) -> u32) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 4: u32>)(vec, (fn(x: u32): u32 := if (#_uEq returning bool)((#_uRem returning u32)(x, (2: u32)), (0: u32)) then {
    (#_uMul returning u32)(x, (2: u32))
  } else {
    x
  }));
  let expected = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::from_array<u32, 4: u32> as λ(Array<u32, 4: u32>) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 4: u32>)((#_mkArray returning Array<u32, 4: u32>)((1: u32), (4: u32), (3: u32), (8: u32)));
  (#_assert returning Unit)(((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 4: u32> as «std-1.0.0-beta.12»::cmp::Eq<>)::eq<> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 4: u32>, «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 4: u32>) -> bool)(result, expected));
  #_skip
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::bounded_vec_tests::map::map_preserves_length<>() -> Unit := {
  let vec = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::from_array<u32, 4: u32> as λ(Array<u32, 4: u32>) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 4: u32>)((#_mkArray returning Array<u32, 4: u32>)((1: u32), (2: u32), (3: u32), (4: u32)));
  let result = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::map<u32, 4: u32, Unit> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 4: u32>, λ(u32) -> u32) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 4: u32>)(vec, (fn(x: u32): u32 := (#_uMul returning u32)(x, (2: u32))));
  (#_assert returning Unit)((#_uEq returning bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::len<u32, 4: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 4: u32>) -> u32)(result), («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::len<u32, 4: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 4: u32>) -> u32)(vec)));
  (#_assert returning Unit)((#_uEq returning bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::max_len<u32, 4: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 4: u32>) -> u32)(result), («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::max_len<u32, 4: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 4: u32>) -> u32)(vec)));
  #_skip
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::bounded_vec_tests::map::map_on_empty_vector<>() -> Unit := {
  let vec = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::new<u32, 5: u32> as λ() -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>)();
  let result = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::map<u32, 5: u32, Unit> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>, λ(u32) -> u32) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>)(vec, (fn(x: u32): u32 := (#_uMul returning u32)(x, (2: u32))));
  (#_assert returning Unit)(((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32> as «std-1.0.0-beta.12»::cmp::Eq<>)::eq<> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>, «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>) -> bool)(result, vec));
  (#_assert returning Unit)((#_uEq returning bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::len<u32, 5: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>) -> u32)(result), (0: u32)));
  (#_assert returning Unit)((#_uEq returning bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::max_len<u32, 5: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>) -> u32)(result), (5: u32)));
  #_skip
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::bounded_vec_tests::mapi::applies_function_correctly<>() -> Unit := {
  let vec = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::from_array<u32, 4: u32> as λ(Array<u32, 4: u32>) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 4: u32>)((#_mkArray returning Array<u32, 4: u32>)((1: u32), (2: u32), (3: u32), (4: u32)));
  let result = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::mapi<u32, 4: u32, Unit> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 4: u32>, λ(u32, u32) -> u32) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 4: u32>)(vec, (fn(i: u32, value: u32): u32 := (#_uAdd returning u32)(i, (#_uMul returning u32)(value, (2: u32)))));
  let expected = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::from_array<u32, 4: u32> as λ(Array<u32, 4: u32>) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 4: u32>)((#_mkArray returning Array<u32, 4: u32>)((2: u32), (5: u32), (8: u32), (11: u32)));
  (#_assert returning Unit)(((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 4: u32> as «std-1.0.0-beta.12»::cmp::Eq<>)::eq<> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 4: u32>, «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 4: u32>) -> bool)(result, expected));
  #_skip
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::bounded_vec_tests::mapi::applies_function_that_changes_return_type<>() -> Unit := {
  let vec = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::from_array<u32, 4: u32> as λ(Array<u32, 4: u32>) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 4: u32>)((#_mkArray returning Array<u32, 4: u32>)((1: u32), (2: u32), (3: u32), (4: u32)));
  let result = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::mapi<u32, 4: u32, Field, Unit> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 4: u32>, λ(u32, u32) -> Field) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<Field, 4: u32>)(vec, (fn(i: u32, value: u32): Field := (#_cast returning Field)((#_uAdd returning u32)(i, (#_uMul returning u32)(value, (2: u32))))));
  let expected = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::from_array<Field, 4: u32> as λ(Array<Field, 4: u32>) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<Field, 4: u32>)((#_mkArray returning Array<Field, 4: u32>)((2: Field), (5: Field), (8: Field), (11: Field)));
  (#_assert returning Unit)(((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<Field, 4: u32> as «std-1.0.0-beta.12»::cmp::Eq<>)::eq<> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<Field, 4: u32>, «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<Field, 4: u32>) -> bool)(result, expected));
  #_skip
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::bounded_vec_tests::mapi::does_not_apply_function_past_len<>() -> Unit := {
  let vec = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::from_array<u32, 3: u32, 2: u32> as λ(Array<u32, 2: u32>) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>)((#_mkArray returning Array<u32, 2: u32>)((0: u32), (1: u32)));
  let result = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::mapi<u32, 3: u32, Unit> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>, λ(u32, u32) -> u32) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>)(vec, (fn(__0: u32, value: u32): u32 := if (#_uEq returning bool)(value, (0: u32)) then {
    (5: u32)
  } else {
    value
  }));
  let expected = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::from_array<u32, 3: u32, 2: u32> as λ(Array<u32, 2: u32>) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>)((#_mkArray returning Array<u32, 2: u32>)((5: u32), (1: u32)));
  (#_assert returning Unit)(((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32> as «std-1.0.0-beta.12»::cmp::Eq<>)::eq<> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>, «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>) -> bool)(result, expected));
  (#_assert returning Unit)((#_uEq returning bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::get_unchecked<u32, 3: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>, u32) -> u32)(result, (2: u32)), (0: u32)));
  #_skip
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::bounded_vec_tests::mapi::mapi_with_index_branching_logic<>() -> Unit := {
  let vec = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::from_array<u32, 4: u32> as λ(Array<u32, 4: u32>) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 4: u32>)((#_mkArray returning Array<u32, 4: u32>)((1: u32), (2: u32), (3: u32), (4: u32)));
  let result = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::mapi<u32, 4: u32, Unit> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 4: u32>, λ(u32, u32) -> u32) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 4: u32>)(vec, (fn(i: u32, x: u32): u32 := if (#_uEq returning bool)((#_uRem returning u32)(i, (2: u32)), (0: u32)) then {
    (#_uMul returning u32)(x, (2: u32))
  } else {
    x
  }));
  let expected = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::from_array<u32, 4: u32> as λ(Array<u32, 4: u32>) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 4: u32>)((#_mkArray returning Array<u32, 4: u32>)((2: u32), (2: u32), (6: u32), (4: u32)));
  (#_assert returning Unit)(((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 4: u32> as «std-1.0.0-beta.12»::cmp::Eq<>)::eq<> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 4: u32>, «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 4: u32>) -> bool)(result, expected));
  #_skip
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::bounded_vec_tests::for_each::for_each_map<T: Type, U: Type, Env: Type, MaxLen: u32>(input: «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32>, f: λ(T) -> U) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<U, MaxLen: u32> := {
  let mut output = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::new<U, MaxLen: u32> as λ() -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<U, MaxLen: u32>)();
  let output_ref = (#_ref returning & «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<U, MaxLen: u32>)(output);
  («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::for_each<T, MaxLen: u32, Tuple<& «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<U, MaxLen: u32>, λ(T) -> U> > as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32>, λ(T) -> Unit) -> Unit)(input, (fn(x: T): Unit := («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::push<U, MaxLen: u32> as λ(& «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<U, MaxLen: u32>, U) -> Unit)(output_ref, (f as λ(T) -> U)(x))));
  output
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::bounded_vec_tests::for_each::smoke_test<>() -> Unit := {
  let mut acc = (0: u32);
  let acc_ref = (#_ref returning & u32)(acc);
  let vec = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::from_array<u32, 3: u32> as λ(Array<u32, 3: u32>) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>)((#_mkArray returning Array<u32, 3: u32>)((1: u32), (2: u32), (3: u32)));
  («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::for_each<u32, 3: u32, Tuple<& u32> > as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>, λ(u32) -> Unit) -> Unit)(vec, (fn(value: u32): Unit := {
    (*acc_ref: u32) = (#_uAdd returning u32)((#_readRef returning u32)(acc_ref), value);
    #_skip
  }));
  (#_assert returning Unit)((#_uEq returning bool)(acc, (6: u32)));
  #_skip
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::bounded_vec_tests::for_each::applies_function_correctly<>() -> Unit := {
  let vec = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::from_array<u32, 4: u32> as λ(Array<u32, 4: u32>) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 4: u32>)((#_mkArray returning Array<u32, 4: u32>)((1: u32), (2: u32), (3: u32), (4: u32)));
  let result = («std-1.0.0-beta.12»::collections::bounded_vec::bounded_vec_tests::for_each::for_each_map<u32, Unit, 4: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 4: u32>, λ(u32) -> u32) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 4: u32>)(vec, (fn(value: u32): u32 := (#_uMul returning u32)(value, (2: u32))));
  let expected = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::from_array<u32, 4: u32> as λ(Array<u32, 4: u32>) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 4: u32>)((#_mkArray returning Array<u32, 4: u32>)((2: u32), (4: u32), (6: u32), (8: u32)));
  (#_assert returning Unit)(((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 4: u32> as «std-1.0.0-beta.12»::cmp::Eq<>)::eq<> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 4: u32>, «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 4: u32>) -> bool)(result, expected));
  #_skip
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::bounded_vec_tests::for_each::applies_function_that_changes_return_type<>() -> Unit := {
  let vec = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::from_array<u32, 4: u32> as λ(Array<u32, 4: u32>) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 4: u32>)((#_mkArray returning Array<u32, 4: u32>)((1: u32), (2: u32), (3: u32), (4: u32)));
  let result = («std-1.0.0-beta.12»::collections::bounded_vec::bounded_vec_tests::for_each::for_each_map<u32, Field, Unit, 4: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 4: u32>, λ(u32) -> Field) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<Field, 4: u32>)(vec, (fn(value: u32): Field := (#_cast returning Field)((#_uMul returning u32)(value, (2: u32)))));
  let expected = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::from_array<Field, 4: u32> as λ(Array<Field, 4: u32>) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<Field, 4: u32>)((#_mkArray returning Array<Field, 4: u32>)((2: Field), (4: Field), (6: Field), (8: Field)));
  (#_assert returning Unit)(((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<Field, 4: u32> as «std-1.0.0-beta.12»::cmp::Eq<>)::eq<> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<Field, 4: u32>, «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<Field, 4: u32>) -> bool)(result, expected));
  #_skip
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::bounded_vec_tests::for_each::does_not_apply_function_past_len<>() -> Unit := {
  let vec = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::from_array<u32, 3: u32, 2: u32> as λ(Array<u32, 2: u32>) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>)((#_mkArray returning Array<u32, 2: u32>)((0: u32), (1: u32)));
  let result = («std-1.0.0-beta.12»::collections::bounded_vec::bounded_vec_tests::for_each::for_each_map<u32, Unit, 3: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>, λ(u32) -> u32) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>)(vec, (fn(value: u32): u32 := if (#_uEq returning bool)(value, (0: u32)) then {
    (5: u32)
  } else {
    value
  }));
  let expected = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::from_array<u32, 3: u32, 2: u32> as λ(Array<u32, 2: u32>) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>)((#_mkArray returning Array<u32, 2: u32>)((5: u32), (1: u32)));
  (#_assert returning Unit)(((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32> as «std-1.0.0-beta.12»::cmp::Eq<>)::eq<> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>, «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>) -> bool)(result, expected));
  (#_assert returning Unit)((#_uEq returning bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::get_unchecked<u32, 3: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>, u32) -> u32)(result, (2: u32)), (0: u32)));
  #_skip
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::bounded_vec_tests::for_each::for_each_on_empty_vector<>() -> Unit := {
  let vec = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::new<u32, 5: u32> as λ() -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>)();
  let mut count = (0: Field);
  let count_ref = (#_ref returning & Field)(count);
  («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::for_each<u32, 5: u32, Tuple<& Field> > as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>, λ(u32) -> Unit) -> Unit)(vec, (fn(__0: u32): Unit := {
    (*count_ref: Field) = (#_fAdd returning Field)((#_readRef returning Field)(count_ref), (1: Field));
    #_skip
  }));
  (#_assert returning Unit)((#_fEq returning bool)(count, (0: Field)));
  #_skip
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::bounded_vec_tests::for_each::for_each_with_side_effects<>() -> Unit := {
  let vec = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::from_array<u32, 3: u32> as λ(Array<u32, 3: u32>) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>)((#_mkArray returning Array<u32, 3: u32>)((1: u32), (2: u32), (3: u32)));
  let mut seen = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::new<u32, 3: u32> as λ() -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>)();
  let seen_ref = (#_ref returning & «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>)(seen);
  («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::for_each<u32, 3: u32, Tuple<& «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32> > > as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>, λ(u32) -> Unit) -> Unit)(vec, (fn(x: u32): Unit := («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::push<u32, 3: u32> as λ(& «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>, u32) -> Unit)(seen_ref, x)));
  (#_assert returning Unit)(((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32> as «std-1.0.0-beta.12»::cmp::Eq<>)::eq<> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>, «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>) -> bool)(seen, vec));
  #_skip
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::bounded_vec_tests::for_eachi::for_eachi_mapi<T: Type, U: Type, Env: Type, MaxLen: u32>(input: «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32>, f: λ(u32, T) -> U) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<U, MaxLen: u32> := {
  let mut output = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::new<U, MaxLen: u32> as λ() -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<U, MaxLen: u32>)();
  let output_ref = (#_ref returning & «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<U, MaxLen: u32>)(output);
  («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::for_eachi<T, MaxLen: u32, Tuple<& «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<U, MaxLen: u32>, λ(u32, T) -> U> > as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<T, MaxLen: u32>, λ(u32, T) -> Unit) -> Unit)(input, (fn(i: u32, x: T): Unit := («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::push<U, MaxLen: u32> as λ(& «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<U, MaxLen: u32>, U) -> Unit)(output_ref, (f as λ(u32, T) -> U)(i, x))));
  output
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::bounded_vec_tests::for_eachi::smoke_test<>() -> Unit := {
  let mut acc = (0: u32);
  let acc_ref = (#_ref returning & u32)(acc);
  let vec = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::from_array<u32, 3: u32> as λ(Array<u32, 3: u32>) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>)((#_mkArray returning Array<u32, 3: u32>)((1: u32), (2: u32), (3: u32)));
  («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::for_eachi<u32, 3: u32, Tuple<& u32> > as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>, λ(u32, u32) -> Unit) -> Unit)(vec, (fn(i: u32, value: u32): Unit := {
    (*acc_ref: u32) = (#_uAdd returning u32)((#_readRef returning u32)(acc_ref), (#_uMul returning u32)(i, value));
    #_skip
  }));
  (#_assert returning Unit)((#_uEq returning bool)(acc, (8: u32)));
  #_skip
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::bounded_vec_tests::for_eachi::applies_function_correctly<>() -> Unit := {
  let vec = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::from_array<u32, 4: u32> as λ(Array<u32, 4: u32>) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 4: u32>)((#_mkArray returning Array<u32, 4: u32>)((1: u32), (2: u32), (3: u32), (4: u32)));
  let result = («std-1.0.0-beta.12»::collections::bounded_vec::bounded_vec_tests::for_eachi::for_eachi_mapi<u32, Unit, 4: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 4: u32>, λ(u32, u32) -> u32) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 4: u32>)(vec, (fn(i: u32, value: u32): u32 := (#_uAdd returning u32)(i, (#_uMul returning u32)(value, (2: u32)))));
  let expected = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::from_array<u32, 4: u32> as λ(Array<u32, 4: u32>) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 4: u32>)((#_mkArray returning Array<u32, 4: u32>)((2: u32), (5: u32), (8: u32), (11: u32)));
  (#_assert returning Unit)(((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 4: u32> as «std-1.0.0-beta.12»::cmp::Eq<>)::eq<> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 4: u32>, «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 4: u32>) -> bool)(result, expected));
  #_skip
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::bounded_vec_tests::for_eachi::applies_function_that_changes_return_type<>() -> Unit := {
  let vec = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::from_array<u32, 4: u32> as λ(Array<u32, 4: u32>) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 4: u32>)((#_mkArray returning Array<u32, 4: u32>)((1: u32), (2: u32), (3: u32), (4: u32)));
  let result = («std-1.0.0-beta.12»::collections::bounded_vec::bounded_vec_tests::for_eachi::for_eachi_mapi<u32, Field, Unit, 4: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 4: u32>, λ(u32, u32) -> Field) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<Field, 4: u32>)(vec, (fn(i: u32, value: u32): Field := (#_cast returning Field)((#_uAdd returning u32)(i, (#_uMul returning u32)(value, (2: u32))))));
  let expected = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::from_array<Field, 4: u32> as λ(Array<Field, 4: u32>) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<Field, 4: u32>)((#_mkArray returning Array<Field, 4: u32>)((2: Field), (5: Field), (8: Field), (11: Field)));
  (#_assert returning Unit)(((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<Field, 4: u32> as «std-1.0.0-beta.12»::cmp::Eq<>)::eq<> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<Field, 4: u32>, «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<Field, 4: u32>) -> bool)(result, expected));
  #_skip
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::bounded_vec_tests::for_eachi::does_not_apply_function_past_len<>() -> Unit := {
  let vec = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::from_array<u32, 3: u32, 2: u32> as λ(Array<u32, 2: u32>) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>)((#_mkArray returning Array<u32, 2: u32>)((0: u32), (1: u32)));
  let result = («std-1.0.0-beta.12»::collections::bounded_vec::bounded_vec_tests::for_eachi::for_eachi_mapi<u32, Unit, 3: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>, λ(u32, u32) -> u32) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>)(vec, (fn(__0: u32, value: u32): u32 := if (#_uEq returning bool)(value, (0: u32)) then {
    (5: u32)
  } else {
    value
  }));
  let expected = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::from_array<u32, 3: u32, 2: u32> as λ(Array<u32, 2: u32>) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>)((#_mkArray returning Array<u32, 2: u32>)((5: u32), (1: u32)));
  (#_assert returning Unit)(((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32> as «std-1.0.0-beta.12»::cmp::Eq<>)::eq<> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>, «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>) -> bool)(result, expected));
  (#_assert returning Unit)((#_uEq returning bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::get_unchecked<u32, 3: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>, u32) -> u32)(result, (2: u32)), (0: u32)));
  #_skip
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::bounded_vec_tests::for_eachi::for_eachi_on_empty_vector<>() -> Unit := {
  let vec = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::new<u32, 5: u32> as λ() -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>)();
  let mut count = (0: Field);
  let count_ref = (#_ref returning & Field)(count);
  («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::for_eachi<u32, 5: u32, Tuple<& Field> > as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>, λ(u32, u32) -> Unit) -> Unit)(vec, (fn(__0: u32, __1: u32): Unit := {
    (*count_ref: Field) = (#_fAdd returning Field)((#_readRef returning Field)(count_ref), (1: Field));
    #_skip
  }));
  (#_assert returning Unit)((#_fEq returning bool)(count, (0: Field)));
  #_skip
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::bounded_vec_tests::for_eachi::for_eachi_with_index_tracking<>() -> Unit := {
  let vec = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::from_array<u32, 3: u32> as λ(Array<u32, 3: u32>) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>)((#_mkArray returning Array<u32, 3: u32>)((10: u32), (20: u32), (30: u32)));
  let mut indices = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::new<u32, 3: u32> as λ() -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>)();
  let indices_ref = (#_ref returning & «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>)(indices);
  («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::for_eachi<u32, 3: u32, Tuple<& «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32> > > as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>, λ(u32, u32) -> Unit) -> Unit)(vec, (fn(i: u32, __0: u32): Unit := («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::push<u32, 3: u32> as λ(& «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>, u32) -> Unit)(indices_ref, i)));
  let expected = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::from_array<u32, 3: u32> as λ(Array<u32, 3: u32>) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>)((#_mkArray returning Array<u32, 3: u32>)((0: u32), (1: u32), (2: u32)));
  (#_assert returning Unit)(((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32> as «std-1.0.0-beta.12»::cmp::Eq<>)::eq<> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>, «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>) -> bool)(indices, expected));
  #_skip
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::bounded_vec_tests::from_array::empty<>() -> Unit := {
  let empty_array = (#_mkArray returning Array<Field, 0: u32>)();
  let bounded_vec = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::from_array<Field, 0: u32> as λ(Array<Field, 0: u32>) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<Field, 0: u32>)((#_mkArray returning Array<Field, 0: u32>)());
  (#_assert returning Unit)((#_uEq returning bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::max_len<Field, 0: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<Field, 0: u32>) -> u32)(bounded_vec), (0: u32)));
  (#_assert returning Unit)((#_uEq returning bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::len<Field, 0: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<Field, 0: u32>) -> u32)(bounded_vec), (0: u32)));
  (#_assert returning Unit)(((Array<Field, 0: u32> as «std-1.0.0-beta.12»::cmp::Eq<>)::eq<> as λ(Array<Field, 0: u32>, Array<Field, 0: u32>) -> bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::storage<Field, 0: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<Field, 0: u32>) -> Array<Field, 0: u32>)(bounded_vec), empty_array));
  #_skip
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::bounded_vec_tests::from_array::equal_len<>() -> Unit := {
  let array = (#_mkArray returning Array<Field, 3: u32>)((1: Field), (2: Field), (3: Field));
  let bounded_vec = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::from_array<Field, 3: u32> as λ(Array<Field, 3: u32>) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<Field, 3: u32>)(array);
  (#_assert returning Unit)((#_uEq returning bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::max_len<Field, 3: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<Field, 3: u32>) -> u32)(bounded_vec), (3: u32)));
  (#_assert returning Unit)((#_uEq returning bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::len<Field, 3: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<Field, 3: u32>) -> u32)(bounded_vec), (3: u32)));
  (#_assert returning Unit)(((Array<Field, 3: u32> as «std-1.0.0-beta.12»::cmp::Eq<>)::eq<> as λ(Array<Field, 3: u32>, Array<Field, 3: u32>) -> bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::storage<Field, 3: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<Field, 3: u32>) -> Array<Field, 3: u32>)(bounded_vec), array));
  #_skip
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::bounded_vec_tests::from_array::max_len_greater_then_array_len<>() -> Unit := {
  let array = (#_mkArray returning Array<Field, 3: u32>)((1: Field), (2: Field), (3: Field));
  let bounded_vec = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::from_array<Field, 10: u32, 3: u32> as λ(Array<Field, 3: u32>) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<Field, 10: u32>)(array);
  (#_assert returning Unit)((#_uEq returning bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::max_len<Field, 10: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<Field, 10: u32>) -> u32)(bounded_vec), (10: u32)));
  (#_assert returning Unit)((#_uEq returning bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::len<Field, 10: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<Field, 10: u32>) -> u32)(bounded_vec), (3: u32)));
  (#_assert returning Unit)((#_fEq returning bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::get<Field, 10: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<Field, 10: u32>, u32) -> Field)(bounded_vec, (0: u32)), (1: Field)));
  (#_assert returning Unit)((#_fEq returning bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::get<Field, 10: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<Field, 10: u32>, u32) -> Field)(bounded_vec, (1: u32)), (2: Field)));
  (#_assert returning Unit)((#_fEq returning bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::get<Field, 10: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<Field, 10: u32>, u32) -> Field)(bounded_vec, (2: u32)), (3: Field)));
  #_skip
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::bounded_vec_tests::from_array::max_len_lower_then_array_len<>() -> Unit := {
  let __0 = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::from_array<Field, 2: u32, 3: u32> as λ(Array<Field, 3: u32>) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<Field, 2: u32>)((#_mkRepeatedArray returning Array<Field, 3: u32>)((0: Field)));
  #_skip
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::bounded_vec_tests::from_array::from_array_preserves_order<>() -> Unit := {
  let array = (#_mkArray returning Array<u32, 5: u32>)((5: u32), (3: u32), (1: u32), (4: u32), (2: u32));
  let vec = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::from_array<u32, 5: u32> as λ(Array<u32, 5: u32>) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>)(array);
  for i in (0: u32) .. (#_arrayLen returning u32)(array) do {
    (#_assert returning Unit)((#_uEq returning bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::get<u32, 5: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>, u32) -> u32)(vec, i), (#_arrayIndex returning u32)(array, (#_cast returning u32)(i))));
    #_skip
  };
  #_skip
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::bounded_vec_tests::from_array::from_array_with_different_types<>() -> Unit := {
  let bool_array = (#_mkArray returning Array<bool, 3: u32>)(#_true, #_false, #_true);
  let bool_vec = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::from_array<bool, 3: u32> as λ(Array<bool, 3: u32>) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<bool, 3: u32>)(bool_array);
  (#_assert returning Unit)((#_uEq returning bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::len<bool, 3: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<bool, 3: u32>) -> u32)(bool_vec), (3: u32)));
  (#_assert returning Unit)((#_bEq returning bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::get<bool, 3: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<bool, 3: u32>, u32) -> bool)(bool_vec, (0: u32)), #_true));
  (#_assert returning Unit)((#_bEq returning bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::get<bool, 3: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<bool, 3: u32>, u32) -> bool)(bool_vec, (1: u32)), #_false));
  #_skip
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::bounded_vec_tests::trait_from::simple<>() -> Unit := {
  let array = (#_mkArray returning Array<Field, 2: u32>)((1: Field), (2: Field));
  let bounded_vec = ((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<Field, 10: u32> as «std-1.0.0-beta.12»::convert::From<Array<Field, 2: u32> >)::«from»<> as λ(Array<Field, 2: u32>) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<Field, 10: u32>)(array);
  (#_assert returning Unit)((#_uEq returning bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::max_len<Field, 10: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<Field, 10: u32>) -> u32)(bounded_vec), (10: u32)));
  (#_assert returning Unit)((#_uEq returning bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::len<Field, 10: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<Field, 10: u32>) -> u32)(bounded_vec), (2: u32)));
  (#_assert returning Unit)((#_fEq returning bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::get<Field, 10: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<Field, 10: u32>, u32) -> Field)(bounded_vec, (0: u32)), (1: Field)));
  (#_assert returning Unit)((#_fEq returning bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::get<Field, 10: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<Field, 10: u32>, u32) -> Field)(bounded_vec, (1: u32)), (2: Field)));
  #_skip
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::bounded_vec_tests::trait_eq::empty_equality<>() -> Unit := {
  let mut bounded_vec1 = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::new<Field, 3: u32> as λ() -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<Field, 3: u32>)();
  let mut bounded_vec2 = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::new<Field, 3: u32> as λ() -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<Field, 3: u32>)();
  (#_assert returning Unit)(((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<Field, 3: u32> as «std-1.0.0-beta.12»::cmp::Eq<>)::eq<> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<Field, 3: u32>, «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<Field, 3: u32>) -> bool)(bounded_vec1, bounded_vec2));
  #_skip
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::bounded_vec_tests::trait_eq::inequality<>() -> Unit := {
  let mut bounded_vec1 = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::new<Field, 3: u32> as λ() -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<Field, 3: u32>)();
  let mut bounded_vec2 = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::new<Field, 3: u32> as λ() -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<Field, 3: u32>)();
  («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::push<Field, 3: u32> as λ(& «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<Field, 3: u32>, Field) -> Unit)((#_ref returning & «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<Field, 3: u32>)(bounded_vec1), (1: Field));
  («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::push<Field, 3: u32> as λ(& «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<Field, 3: u32>, Field) -> Unit)((#_ref returning & «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<Field, 3: u32>)(bounded_vec2), (2: Field));
  (#_assert returning Unit)(((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<Field, 3: u32> as «std-1.0.0-beta.12»::cmp::Eq<>)::eq<> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<Field, 3: u32>, «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<Field, 3: u32>) -> bool)(bounded_vec1, bounded_vec2));
  #_skip
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::bounded_vec_tests::from_parts::from_parts<>() -> Unit := {
  let vec = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::from_parts<u32, 4: u32> as λ(Array<u32, 4: u32>, u32) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 4: u32>)((#_mkArray returning Array<u32, 4: u32>)((1: u32), (2: u32), (3: u32), (0: u32)), (3: u32));
  (#_assert returning Unit)((#_uEq returning bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::len<u32, 4: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 4: u32>) -> u32)(vec), (3: u32)));
  let vec1 = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::from_parts<u32, 4: u32> as λ(Array<u32, 4: u32>, u32) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 4: u32>)((#_mkArray returning Array<u32, 4: u32>)((1: u32), (2: u32), (3: u32), (1: u32)), (3: u32));
  let vec2 = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::from_parts<u32, 4: u32> as λ(Array<u32, 4: u32>, u32) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 4: u32>)((#_mkArray returning Array<u32, 4: u32>)((1: u32), (2: u32), (3: u32), (2: u32)), (3: u32));
  (#_assert returning Unit)(((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 4: u32> as «std-1.0.0-beta.12»::cmp::Eq<>)::eq<> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 4: u32>, «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 4: u32>) -> bool)(vec1, vec2));
  #_skip
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::bounded_vec_tests::from_parts::from_parts_unchecked<>() -> Unit := {
  let vec = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::from_parts_unchecked<u32, 4: u32> as λ(Array<u32, 4: u32>, u32) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 4: u32>)((#_mkArray returning Array<u32, 4: u32>)((1: u32), (2: u32), (3: u32), (0: u32)), (3: u32));
  (#_assert returning Unit)((#_uEq returning bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::len<u32, 4: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 4: u32>) -> u32)(vec), (3: u32)));
  let vec1 = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::from_parts_unchecked<u32, 4: u32> as λ(Array<u32, 4: u32>, u32) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 4: u32>)((#_mkArray returning Array<u32, 4: u32>)((1: u32), (2: u32), (3: u32), (1: u32)), (3: u32));
  let vec2 = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::from_parts_unchecked<u32, 4: u32> as λ(Array<u32, 4: u32>, u32) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 4: u32>)((#_mkArray returning Array<u32, 4: u32>)((1: u32), (2: u32), (3: u32), (2: u32)), (3: u32));
  (#_assert returning Unit)(((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 4: u32> as «std-1.0.0-beta.12»::cmp::Eq<>)::eq<> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 4: u32>, «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 4: u32>) -> bool)(vec1, vec2));
  #_skip
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::bounded_vec_tests::push_pop::push_and_pop_operations<>() -> Unit := {
  let mut vec = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::new<u32, 5: u32> as λ() -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>)();
  (#_assert returning Unit)((#_uEq returning bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::len<u32, 5: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>) -> u32)(vec), (0: u32)));
  («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::push<u32, 5: u32> as λ(& «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>, u32) -> Unit)((#_ref returning & «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>)(vec), (1: u32));
  (#_assert returning Unit)((#_uEq returning bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::len<u32, 5: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>) -> u32)(vec), (1: u32)));
  (#_assert returning Unit)((#_uEq returning bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::get<u32, 5: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>, u32) -> u32)(vec, (0: u32)), (1: u32)));
  («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::push<u32, 5: u32> as λ(& «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>, u32) -> Unit)((#_ref returning & «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>)(vec), (2: u32));
  (#_assert returning Unit)((#_uEq returning bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::len<u32, 5: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>) -> u32)(vec), (2: u32)));
  (#_assert returning Unit)((#_uEq returning bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::get<u32, 5: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>, u32) -> u32)(vec, (1: u32)), (2: u32)));
  let popped = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::pop<u32, 5: u32> as λ(& «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>) -> u32)((#_ref returning & «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>)(vec));
  (#_assert returning Unit)((#_uEq returning bool)(popped, (2: u32)));
  (#_assert returning Unit)((#_uEq returning bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::len<u32, 5: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>) -> u32)(vec), (1: u32)));
  let popped2 = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::pop<u32, 5: u32> as λ(& «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>) -> u32)((#_ref returning & «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>)(vec));
  (#_assert returning Unit)((#_uEq returning bool)(popped2, (1: u32)));
  (#_assert returning Unit)((#_uEq returning bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::len<u32, 5: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>) -> u32)(vec), (0: u32)));
  #_skip
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::bounded_vec_tests::push_pop::push_to_full_vector<>() -> Unit := {
  let mut vec = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::new<u32, 2: u32> as λ() -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 2: u32>)();
  («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::push<u32, 2: u32> as λ(& «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 2: u32>, u32) -> Unit)((#_ref returning & «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 2: u32>)(vec), (1: u32));
  («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::push<u32, 2: u32> as λ(& «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 2: u32>, u32) -> Unit)((#_ref returning & «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 2: u32>)(vec), (2: u32));
  («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::push<u32, 2: u32> as λ(& «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 2: u32>, u32) -> Unit)((#_ref returning & «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 2: u32>)(vec), (3: u32));
  #_skip
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::bounded_vec_tests::push_pop::pop_from_empty_vector<>() -> Unit := {
  let mut vec = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::new<u32, 5: u32> as λ() -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>)();
  let __0 = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::pop<u32, 5: u32> as λ(& «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>) -> u32)((#_ref returning & «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>)(vec));
  #_skip
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::bounded_vec_tests::push_pop::push_pop_cycle<>() -> Unit := {
  let mut vec = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::new<u32, 3: u32> as λ() -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>)();
  («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::push<u32, 3: u32> as λ(& «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>, u32) -> Unit)((#_ref returning & «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>)(vec), (1: u32));
  («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::push<u32, 3: u32> as λ(& «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>, u32) -> Unit)((#_ref returning & «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>)(vec), (2: u32));
  («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::push<u32, 3: u32> as λ(& «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>, u32) -> Unit)((#_ref returning & «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>)(vec), (3: u32));
  (#_assert returning Unit)((#_uEq returning bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::len<u32, 3: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>) -> u32)(vec), (3: u32)));
  (#_assert returning Unit)((#_uEq returning bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::pop<u32, 3: u32> as λ(& «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>) -> u32)((#_ref returning & «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>)(vec)), (3: u32)));
  (#_assert returning Unit)((#_uEq returning bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::pop<u32, 3: u32> as λ(& «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>) -> u32)((#_ref returning & «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>)(vec)), (2: u32)));
  (#_assert returning Unit)((#_uEq returning bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::pop<u32, 3: u32> as λ(& «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>) -> u32)((#_ref returning & «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>)(vec)), (1: u32)));
  (#_assert returning Unit)((#_uEq returning bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::len<u32, 3: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>) -> u32)(vec), (0: u32)));
  («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::push<u32, 3: u32> as λ(& «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>, u32) -> Unit)((#_ref returning & «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>)(vec), (4: u32));
  (#_assert returning Unit)((#_uEq returning bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::len<u32, 3: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>) -> u32)(vec), (1: u32)));
  (#_assert returning Unit)((#_uEq returning bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::get<u32, 3: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>, u32) -> u32)(vec, (0: u32)), (4: u32)));
  #_skip
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::bounded_vec_tests::extend::extend_from_array<>() -> Unit := {
  let mut vec = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::new<u32, 5: u32> as λ() -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>)();
  («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::push<u32, 5: u32> as λ(& «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>, u32) -> Unit)((#_ref returning & «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>)(vec), (1: u32));
  («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::extend_from_array<u32, 5: u32, 2: u32> as λ(& «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>, Array<u32, 2: u32>) -> Unit)((#_ref returning & «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>)(vec), (#_mkArray returning Array<u32, 2: u32>)((2: u32), (3: u32)));
  (#_assert returning Unit)((#_uEq returning bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::len<u32, 5: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>) -> u32)(vec), (3: u32)));
  (#_assert returning Unit)((#_uEq returning bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::get<u32, 5: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>, u32) -> u32)(vec, (0: u32)), (1: u32)));
  (#_assert returning Unit)((#_uEq returning bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::get<u32, 5: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>, u32) -> u32)(vec, (1: u32)), (2: u32)));
  (#_assert returning Unit)((#_uEq returning bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::get<u32, 5: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>, u32) -> u32)(vec, (2: u32)), (3: u32)));
  #_skip
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::bounded_vec_tests::extend::extend_from_slice<>() -> Unit := {
  let mut vec = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::new<u32, 5: u32> as λ() -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>)();
  («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::push<u32, 5: u32> as λ(& «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>, u32) -> Unit)((#_ref returning & «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>)(vec), (1: u32));
  («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::extend_from_slice<u32, 5: u32> as λ(& «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>, Slice<u32>) -> Unit)((#_ref returning & «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>)(vec), (#_mkSlice returning Slice<u32>)((2: u32), (3: u32)));
  (#_assert returning Unit)((#_uEq returning bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::len<u32, 5: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>) -> u32)(vec), (3: u32)));
  (#_assert returning Unit)((#_uEq returning bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::get<u32, 5: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>, u32) -> u32)(vec, (0: u32)), (1: u32)));
  (#_assert returning Unit)((#_uEq returning bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::get<u32, 5: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>, u32) -> u32)(vec, (1: u32)), (2: u32)));
  (#_assert returning Unit)((#_uEq returning bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::get<u32, 5: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>, u32) -> u32)(vec, (2: u32)), (3: u32)));
  #_skip
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::bounded_vec_tests::extend::extend_from_bounded_vec<>() -> Unit := {
  let mut vec1 = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::new<u32, 5: u32> as λ() -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>)();
  let mut vec2 = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::new<u32, 3: u32> as λ() -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>)();
  («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::push<u32, 5: u32> as λ(& «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>, u32) -> Unit)((#_ref returning & «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>)(vec1), (1: u32));
  («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::push<u32, 3: u32> as λ(& «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>, u32) -> Unit)((#_ref returning & «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>)(vec2), (2: u32));
  («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::push<u32, 3: u32> as λ(& «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>, u32) -> Unit)((#_ref returning & «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>)(vec2), (3: u32));
  («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::extend_from_bounded_vec<u32, 5: u32, 3: u32> as λ(& «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>, «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>) -> Unit)((#_ref returning & «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>)(vec1), vec2);
  (#_assert returning Unit)((#_uEq returning bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::len<u32, 5: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>) -> u32)(vec1), (3: u32)));
  (#_assert returning Unit)((#_uEq returning bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::get<u32, 5: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>, u32) -> u32)(vec1, (0: u32)), (1: u32)));
  (#_assert returning Unit)((#_uEq returning bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::get<u32, 5: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>, u32) -> u32)(vec1, (1: u32)), (2: u32)));
  (#_assert returning Unit)((#_uEq returning bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::get<u32, 5: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>, u32) -> u32)(vec1, (2: u32)), (3: u32)));
  #_skip
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::bounded_vec_tests::extend::extend_array_beyond_max_len<>() -> Unit := {
  let mut vec = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::new<u32, 3: u32> as λ() -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>)();
  («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::push<u32, 3: u32> as λ(& «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>, u32) -> Unit)((#_ref returning & «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>)(vec), (1: u32));
  («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::extend_from_array<u32, 3: u32> as λ(& «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>, Array<u32, 3: u32>) -> Unit)((#_ref returning & «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>)(vec), (#_mkArray returning Array<u32, 3: u32>)((2: u32), (3: u32), (4: u32)));
  #_skip
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::bounded_vec_tests::extend::extend_slice_beyond_max_len<>() -> Unit := {
  let mut vec = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::new<u32, 3: u32> as λ() -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>)();
  («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::push<u32, 3: u32> as λ(& «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>, u32) -> Unit)((#_ref returning & «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>)(vec), (1: u32));
  («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::extend_from_slice<u32, 3: u32> as λ(& «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>, Slice<u32>) -> Unit)((#_ref returning & «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>)(vec), (#_mkSlice returning Slice<u32>)((2: u32), (3: u32), (4: u32)));
  #_skip
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::bounded_vec_tests::extend::extend_bounded_vec_beyond_max_len<>() -> Unit := {
  let mut vec = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::new<u32, 3: u32> as λ() -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>)();
  let other = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::from_array<u32, 5: u32> as λ(Array<u32, 5: u32>) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>)((#_mkArray returning Array<u32, 5: u32>)((1: u32), (2: u32), (3: u32), (4: u32), (5: u32)));
  («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::extend_from_bounded_vec<u32, 3: u32, 5: u32> as λ(& «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>, «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>) -> Unit)((#_ref returning & «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>)(vec), other);
  #_skip
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::bounded_vec_tests::extend::extend_with_empty_collections<>() -> Unit := {
  let mut vec = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::new<u32, 5: u32> as λ() -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>)();
  let original_len = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::len<u32, 5: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>) -> u32)(vec);
  («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::extend_from_array<u32, 5: u32, 0: u32> as λ(& «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>, Array<u32, 0: u32>) -> Unit)((#_ref returning & «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>)(vec), (#_mkArray returning Array<u32, 0: u32>)());
  (#_assert returning Unit)((#_uEq returning bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::len<u32, 5: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>) -> u32)(vec), original_len));
  («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::extend_from_slice<u32, 5: u32> as λ(& «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>, Slice<u32>) -> Unit)((#_ref returning & «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>)(vec), (#_mkSlice returning Slice<u32>)());
  (#_assert returning Unit)((#_uEq returning bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::len<u32, 5: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>) -> u32)(vec), original_len));
  let empty = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::new<u32, 3: u32> as λ() -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>)();
  («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::extend_from_bounded_vec<u32, 5: u32, 3: u32> as λ(& «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>, «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>) -> Unit)((#_ref returning & «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>)(vec), empty);
  (#_assert returning Unit)((#_uEq returning bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::len<u32, 5: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>) -> u32)(vec), original_len));
  #_skip
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::bounded_vec_tests::storage::storage_consistency<>() -> Unit := {
  let mut vec = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::new<u32, 5: u32> as λ() -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>)();
  (#_assert returning Unit)(((Array<u32, 5: u32> as «std-1.0.0-beta.12»::cmp::Eq<>)::eq<> as λ(Array<u32, 5: u32>, Array<u32, 5: u32>) -> bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::storage<u32, 5: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>) -> Array<u32, 5: u32>)(vec), (#_mkArray returning Array<u32, 5: u32>)((0: u32), (0: u32), (0: u32), (0: u32), (0: u32))));
  («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::push<u32, 5: u32> as λ(& «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>, u32) -> Unit)((#_ref returning & «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>)(vec), (1: u32));
  («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::push<u32, 5: u32> as λ(& «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>, u32) -> Unit)((#_ref returning & «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>)(vec), (2: u32));
  (#_assert returning Unit)(((Array<u32, 5: u32> as «std-1.0.0-beta.12»::cmp::Eq<>)::eq<> as λ(Array<u32, 5: u32>, Array<u32, 5: u32>) -> bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::storage<u32, 5: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>) -> Array<u32, 5: u32>)(vec), (#_mkArray returning Array<u32, 5: u32>)((1: u32), (2: u32), (0: u32), (0: u32), (0: u32))));
  (#_assert returning Unit)((#_uEq returning bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::len<u32, 5: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>) -> u32)(vec), (2: u32)));
  (#_assert returning Unit)((#_uEq returning bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::max_len<u32, 5: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 5: u32>) -> u32)(vec), (5: u32)));
  #_skip
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::bounded_vec_tests::storage::storage_after_pop<>() -> Unit := {
  let mut vec = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::from_array<u32, 3: u32> as λ(Array<u32, 3: u32>) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>)((#_mkArray returning Array<u32, 3: u32>)((1: u32), (2: u32), (3: u32)));
  let __0 = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::pop<u32, 3: u32> as λ(& «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>) -> u32)((#_ref returning & «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>)(vec));
  (#_assert returning Unit)(((Array<u32, 3: u32> as «std-1.0.0-beta.12»::cmp::Eq<>)::eq<> as λ(Array<u32, 3: u32>, Array<u32, 3: u32>) -> bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::storage<u32, 3: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>) -> Array<u32, 3: u32>)(vec), (#_mkArray returning Array<u32, 3: u32>)((1: u32), (2: u32), (0: u32))));
  (#_assert returning Unit)((#_uEq returning bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::len<u32, 3: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>) -> u32)(vec), (2: u32)));
  #_skip
}

noir_def «std-1.0.0-beta.12»::collections::bounded_vec::bounded_vec_tests::storage::vector_immutable<>() -> Unit := {
  let vec = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::from_array<u32, 3: u32> as λ(Array<u32, 3: u32>) -> «std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>)((#_mkArray returning Array<u32, 3: u32>)((1: u32), (2: u32), (3: u32)));
  let storage = («std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::storage<u32, 3: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>) -> Array<u32, 3: u32>)(vec);
  (#_assert returning Unit)(((Array<u32, 3: u32> as «std-1.0.0-beta.12»::cmp::Eq<>)::eq<> as λ(Array<u32, 3: u32>, Array<u32, 3: u32>) -> bool)(storage, (#_mkArray returning Array<u32, 3: u32>)((1: u32), (2: u32), (3: u32))));
  (#_assert returning Unit)((#_uEq returning bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::len<u32, 3: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>) -> u32)(vec), (3: u32)));
  (#_assert returning Unit)((#_uEq returning bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::get<u32, 3: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>, u32) -> u32)(vec, (0: u32)), (1: u32)));
  (#_assert returning Unit)((#_uEq returning bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::get<u32, 3: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>, u32) -> u32)(vec, (1: u32)), (2: u32)));
  (#_assert returning Unit)((#_uEq returning bool)((«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec::get<u32, 3: u32> as λ(«std-1.0.0-beta.12»::collections::bounded_vec::BoundedVec<u32, 3: u32>, u32) -> u32)(vec, (2: u32)), (3: u32)));
  #_skip
}

def «std-1.0.0-beta.12».Collections.BoundedVec.env : Env := Env.mk
  [«std-1.0.0-beta.12::collections::bounded_vec::BoundedVec::new», «std-1.0.0-beta.12::collections::bounded_vec::BoundedVec::get», «std-1.0.0-beta.12::collections::bounded_vec::BoundedVec::get_unchecked», «std-1.0.0-beta.12::collections::bounded_vec::BoundedVec::set», «std-1.0.0-beta.12::collections::bounded_vec::BoundedVec::set_unchecked», «std-1.0.0-beta.12::collections::bounded_vec::BoundedVec::push», «std-1.0.0-beta.12::collections::bounded_vec::BoundedVec::len», «std-1.0.0-beta.12::collections::bounded_vec::BoundedVec::max_len», «std-1.0.0-beta.12::collections::bounded_vec::BoundedVec::storage», «std-1.0.0-beta.12::collections::bounded_vec::BoundedVec::extend_from_array», «std-1.0.0-beta.12::collections::bounded_vec::BoundedVec::extend_from_slice», «std-1.0.0-beta.12::collections::bounded_vec::BoundedVec::extend_from_bounded_vec», «std-1.0.0-beta.12::collections::bounded_vec::BoundedVec::from_array», «std-1.0.0-beta.12::collections::bounded_vec::BoundedVec::pop», «std-1.0.0-beta.12::collections::bounded_vec::BoundedVec::any», «std-1.0.0-beta.12::collections::bounded_vec::BoundedVec::map», «std-1.0.0-beta.12::collections::bounded_vec::BoundedVec::mapi», «std-1.0.0-beta.12::collections::bounded_vec::BoundedVec::for_each», «std-1.0.0-beta.12::collections::bounded_vec::BoundedVec::for_eachi», «std-1.0.0-beta.12::collections::bounded_vec::BoundedVec::from_parts», «std-1.0.0-beta.12::collections::bounded_vec::BoundedVec::from_parts_unchecked», «std-1.0.0-beta.12::collections::bounded_vec::bounded_vec_tests::get::panics_when_reading_elements_past_end_of_vec», «std-1.0.0-beta.12::collections::bounded_vec::bounded_vec_tests::get::panics_when_reading_beyond_length», «std-1.0.0-beta.12::collections::bounded_vec::bounded_vec_tests::get::get_works_within_bounds», «std-1.0.0-beta.12::collections::bounded_vec::bounded_vec_tests::get::get_unchecked_works», «std-1.0.0-beta.12::collections::bounded_vec::bounded_vec_tests::get::get_unchecked_works_past_len», «std-1.0.0-beta.12::collections::bounded_vec::bounded_vec_tests::set::set_updates_values_properly», «std-1.0.0-beta.12::collections::bounded_vec::bounded_vec_tests::set::panics_when_writing_elements_past_end_of_vec», «std-1.0.0-beta.12::collections::bounded_vec::bounded_vec_tests::set::panics_when_setting_beyond_length», «std-1.0.0-beta.12::collections::bounded_vec::bounded_vec_tests::set::set_unchecked_operations», «std-1.0.0-beta.12::collections::bounded_vec::bounded_vec_tests::set::set_unchecked_operations_past_len», «std-1.0.0-beta.12::collections::bounded_vec::bounded_vec_tests::set::set_preserves_other_elements», «std-1.0.0-beta.12::collections::bounded_vec::bounded_vec_tests::any::returns_false_if_predicate_not_satisfied», «std-1.0.0-beta.12::collections::bounded_vec::bounded_vec_tests::any::returns_true_if_predicate_satisfied», «std-1.0.0-beta.12::collections::bounded_vec::bounded_vec_tests::any::returns_false_on_empty_boundedvec», «std-1.0.0-beta.12::collections::bounded_vec::bounded_vec_tests::any::any_with_complex_predicates», «std-1.0.0-beta.12::collections::bounded_vec::bounded_vec_tests::any::any_with_partial_vector», «std-1.0.0-beta.12::collections::bounded_vec::bounded_vec_tests::map::applies_function_correctly», «std-1.0.0-beta.12::collections::bounded_vec::bounded_vec_tests::map::applies_function_that_changes_return_type», «std-1.0.0-beta.12::collections::bounded_vec::bounded_vec_tests::map::does_not_apply_function_past_len», «std-1.0.0-beta.12::collections::bounded_vec::bounded_vec_tests::map::map_with_conditional_logic», «std-1.0.0-beta.12::collections::bounded_vec::bounded_vec_tests::map::map_preserves_length», «std-1.0.0-beta.12::collections::bounded_vec::bounded_vec_tests::map::map_on_empty_vector», «std-1.0.0-beta.12::collections::bounded_vec::bounded_vec_tests::mapi::applies_function_correctly», «std-1.0.0-beta.12::collections::bounded_vec::bounded_vec_tests::mapi::applies_function_that_changes_return_type», «std-1.0.0-beta.12::collections::bounded_vec::bounded_vec_tests::mapi::does_not_apply_function_past_len», «std-1.0.0-beta.12::collections::bounded_vec::bounded_vec_tests::mapi::mapi_with_index_branching_logic», «std-1.0.0-beta.12::collections::bounded_vec::bounded_vec_tests::for_each::for_each_map», «std-1.0.0-beta.12::collections::bounded_vec::bounded_vec_tests::for_each::smoke_test», «std-1.0.0-beta.12::collections::bounded_vec::bounded_vec_tests::for_each::applies_function_correctly», «std-1.0.0-beta.12::collections::bounded_vec::bounded_vec_tests::for_each::applies_function_that_changes_return_type», «std-1.0.0-beta.12::collections::bounded_vec::bounded_vec_tests::for_each::does_not_apply_function_past_len», «std-1.0.0-beta.12::collections::bounded_vec::bounded_vec_tests::for_each::for_each_on_empty_vector», «std-1.0.0-beta.12::collections::bounded_vec::bounded_vec_tests::for_each::for_each_with_side_effects», «std-1.0.0-beta.12::collections::bounded_vec::bounded_vec_tests::for_eachi::for_eachi_mapi», «std-1.0.0-beta.12::collections::bounded_vec::bounded_vec_tests::for_eachi::smoke_test», «std-1.0.0-beta.12::collections::bounded_vec::bounded_vec_tests::for_eachi::applies_function_correctly», «std-1.0.0-beta.12::collections::bounded_vec::bounded_vec_tests::for_eachi::applies_function_that_changes_return_type», «std-1.0.0-beta.12::collections::bounded_vec::bounded_vec_tests::for_eachi::does_not_apply_function_past_len», «std-1.0.0-beta.12::collections::bounded_vec::bounded_vec_tests::for_eachi::for_eachi_on_empty_vector», «std-1.0.0-beta.12::collections::bounded_vec::bounded_vec_tests::for_eachi::for_eachi_with_index_tracking», «std-1.0.0-beta.12::collections::bounded_vec::bounded_vec_tests::from_array::empty», «std-1.0.0-beta.12::collections::bounded_vec::bounded_vec_tests::from_array::equal_len», «std-1.0.0-beta.12::collections::bounded_vec::bounded_vec_tests::from_array::max_len_greater_then_array_len», «std-1.0.0-beta.12::collections::bounded_vec::bounded_vec_tests::from_array::max_len_lower_then_array_len», «std-1.0.0-beta.12::collections::bounded_vec::bounded_vec_tests::from_array::from_array_preserves_order», «std-1.0.0-beta.12::collections::bounded_vec::bounded_vec_tests::from_array::from_array_with_different_types», «std-1.0.0-beta.12::collections::bounded_vec::bounded_vec_tests::trait_from::simple», «std-1.0.0-beta.12::collections::bounded_vec::bounded_vec_tests::trait_eq::empty_equality», «std-1.0.0-beta.12::collections::bounded_vec::bounded_vec_tests::trait_eq::inequality», «std-1.0.0-beta.12::collections::bounded_vec::bounded_vec_tests::from_parts::from_parts», «std-1.0.0-beta.12::collections::bounded_vec::bounded_vec_tests::from_parts::from_parts_unchecked», «std-1.0.0-beta.12::collections::bounded_vec::bounded_vec_tests::push_pop::push_and_pop_operations», «std-1.0.0-beta.12::collections::bounded_vec::bounded_vec_tests::push_pop::push_to_full_vector», «std-1.0.0-beta.12::collections::bounded_vec::bounded_vec_tests::push_pop::pop_from_empty_vector», «std-1.0.0-beta.12::collections::bounded_vec::bounded_vec_tests::push_pop::push_pop_cycle», «std-1.0.0-beta.12::collections::bounded_vec::bounded_vec_tests::extend::extend_from_array», «std-1.0.0-beta.12::collections::bounded_vec::bounded_vec_tests::extend::extend_from_slice», «std-1.0.0-beta.12::collections::bounded_vec::bounded_vec_tests::extend::extend_from_bounded_vec», «std-1.0.0-beta.12::collections::bounded_vec::bounded_vec_tests::extend::extend_array_beyond_max_len», «std-1.0.0-beta.12::collections::bounded_vec::bounded_vec_tests::extend::extend_slice_beyond_max_len», «std-1.0.0-beta.12::collections::bounded_vec::bounded_vec_tests::extend::extend_bounded_vec_beyond_max_len», «std-1.0.0-beta.12::collections::bounded_vec::bounded_vec_tests::extend::extend_with_empty_collections», «std-1.0.0-beta.12::collections::bounded_vec::bounded_vec_tests::storage::storage_consistency», «std-1.0.0-beta.12::collections::bounded_vec::bounded_vec_tests::storage::storage_after_pop», «std-1.0.0-beta.12::collections::bounded_vec::bounded_vec_tests::storage::vector_immutable»]
  [impl_32, impl_33]
