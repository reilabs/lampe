-- Generated by lampe

import «std-1.0.0-beta.12».Extracted.GeneratedTypes
import Lampe

open Lampe

noir_def «std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurvePoint::double<>(self: «std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurvePoint<>) -> «std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurvePoint<> := {
  («std-1.0.0-beta.12»::embedded_curve_ops::embedded_curve_add<> as λ(«std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurvePoint<>, «std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurvePoint<>) -> «std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurvePoint<>)(self, self)
}

noir_def «std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurvePoint::point_at_infinity<>() -> «std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurvePoint<> := {
  (#_makeData returning «std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurvePoint<>)((0: Field), (0: Field), #_true)
}

noir_def «std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurvePoint::generator<>() -> «std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurvePoint<> := {
  (#_makeData returning «std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurvePoint<>)((1: Field), (17631683881184975370165255887551781615748388533673675138860: Field), #_false)
}

noir_trait_impl[«std-1.0.0-beta.12».impl_25]<> «std-1.0.0-beta.12»::ops::arith::Add<> for «std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurvePoint<> where [] := {
  noir_def add<>(self: «std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurvePoint<>, other: «std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurvePoint<>) -> «std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurvePoint<> := {
    («std-1.0.0-beta.12»::embedded_curve_ops::embedded_curve_add<> as λ(«std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurvePoint<>, «std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurvePoint<>) -> «std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurvePoint<>)(self, other)
  };
}

noir_trait_impl[«std-1.0.0-beta.12».impl_26]<> «std-1.0.0-beta.12»::ops::arith::Sub<> for «std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurvePoint<> where [] := {
  noir_def sub<>(self: «std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurvePoint<>, other: «std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurvePoint<>) -> «std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurvePoint<> := {
    ((«std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurvePoint<> as «std-1.0.0-beta.12»::ops::arith::Add<>)::add<> as λ(«std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurvePoint<>, «std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurvePoint<>) -> «std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurvePoint<>)(self, ((«std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurvePoint<> as «std-1.0.0-beta.12»::ops::arith::Neg<>)::neg<> as λ(«std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurvePoint<>) -> «std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurvePoint<>)(other))
  };
}

noir_trait_impl[«std-1.0.0-beta.12».impl_27]<> «std-1.0.0-beta.12»::ops::arith::Neg<> for «std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurvePoint<> where [] := {
  noir_def neg<>(self: «std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurvePoint<>) -> «std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurvePoint<> := {
    (#_makeData returning «std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurvePoint<>)(self.0, (#_fNeg returning Field)(self.1), self.2)
  };
}

noir_trait_impl[«std-1.0.0-beta.12».impl_28]<> «std-1.0.0-beta.12»::cmp::Eq<> for «std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurvePoint<> where [] := {
  noir_def eq<>(self: «std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurvePoint<>, b: «std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurvePoint<>) -> bool := {
    (#_bOr returning bool)((#_bAnd returning bool)(self.2, b.2), (#_bAnd returning bool)((#_bAnd returning bool)((#_bEq returning bool)(self.2, b.2), (#_fEq returning bool)(self.0, b.0)), (#_fEq returning bool)(self.1, b.1)))
  };
}

noir_trait_impl[«std-1.0.0-beta.12».impl_29]<> «std-1.0.0-beta.12»::hash::Hash<> for «std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurvePoint<> where [] := {
  noir_def hash<H: Type>(self: «std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurvePoint<>, state: & H) -> Unit := {
    if self.2 then {
      ((bool as «std-1.0.0-beta.12»::hash::Hash<>)::hash<H> as λ(bool, & H) -> Unit)(self.2, state);
      #_skip
    } else {
      ((Field as «std-1.0.0-beta.12»::hash::Hash<>)::hash<H> as λ(Field, & H) -> Unit)(self.0, state);
      ((Field as «std-1.0.0-beta.12»::hash::Hash<>)::hash<H> as λ(Field, & H) -> Unit)(self.1, state);
      #_skip
    }
  };
}

noir_def «std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurveScalar::new<>(lo: Field, hi: Field) -> «std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurveScalar<> := {
  (#_makeData returning «std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurveScalar<>)(lo, hi)
}

noir_def «std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurveScalar::from_field<>(scalar: Field) -> «std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurveScalar<> := {
  let (a, b) = («std-1.0.0-beta.12»::field::bn254::decompose<> as λ(Field) -> Tuple<Field, Field>)(scalar);
  (#_makeData returning «std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurveScalar<>)(a, b)
}

noir_def «std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurveScalar::from_bytes<>(bytes: Array<u8, 64: u32>, offset: u32) -> «std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurveScalar<> := {
  let mut v = (1: Field);
  let mut lo = (#_cast returning Field)((0: Field));
  let mut hi = (#_cast returning Field)((0: Field));
  for i in (0: u32) .. (16: u32) do {
    lo = (#_fAdd returning Field)(lo, (#_fMul returning Field)((#_cast returning Field)((#_arrayIndex returning u8)(bytes, (#_cast returning u32)((#_uSub returning u32)((#_uAdd returning u32)(offset, (31: u32)), i)))), v));
    hi = (#_fAdd returning Field)(hi, (#_fMul returning Field)((#_cast returning Field)((#_arrayIndex returning u8)(bytes, (#_cast returning u32)((#_uSub returning u32)((#_uAdd returning u32)(offset, (15: u32)), i)))), v));
    v = (#_fMul returning Field)(v, (256: Field));
    #_skip
  };
  let sig_s = (#_makeData returning «std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurveScalar<>)(lo, hi);
  sig_s
}

noir_trait_impl[«std-1.0.0-beta.12».impl_30]<> «std-1.0.0-beta.12»::cmp::Eq<> for «std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurveScalar<> where [] := {
  noir_def eq<>(self: «std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurveScalar<>, other: «std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurveScalar<>) -> bool := {
    (#_bAnd returning bool)((#_fEq returning bool)(other.1, self.1), (#_fEq returning bool)(other.0, self.0))
  };
}

noir_trait_impl[«std-1.0.0-beta.12».impl_31]<> «std-1.0.0-beta.12»::hash::Hash<> for «std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurveScalar<> where [] := {
  noir_def hash<H: Type>(self: «std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurveScalar<>, state: & H) -> Unit := {
    ((Field as «std-1.0.0-beta.12»::hash::Hash<>)::hash<H> as λ(Field, & H) -> Unit)(self.1, state);
    ((Field as «std-1.0.0-beta.12»::hash::Hash<>)::hash<H> as λ(Field, & H) -> Unit)(self.0, state);
    #_skip
  };
}

noir_def «std-1.0.0-beta.12»::embedded_curve_ops::multi_scalar_mul<N: u32>(points: Array<«std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurvePoint<>, N: u32>, scalars: Array<«std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurveScalar<>, N: u32>) -> «std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurvePoint<> := {
  (#_arrayIndex returning «std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurvePoint<>)((#_multiScalarMul returning Array<«std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurvePoint<>, 1: u32>)(points, scalars), (0: u32))
}

noir_def «std-1.0.0-beta.12»::embedded_curve_ops::fixed_base_scalar_mul<>(scalar: «std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurveScalar<>) -> «std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurvePoint<> := {
  («std-1.0.0-beta.12»::embedded_curve_ops::multi_scalar_mul<1: u32> as λ(Array<«std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurvePoint<>, 1: u32>, Array<«std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurveScalar<>, 1: u32>) -> «std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurvePoint<>)((#_mkArray returning Array<«std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurvePoint<>, 1: u32>)((«std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurvePoint::generator<> as λ() -> «std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurvePoint<>)()), (#_mkArray returning Array<«std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurveScalar<>, 1: u32>)(scalar))
}

noir_def «std-1.0.0-beta.12»::embedded_curve_ops::embedded_curve_add<>(point1: «std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurvePoint<>, point2: «std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurvePoint<>) -> «std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurvePoint<> := {
  if (#_isUnconstrained returning bool)() then {
    if point1.2 then {
      point2
    } else if point2.2 then {
      point1
    } else {
      («std-1.0.0-beta.12»::embedded_curve_ops::embedded_curve_add_unsafe<> as λ(«std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurvePoint<>, «std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurvePoint<>) -> «std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurvePoint<>)(point1, point2)
    }
  } else {
    let x_coordinates_match = (#_fEq returning bool)(point1.0, point2.0);
    let y_coordinates_match = (#_fEq returning bool)(point1.1, point2.1);
    let double_predicate = (#_bAnd returning bool)(x_coordinates_match, y_coordinates_match);
    let infinity_predicate = (#_bAnd returning bool)(x_coordinates_match, (#_bNot returning bool)(y_coordinates_match));
    let point1_1 = (#_makeData returning «std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurvePoint<>)((#_fAdd returning Field)(point1.0, (#_cast returning Field)(x_coordinates_match)), point1.1, #_false);
    let point2_1 = (#_makeData returning «std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurvePoint<>)(point2.0, point2.1, #_false);
    let mut result = («std-1.0.0-beta.12»::embedded_curve_ops::embedded_curve_add_unsafe<> as λ(«std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurvePoint<>, «std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurvePoint<>) -> «std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurvePoint<>)(point1_1, point2_1);
    let double = («std-1.0.0-beta.12»::embedded_curve_ops::embedded_curve_add_unsafe<> as λ(«std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurvePoint<>, «std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurvePoint<>) -> «std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurvePoint<>)(point1, point1);
    result = if double_predicate then {
      double
    } else {
      result
    };
    if point1.2 then {
      result = point2;
      #_skip
    };
    if point2.2 then {
      result = point1;
      #_skip
    };
    let mut result_is_infinity = (#_bAnd returning bool)(infinity_predicate, (#_bAnd returning bool)((#_bNot returning bool)(point1.2), (#_bNot returning bool)(point2.2)));
    (result.2: bool) = (#_bOr returning bool)(result_is_infinity, (#_bAnd returning bool)(point1.2, point2.2));
    result
  }
}

noir_def «std-1.0.0-beta.12»::embedded_curve_ops::embedded_curve_add_not_nul<>(point1: «std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurvePoint<>, point2: «std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurvePoint<>) -> «std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurvePoint<> := {
  (#_assert returning Unit)((#_fNeq returning bool)(point1.0, point2.0));
  (#_assert returning Unit)((#_bNot returning bool)(point1.2));
  (#_assert returning Unit)((#_bNot returning bool)(point2.2));
  let point1_1 = (#_makeData returning «std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurvePoint<>)(point1.0, point1.1, #_false);
  let point2_1 = (#_makeData returning «std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurvePoint<>)(point2.0, point2.1, #_false);
  («std-1.0.0-beta.12»::embedded_curve_ops::embedded_curve_add_unsafe<> as λ(«std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurvePoint<>, «std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurvePoint<>) -> «std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurvePoint<>)(point1_1, point2_1)
}

noir_def «std-1.0.0-beta.12»::embedded_curve_ops::embedded_curve_add_unsafe<>(point1: «std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurvePoint<>, point2: «std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurvePoint<>) -> «std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurvePoint<> := {
  (#_arrayIndex returning «std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurvePoint<>)((#_embeddedCurveAdd returning Array<«std-1.0.0-beta.12»::embedded_curve_ops::EmbeddedCurvePoint<>, 1: u32>)(point1, point2), (0: u32))
}

def «std-1.0.0-beta.12».EmbeddedCurveOps.env : Env := Env.mk
  [«std-1.0.0-beta.12::embedded_curve_ops::EmbeddedCurvePoint::double», «std-1.0.0-beta.12::embedded_curve_ops::EmbeddedCurvePoint::point_at_infinity», «std-1.0.0-beta.12::embedded_curve_ops::EmbeddedCurvePoint::generator», «std-1.0.0-beta.12::embedded_curve_ops::EmbeddedCurveScalar::new», «std-1.0.0-beta.12::embedded_curve_ops::EmbeddedCurveScalar::from_field», «std-1.0.0-beta.12::embedded_curve_ops::EmbeddedCurveScalar::from_bytes», «std-1.0.0-beta.12::embedded_curve_ops::multi_scalar_mul», «std-1.0.0-beta.12::embedded_curve_ops::fixed_base_scalar_mul», «std-1.0.0-beta.12::embedded_curve_ops::embedded_curve_add», «std-1.0.0-beta.12::embedded_curve_ops::embedded_curve_add_not_nul», «std-1.0.0-beta.12::embedded_curve_ops::embedded_curve_add_unsafe»]
  [impl_25, impl_26, impl_27, impl_28, impl_29, impl_30, impl_31]
