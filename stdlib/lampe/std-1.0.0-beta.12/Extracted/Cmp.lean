-- Generated by lampe

import «std-1.0.0-beta.12».Extracted.GeneratedTypes
import Lampe

open Lampe

namespace «std-1.0.0-beta.12»
namespace Extracted

noir_trait_impl[impl_78]<> std::cmp::Eq<> for Field where [] := {
  noir_def eq<>(self: Field, other: Field) -> bool := {
    (#_fEq returning bool)(self, other)
  };
}

noir_trait_impl[impl_79]<> std::cmp::Eq<> for u128 where [] := {
  noir_def eq<>(self: u128, other: u128) -> bool := {
    (#_uEq returning bool)(self, other)
  };
}

noir_trait_impl[impl_80]<> std::cmp::Eq<> for u64 where [] := {
  noir_def eq<>(self: u64, other: u64) -> bool := {
    (#_uEq returning bool)(self, other)
  };
}

noir_trait_impl[impl_81]<> std::cmp::Eq<> for u32 where [] := {
  noir_def eq<>(self: u32, other: u32) -> bool := {
    (#_uEq returning bool)(self, other)
  };
}

noir_trait_impl[impl_82]<> std::cmp::Eq<> for u16 where [] := {
  noir_def eq<>(self: u16, other: u16) -> bool := {
    (#_uEq returning bool)(self, other)
  };
}

noir_trait_impl[impl_83]<> std::cmp::Eq<> for u8 where [] := {
  noir_def eq<>(self: u8, other: u8) -> bool := {
    (#_uEq returning bool)(self, other)
  };
}

noir_trait_impl[impl_84]<> std::cmp::Eq<> for u1 where [] := {
  noir_def eq<>(self: u1, other: u1) -> bool := {
    (#_uEq returning bool)(self, other)
  };
}

noir_trait_impl[impl_85]<> std::cmp::Eq<> for i8 where [] := {
  noir_def eq<>(self: i8, other: i8) -> bool := {
    (#_iEq returning bool)(self, other)
  };
}

noir_trait_impl[impl_86]<> std::cmp::Eq<> for i16 where [] := {
  noir_def eq<>(self: i16, other: i16) -> bool := {
    (#_iEq returning bool)(self, other)
  };
}

noir_trait_impl[impl_87]<> std::cmp::Eq<> for i32 where [] := {
  noir_def eq<>(self: i32, other: i32) -> bool := {
    (#_iEq returning bool)(self, other)
  };
}

noir_trait_impl[impl_88]<> std::cmp::Eq<> for i64 where [] := {
  noir_def eq<>(self: i64, other: i64) -> bool := {
    (#_iEq returning bool)(self, other)
  };
}

noir_trait_impl[impl_89]<> std::cmp::Eq<> for Unit where [] := {
  noir_def eq<>(_self: Unit, _other: Unit) -> bool := {
    #_true
  };
}

noir_trait_impl[impl_90]<> std::cmp::Eq<> for bool where [] := {
  noir_def eq<>(self: bool, other: bool) -> bool := {
    (#_bEq returning bool)(self, other)
  };
}

noir_trait_impl[impl_91]<N: u32, T: Type> std::cmp::Eq<> for Array<T, N: u32> where [T: std::cmp::Eq<>] := {
  noir_def eq<>(self: Array<T, N: u32>, other: Array<T, N: u32>) -> bool := {
    let mut result = #_true;
    for i in (0: u32) .. (#_arrayLen returning u32)(self) do {
      result = (#_bAnd returning bool)(result, ((T as std::cmp::Eq<>)::eq<> as λ(T, T) -> bool)((#_arrayIndex returning T)(self, (#_cast returning u32)(i)), (#_arrayIndex returning T)(other, (#_cast returning u32)(i))));
      #_skip
    };
    result
  };
}

noir_trait_impl[impl_92]<T: Type> std::cmp::Eq<> for Slice<T> where [T: std::cmp::Eq<>] := {
  noir_def eq<>(self: Slice<T>, other: Slice<T>) -> bool := {
    let mut result = (#_uEq returning bool)((#_arrayLen returning u32)(self), (#_arrayLen returning u32)(other));
    if result then {
      for i in (0: u32) .. (#_arrayLen returning u32)(self) do {
        result = (#_bAnd returning bool)(result, ((T as std::cmp::Eq<>)::eq<> as λ(T, T) -> bool)((#_sliceIndex returning T)(self, (#_cast returning u32)(i)), (#_sliceIndex returning T)(other, (#_cast returning u32)(i))));
        #_skip
      };
      #_skip
    };
    result
  };
}

noir_trait_impl[impl_93]<N: u32> std::cmp::Eq<> for String<N: u32> where [] := {
  noir_def eq<>(self: String<N: u32>, other: String<N: u32>) -> bool := {
    let self_bytes = (#_strAsBytes returning Array<u8, N: u32>)(self);
    let other_bytes = (#_strAsBytes returning Array<u8, N: u32>)(other);
    ((Array<u8, N: u32> as std::cmp::Eq<>)::eq<> as λ(Array<u8, N: u32>, Array<u8, N: u32>) -> bool)(self_bytes, other_bytes)
  };
}

noir_trait_impl[impl_94]<A: Type, B: Type> std::cmp::Eq<> for Tuple<A, B> where [A: std::cmp::Eq<>, B: std::cmp::Eq<>] := {
  noir_def eq<>(self: Tuple<A, B>, other: Tuple<A, B>) -> bool := {
    (#_bAnd returning bool)(((A as std::cmp::Eq<>)::eq<> as λ(A, A) -> bool)(self.0, other.0), ((B as std::cmp::Eq<>)::eq<> as λ(B, B) -> bool)(self.1, other.1))
  };
}

noir_trait_impl[impl_95]<A: Type, B: Type, C: Type> std::cmp::Eq<> for Tuple<A, B, C> where [A: std::cmp::Eq<>, B: std::cmp::Eq<>, C: std::cmp::Eq<>] := {
  noir_def eq<>(self: Tuple<A, B, C>, other: Tuple<A, B, C>) -> bool := {
    (#_bAnd returning bool)((#_bAnd returning bool)(((A as std::cmp::Eq<>)::eq<> as λ(A, A) -> bool)(self.0, other.0), ((B as std::cmp::Eq<>)::eq<> as λ(B, B) -> bool)(self.1, other.1)), ((C as std::cmp::Eq<>)::eq<> as λ(C, C) -> bool)(self.2, other.2))
  };
}

noir_trait_impl[impl_96]<A: Type, B: Type, C: Type, D: Type> std::cmp::Eq<> for Tuple<A, B, C, D> where [A: std::cmp::Eq<>, B: std::cmp::Eq<>, C: std::cmp::Eq<>, D: std::cmp::Eq<>] := {
  noir_def eq<>(self: Tuple<A, B, C, D>, other: Tuple<A, B, C, D>) -> bool := {
    (#_bAnd returning bool)((#_bAnd returning bool)((#_bAnd returning bool)(((A as std::cmp::Eq<>)::eq<> as λ(A, A) -> bool)(self.0, other.0), ((B as std::cmp::Eq<>)::eq<> as λ(B, B) -> bool)(self.1, other.1)), ((C as std::cmp::Eq<>)::eq<> as λ(C, C) -> bool)(self.2, other.2)), ((D as std::cmp::Eq<>)::eq<> as λ(D, D) -> bool)(self.3, other.3))
  };
}

noir_trait_impl[impl_97]<A: Type, B: Type, C: Type, D: Type, E: Type> std::cmp::Eq<> for Tuple<A, B, C, D, E> where [A: std::cmp::Eq<>, B: std::cmp::Eq<>, C: std::cmp::Eq<>, D: std::cmp::Eq<>, E: std::cmp::Eq<>] := {
  noir_def eq<>(self: Tuple<A, B, C, D, E>, other: Tuple<A, B, C, D, E>) -> bool := {
    (#_bAnd returning bool)((#_bAnd returning bool)((#_bAnd returning bool)((#_bAnd returning bool)(((A as std::cmp::Eq<>)::eq<> as λ(A, A) -> bool)(self.0, other.0), ((B as std::cmp::Eq<>)::eq<> as λ(B, B) -> bool)(self.1, other.1)), ((C as std::cmp::Eq<>)::eq<> as λ(C, C) -> bool)(self.2, other.2)), ((D as std::cmp::Eq<>)::eq<> as λ(D, D) -> bool)(self.3, other.3)), ((E as std::cmp::Eq<>)::eq<> as λ(E, E) -> bool)(self.4, other.4))
  };
}

noir_trait_impl[impl_98]<> std::cmp::Eq<> for std::cmp::Ordering<> where [] := {
  noir_def eq<>(self: std::cmp::Ordering<>, other: std::cmp::Ordering<>) -> bool := {
    (#_fEq returning bool)(self.0, other.0)
  };
}

noir_def std::cmp::Ordering::less<>() -> std::cmp::Ordering<> := {
  (#_makeData returning std::cmp::Ordering<>)((0: Field))
}

noir_def std::cmp::Ordering::equal<>() -> std::cmp::Ordering<> := {
  (#_makeData returning std::cmp::Ordering<>)((1: Field))
}

noir_def std::cmp::Ordering::greater<>() -> std::cmp::Ordering<> := {
  (#_makeData returning std::cmp::Ordering<>)((2: Field))
}

noir_trait_impl[impl_99]<> std::cmp::Ord<> for u128 where [] := {
  noir_def cmp<>(self: u128, other: u128) -> std::cmp::Ordering<> := {
    if (#_uLt returning bool)(self, other) then {
      (std::cmp::Ordering::less<> as λ() -> std::cmp::Ordering<>)()
    } else if (#_uGt returning bool)(self, other) then {
      (std::cmp::Ordering::greater<> as λ() -> std::cmp::Ordering<>)()
    } else {
      (std::cmp::Ordering::equal<> as λ() -> std::cmp::Ordering<>)()
    }
  };
}

noir_trait_impl[impl_100]<> std::cmp::Ord<> for u64 where [] := {
  noir_def cmp<>(self: u64, other: u64) -> std::cmp::Ordering<> := {
    if (#_uLt returning bool)(self, other) then {
      (std::cmp::Ordering::less<> as λ() -> std::cmp::Ordering<>)()
    } else if (#_uGt returning bool)(self, other) then {
      (std::cmp::Ordering::greater<> as λ() -> std::cmp::Ordering<>)()
    } else {
      (std::cmp::Ordering::equal<> as λ() -> std::cmp::Ordering<>)()
    }
  };
}

noir_trait_impl[impl_101]<> std::cmp::Ord<> for u32 where [] := {
  noir_def cmp<>(self: u32, other: u32) -> std::cmp::Ordering<> := {
    if (#_uLt returning bool)(self, other) then {
      (std::cmp::Ordering::less<> as λ() -> std::cmp::Ordering<>)()
    } else if (#_uGt returning bool)(self, other) then {
      (std::cmp::Ordering::greater<> as λ() -> std::cmp::Ordering<>)()
    } else {
      (std::cmp::Ordering::equal<> as λ() -> std::cmp::Ordering<>)()
    }
  };
}

noir_trait_impl[impl_102]<> std::cmp::Ord<> for u16 where [] := {
  noir_def cmp<>(self: u16, other: u16) -> std::cmp::Ordering<> := {
    if (#_uLt returning bool)(self, other) then {
      (std::cmp::Ordering::less<> as λ() -> std::cmp::Ordering<>)()
    } else if (#_uGt returning bool)(self, other) then {
      (std::cmp::Ordering::greater<> as λ() -> std::cmp::Ordering<>)()
    } else {
      (std::cmp::Ordering::equal<> as λ() -> std::cmp::Ordering<>)()
    }
  };
}

noir_trait_impl[impl_103]<> std::cmp::Ord<> for u8 where [] := {
  noir_def cmp<>(self: u8, other: u8) -> std::cmp::Ordering<> := {
    if (#_uLt returning bool)(self, other) then {
      (std::cmp::Ordering::less<> as λ() -> std::cmp::Ordering<>)()
    } else if (#_uGt returning bool)(self, other) then {
      (std::cmp::Ordering::greater<> as λ() -> std::cmp::Ordering<>)()
    } else {
      (std::cmp::Ordering::equal<> as λ() -> std::cmp::Ordering<>)()
    }
  };
}

noir_trait_impl[impl_104]<> std::cmp::Ord<> for i8 where [] := {
  noir_def cmp<>(self: i8, other: i8) -> std::cmp::Ordering<> := {
    if (#_iLt returning bool)(self, other) then {
      (std::cmp::Ordering::less<> as λ() -> std::cmp::Ordering<>)()
    } else if (#_iGt returning bool)(self, other) then {
      (std::cmp::Ordering::greater<> as λ() -> std::cmp::Ordering<>)()
    } else {
      (std::cmp::Ordering::equal<> as λ() -> std::cmp::Ordering<>)()
    }
  };
}

noir_trait_impl[impl_105]<> std::cmp::Ord<> for i16 where [] := {
  noir_def cmp<>(self: i16, other: i16) -> std::cmp::Ordering<> := {
    if (#_iLt returning bool)(self, other) then {
      (std::cmp::Ordering::less<> as λ() -> std::cmp::Ordering<>)()
    } else if (#_iGt returning bool)(self, other) then {
      (std::cmp::Ordering::greater<> as λ() -> std::cmp::Ordering<>)()
    } else {
      (std::cmp::Ordering::equal<> as λ() -> std::cmp::Ordering<>)()
    }
  };
}

noir_trait_impl[impl_106]<> std::cmp::Ord<> for i32 where [] := {
  noir_def cmp<>(self: i32, other: i32) -> std::cmp::Ordering<> := {
    if (#_iLt returning bool)(self, other) then {
      (std::cmp::Ordering::less<> as λ() -> std::cmp::Ordering<>)()
    } else if (#_iGt returning bool)(self, other) then {
      (std::cmp::Ordering::greater<> as λ() -> std::cmp::Ordering<>)()
    } else {
      (std::cmp::Ordering::equal<> as λ() -> std::cmp::Ordering<>)()
    }
  };
}

noir_trait_impl[impl_107]<> std::cmp::Ord<> for i64 where [] := {
  noir_def cmp<>(self: i64, other: i64) -> std::cmp::Ordering<> := {
    if (#_iLt returning bool)(self, other) then {
      (std::cmp::Ordering::less<> as λ() -> std::cmp::Ordering<>)()
    } else if (#_iGt returning bool)(self, other) then {
      (std::cmp::Ordering::greater<> as λ() -> std::cmp::Ordering<>)()
    } else {
      (std::cmp::Ordering::equal<> as λ() -> std::cmp::Ordering<>)()
    }
  };
}

noir_trait_impl[impl_108]<> std::cmp::Ord<> for Unit where [] := {
  noir_def cmp<>(_self: Unit, _other: Unit) -> std::cmp::Ordering<> := {
    (std::cmp::Ordering::equal<> as λ() -> std::cmp::Ordering<>)()
  };
}

noir_trait_impl[impl_109]<> std::cmp::Ord<> for bool where [] := {
  noir_def cmp<>(self: bool, other: bool) -> std::cmp::Ordering<> := {
    if self then {
      if other then {
        (std::cmp::Ordering::equal<> as λ() -> std::cmp::Ordering<>)()
      } else {
        (std::cmp::Ordering::greater<> as λ() -> std::cmp::Ordering<>)()
      }
    } else if other then {
      (std::cmp::Ordering::less<> as λ() -> std::cmp::Ordering<>)()
    } else {
      (std::cmp::Ordering::equal<> as λ() -> std::cmp::Ordering<>)()
    }
  };
}

noir_trait_impl[impl_110]<N: u32, T: Type> std::cmp::Ord<> for Array<T, N: u32> where [T: std::cmp::Ord<>] := {
  noir_def cmp<>(self: Array<T, N: u32>, other: Array<T, N: u32>) -> std::cmp::Ordering<> := {
    let mut result = (std::cmp::Ordering::equal<> as λ() -> std::cmp::Ordering<>)();
    for i in (0: u32) .. (#_arrayLen returning u32)(self) do {
      if ((std::cmp::Ordering<> as std::cmp::Eq<>)::eq<> as λ(std::cmp::Ordering<>, std::cmp::Ordering<>) -> bool)(result, (std::cmp::Ordering::equal<> as λ() -> std::cmp::Ordering<>)()) then {
        result = ((T as std::cmp::Ord<>)::cmp<> as λ(T, T) -> std::cmp::Ordering<>)((#_arrayIndex returning T)(self, (#_cast returning u32)(i)), (#_arrayIndex returning T)(other, (#_cast returning u32)(i)));
        #_skip
      }
    };
    result
  };
}

noir_trait_impl[impl_111]<T: Type> std::cmp::Ord<> for Slice<T> where [T: std::cmp::Ord<>] := {
  noir_def cmp<>(self: Slice<T>, other: Slice<T>) -> std::cmp::Ordering<> := {
    let self_len = (#_arrayLen returning u32)(self);
    let other_len = (#_arrayLen returning u32)(other);
    let min_len = if (#_uLt returning bool)(self_len, other_len) then {
      self_len
    } else {
      other_len
    };
    let mut result = (std::cmp::Ordering::equal<> as λ() -> std::cmp::Ordering<>)();
    for i in (0: u32) .. min_len do {
      if ((std::cmp::Ordering<> as std::cmp::Eq<>)::eq<> as λ(std::cmp::Ordering<>, std::cmp::Ordering<>) -> bool)(result, (std::cmp::Ordering::equal<> as λ() -> std::cmp::Ordering<>)()) then {
        result = ((T as std::cmp::Ord<>)::cmp<> as λ(T, T) -> std::cmp::Ordering<>)((#_sliceIndex returning T)(self, (#_cast returning u32)(i)), (#_sliceIndex returning T)(other, (#_cast returning u32)(i)));
        #_skip
      }
    };
    if ((std::cmp::Ordering<> as std::cmp::Eq<>)::eq<> as λ(std::cmp::Ordering<>, std::cmp::Ordering<>) -> bool)(result, (std::cmp::Ordering::equal<> as λ() -> std::cmp::Ordering<>)()) then {
      result
    } else {
      ((u32 as std::cmp::Ord<>)::cmp<> as λ(u32, u32) -> std::cmp::Ordering<>)(self_len, other_len)
    }
  };
}

noir_trait_impl[impl_112]<A: Type, B: Type> std::cmp::Ord<> for Tuple<A, B> where [A: std::cmp::Ord<>, B: std::cmp::Ord<>] := {
  noir_def cmp<>(self: Tuple<A, B>, other: Tuple<A, B>) -> std::cmp::Ordering<> := {
    let result = ((A as std::cmp::Ord<>)::cmp<> as λ(A, A) -> std::cmp::Ordering<>)(self.0, other.0);
    if ((std::cmp::Ordering<> as std::cmp::Eq<>)::eq<> as λ(std::cmp::Ordering<>, std::cmp::Ordering<>) -> bool)(result, (std::cmp::Ordering::equal<> as λ() -> std::cmp::Ordering<>)()) then {
      result
    } else {
      ((B as std::cmp::Ord<>)::cmp<> as λ(B, B) -> std::cmp::Ordering<>)(self.1, other.1)
    }
  };
}

noir_trait_impl[impl_113]<A: Type, B: Type, C: Type> std::cmp::Ord<> for Tuple<A, B, C> where [A: std::cmp::Ord<>, B: std::cmp::Ord<>, C: std::cmp::Ord<>] := {
  noir_def cmp<>(self: Tuple<A, B, C>, other: Tuple<A, B, C>) -> std::cmp::Ordering<> := {
    let mut result = ((A as std::cmp::Ord<>)::cmp<> as λ(A, A) -> std::cmp::Ordering<>)(self.0, other.0);
    if ((std::cmp::Ordering<> as std::cmp::Eq<>)::eq<> as λ(std::cmp::Ordering<>, std::cmp::Ordering<>) -> bool)(result, (std::cmp::Ordering::equal<> as λ() -> std::cmp::Ordering<>)()) then {
      result = ((B as std::cmp::Ord<>)::cmp<> as λ(B, B) -> std::cmp::Ordering<>)(self.1, other.1);
      #_skip
    };
    if ((std::cmp::Ordering<> as std::cmp::Eq<>)::eq<> as λ(std::cmp::Ordering<>, std::cmp::Ordering<>) -> bool)(result, (std::cmp::Ordering::equal<> as λ() -> std::cmp::Ordering<>)()) then {
      result = ((C as std::cmp::Ord<>)::cmp<> as λ(C, C) -> std::cmp::Ordering<>)(self.2, other.2);
      #_skip
    };
    result
  };
}

noir_trait_impl[impl_114]<A: Type, B: Type, C: Type, D: Type> std::cmp::Ord<> for Tuple<A, B, C, D> where [A: std::cmp::Ord<>, B: std::cmp::Ord<>, C: std::cmp::Ord<>, D: std::cmp::Ord<>] := {
  noir_def cmp<>(self: Tuple<A, B, C, D>, other: Tuple<A, B, C, D>) -> std::cmp::Ordering<> := {
    let mut result = ((A as std::cmp::Ord<>)::cmp<> as λ(A, A) -> std::cmp::Ordering<>)(self.0, other.0);
    if ((std::cmp::Ordering<> as std::cmp::Eq<>)::eq<> as λ(std::cmp::Ordering<>, std::cmp::Ordering<>) -> bool)(result, (std::cmp::Ordering::equal<> as λ() -> std::cmp::Ordering<>)()) then {
      result = ((B as std::cmp::Ord<>)::cmp<> as λ(B, B) -> std::cmp::Ordering<>)(self.1, other.1);
      #_skip
    };
    if ((std::cmp::Ordering<> as std::cmp::Eq<>)::eq<> as λ(std::cmp::Ordering<>, std::cmp::Ordering<>) -> bool)(result, (std::cmp::Ordering::equal<> as λ() -> std::cmp::Ordering<>)()) then {
      result = ((C as std::cmp::Ord<>)::cmp<> as λ(C, C) -> std::cmp::Ordering<>)(self.2, other.2);
      #_skip
    };
    if ((std::cmp::Ordering<> as std::cmp::Eq<>)::eq<> as λ(std::cmp::Ordering<>, std::cmp::Ordering<>) -> bool)(result, (std::cmp::Ordering::equal<> as λ() -> std::cmp::Ordering<>)()) then {
      result = ((D as std::cmp::Ord<>)::cmp<> as λ(D, D) -> std::cmp::Ordering<>)(self.3, other.3);
      #_skip
    };
    result
  };
}

noir_trait_impl[impl_115]<A: Type, B: Type, C: Type, D: Type, E: Type> std::cmp::Ord<> for Tuple<A, B, C, D, E> where [A: std::cmp::Ord<>, B: std::cmp::Ord<>, C: std::cmp::Ord<>, D: std::cmp::Ord<>, E: std::cmp::Ord<>] := {
  noir_def cmp<>(self: Tuple<A, B, C, D, E>, other: Tuple<A, B, C, D, E>) -> std::cmp::Ordering<> := {
    let mut result = ((A as std::cmp::Ord<>)::cmp<> as λ(A, A) -> std::cmp::Ordering<>)(self.0, other.0);
    if ((std::cmp::Ordering<> as std::cmp::Eq<>)::eq<> as λ(std::cmp::Ordering<>, std::cmp::Ordering<>) -> bool)(result, (std::cmp::Ordering::equal<> as λ() -> std::cmp::Ordering<>)()) then {
      result = ((B as std::cmp::Ord<>)::cmp<> as λ(B, B) -> std::cmp::Ordering<>)(self.1, other.1);
      #_skip
    };
    if ((std::cmp::Ordering<> as std::cmp::Eq<>)::eq<> as λ(std::cmp::Ordering<>, std::cmp::Ordering<>) -> bool)(result, (std::cmp::Ordering::equal<> as λ() -> std::cmp::Ordering<>)()) then {
      result = ((C as std::cmp::Ord<>)::cmp<> as λ(C, C) -> std::cmp::Ordering<>)(self.2, other.2);
      #_skip
    };
    if ((std::cmp::Ordering<> as std::cmp::Eq<>)::eq<> as λ(std::cmp::Ordering<>, std::cmp::Ordering<>) -> bool)(result, (std::cmp::Ordering::equal<> as λ() -> std::cmp::Ordering<>)()) then {
      result = ((D as std::cmp::Ord<>)::cmp<> as λ(D, D) -> std::cmp::Ordering<>)(self.3, other.3);
      #_skip
    };
    if ((std::cmp::Ordering<> as std::cmp::Eq<>)::eq<> as λ(std::cmp::Ordering<>, std::cmp::Ordering<>) -> bool)(result, (std::cmp::Ordering::equal<> as λ() -> std::cmp::Ordering<>)()) then {
      result = ((E as std::cmp::Ord<>)::cmp<> as λ(E, E) -> std::cmp::Ordering<>)(self.4, other.4);
      #_skip
    };
    result
  };
}

noir_def std::cmp::max<T: Type>(v1: T, v2: T) -> T := {
  if ((T as std::cmp::Ord<>)::cmp<> as λ(T, T) -> bool)(v1, v2) then {
    v1
  } else {
    v2
  }
}

noir_def std::cmp::min<T: Type>(v1: T, v2: T) -> T := {
  if ((T as std::cmp::Ord<>)::cmp<> as λ(T, T) -> bool)(v1, v2) then {
    v2
  } else {
    v1
  }
}

noir_def std::cmp::cmp_tests::sanity_check_min<>() -> Unit := {
  (#_assert returning Unit)((#_uEq returning bool)((std::cmp::min<u64> as λ(u64, u64) -> u64)((0: u64), (1: u64)), (0: u64)));
  (#_assert returning Unit)((#_uEq returning bool)((std::cmp::min<u64> as λ(u64, u64) -> u64)((0: u64), (0: u64)), (0: u64)));
  (#_assert returning Unit)((#_uEq returning bool)((std::cmp::min<u64> as λ(u64, u64) -> u64)((1: u64), (1: u64)), (1: u64)));
  (#_assert returning Unit)((#_uEq returning bool)((std::cmp::min<u8> as λ(u8, u8) -> u8)((255: u8), (0: u8)), (0: u8)));
  #_skip
}

noir_def std::cmp::cmp_tests::sanity_check_max<>() -> Unit := {
  (#_assert returning Unit)((#_uEq returning bool)((std::cmp::max<u64> as λ(u64, u64) -> u64)((0: u64), (1: u64)), (1: u64)));
  (#_assert returning Unit)((#_uEq returning bool)((std::cmp::max<u64> as λ(u64, u64) -> u64)((0: u64), (0: u64)), (0: u64)));
  (#_assert returning Unit)((#_uEq returning bool)((std::cmp::max<u64> as λ(u64, u64) -> u64)((1: u64), (1: u64)), (1: u64)));
  (#_assert returning Unit)((#_uEq returning bool)((std::cmp::max<u8> as λ(u8, u8) -> u8)((255: u8), (0: u8)), (255: u8)));
  #_skip
}

noir_def std::cmp::cmp_tests::correctly_handles_unequal_length_slices<>() -> Unit := {
  let slice_1 = (#_mkSlice returning Slice<Field>)((0: Field), (1: Field), (2: Field), (3: Field));
  let slice_2 = (#_mkSlice returning Slice<Field>)((0: Field), (1: Field), (2: Field));
  (#_assert returning Unit)((#_bNot returning bool)(((Slice<Field> as std::cmp::Eq<>)::eq<> as λ(Slice<Field>, Slice<Field>) -> bool)(slice_1, slice_2)));
  #_skip
}

noir_def std::cmp::cmp_tests::lexicographic_ordering_for_slices<>() -> Unit := {
  (#_assert returning Unit)(((std::cmp::Ordering<> as std::cmp::Eq<>)::eq<> as λ(std::cmp::Ordering<>, std::cmp::Ordering<>) -> bool)(((Slice<u32> as std::cmp::Ord<>)::cmp<> as λ(Slice<u32>, Slice<u32>) -> std::cmp::Ordering<>)((#_mkSlice returning Slice<u32>)((2: u32)), (#_mkSlice returning Slice<u32>)((1: u32), (1: u32), (1: u32))), (std::cmp::Ordering::greater<> as λ() -> std::cmp::Ordering<>)()));
  (#_assert returning Unit)(((std::cmp::Ordering<> as std::cmp::Eq<>)::eq<> as λ(std::cmp::Ordering<>, std::cmp::Ordering<>) -> bool)(((Slice<u32> as std::cmp::Ord<>)::cmp<> as λ(Slice<u32>, Slice<u32>) -> std::cmp::Ordering<>)((#_mkSlice returning Slice<u32>)((1: u32), (2: u32)), (#_mkSlice returning Slice<u32>)((1: u32), (2: u32), (3: u32))), (std::cmp::Ordering::less<> as λ() -> std::cmp::Ordering<>)()));
  #_skip
}

def Cmp.env : Env := Env.mk
  [«std::cmp::Ordering::less», «std::cmp::Ordering::equal», «std::cmp::Ordering::greater», «std::cmp::max», «std::cmp::min», «std::cmp::cmp_tests::sanity_check_min», «std::cmp::cmp_tests::sanity_check_max», «std::cmp::cmp_tests::correctly_handles_unequal_length_slices», «std::cmp::cmp_tests::lexicographic_ordering_for_slices»]
  [impl_78, impl_79, impl_80, impl_81, impl_82, impl_83, impl_84, impl_85, impl_86, impl_87, impl_88, impl_89, impl_90, impl_91, impl_92, impl_93, impl_94, impl_95, impl_96, impl_97, impl_98, impl_99, impl_100, impl_101, impl_102, impl_103, impl_104, impl_105, impl_106, impl_107, impl_108, impl_109, impl_110, impl_111, impl_112, impl_113, impl_114, impl_115]
