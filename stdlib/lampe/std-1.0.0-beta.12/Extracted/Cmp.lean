-- Generated by lampe

import «std-1.0.0-beta.12».Extracted.GeneratedTypes
import Lampe

open Lampe

noir_trait_impl[«std-1.0.0-beta.12».impl_78]<> «std-1.0.0-beta.12»::cmp::Eq<> for Field where [] := {
  noir_def eq<>(self: Field, other: Field) -> bool := {
    (#_fEq returning bool)(self, other)
  };
}

noir_trait_impl[«std-1.0.0-beta.12».impl_79]<> «std-1.0.0-beta.12»::cmp::Eq<> for u128 where [] := {
  noir_def eq<>(self: u128, other: u128) -> bool := {
    (#_uEq returning bool)(self, other)
  };
}

noir_trait_impl[«std-1.0.0-beta.12».impl_80]<> «std-1.0.0-beta.12»::cmp::Eq<> for u64 where [] := {
  noir_def eq<>(self: u64, other: u64) -> bool := {
    (#_uEq returning bool)(self, other)
  };
}

noir_trait_impl[«std-1.0.0-beta.12».impl_81]<> «std-1.0.0-beta.12»::cmp::Eq<> for u32 where [] := {
  noir_def eq<>(self: u32, other: u32) -> bool := {
    (#_uEq returning bool)(self, other)
  };
}

noir_trait_impl[«std-1.0.0-beta.12».impl_82]<> «std-1.0.0-beta.12»::cmp::Eq<> for u16 where [] := {
  noir_def eq<>(self: u16, other: u16) -> bool := {
    (#_uEq returning bool)(self, other)
  };
}

noir_trait_impl[«std-1.0.0-beta.12».impl_83]<> «std-1.0.0-beta.12»::cmp::Eq<> for u8 where [] := {
  noir_def eq<>(self: u8, other: u8) -> bool := {
    (#_uEq returning bool)(self, other)
  };
}

noir_trait_impl[«std-1.0.0-beta.12».impl_84]<> «std-1.0.0-beta.12»::cmp::Eq<> for u1 where [] := {
  noir_def eq<>(self: u1, other: u1) -> bool := {
    (#_uEq returning bool)(self, other)
  };
}

noir_trait_impl[«std-1.0.0-beta.12».impl_85]<> «std-1.0.0-beta.12»::cmp::Eq<> for i8 where [] := {
  noir_def eq<>(self: i8, other: i8) -> bool := {
    (#_iEq returning bool)(self, other)
  };
}

noir_trait_impl[«std-1.0.0-beta.12».impl_86]<> «std-1.0.0-beta.12»::cmp::Eq<> for i16 where [] := {
  noir_def eq<>(self: i16, other: i16) -> bool := {
    (#_iEq returning bool)(self, other)
  };
}

noir_trait_impl[«std-1.0.0-beta.12».impl_87]<> «std-1.0.0-beta.12»::cmp::Eq<> for i32 where [] := {
  noir_def eq<>(self: i32, other: i32) -> bool := {
    (#_iEq returning bool)(self, other)
  };
}

noir_trait_impl[«std-1.0.0-beta.12».impl_88]<> «std-1.0.0-beta.12»::cmp::Eq<> for i64 where [] := {
  noir_def eq<>(self: i64, other: i64) -> bool := {
    (#_iEq returning bool)(self, other)
  };
}

noir_trait_impl[«std-1.0.0-beta.12».impl_89]<> «std-1.0.0-beta.12»::cmp::Eq<> for Unit where [] := {
  noir_def eq<>(_self: Unit, _other: Unit) -> bool := {
    #_true
  };
}

noir_trait_impl[«std-1.0.0-beta.12».impl_90]<> «std-1.0.0-beta.12»::cmp::Eq<> for bool where [] := {
  noir_def eq<>(self: bool, other: bool) -> bool := {
    (#_bEq returning bool)(self, other)
  };
}

noir_trait_impl[«std-1.0.0-beta.12».impl_91]<N: u32, T: Type> «std-1.0.0-beta.12»::cmp::Eq<> for Array<T, N: u32> where [T: «std-1.0.0-beta.12»::cmp::Eq<>] := {
  noir_def eq<>(self: Array<T, N: u32>, other: Array<T, N: u32>) -> bool := {
    let mut result = #_true;
    for i in (0: u32) .. (#_arrayLen returning u32)(self) do {
      result = (#_bAnd returning bool)(result, ((T as «std-1.0.0-beta.12»::cmp::Eq<>)::eq<> as λ(T, T) -> bool)((#_arrayIndex returning T)(self, (#_cast returning u32)(i)), (#_arrayIndex returning T)(other, (#_cast returning u32)(i))));
      #_skip
    };
    result
  };
}

noir_trait_impl[«std-1.0.0-beta.12».impl_92]<T: Type> «std-1.0.0-beta.12»::cmp::Eq<> for Slice<T> where [T: «std-1.0.0-beta.12»::cmp::Eq<>] := {
  noir_def eq<>(self: Slice<T>, other: Slice<T>) -> bool := {
    let mut result = (#_uEq returning bool)((#_arrayLen returning u32)(self), (#_arrayLen returning u32)(other));
    if result then {
      for i in (0: u32) .. (#_arrayLen returning u32)(self) do {
        result = (#_bAnd returning bool)(result, ((T as «std-1.0.0-beta.12»::cmp::Eq<>)::eq<> as λ(T, T) -> bool)((#_sliceIndex returning T)(self, (#_cast returning u32)(i)), (#_sliceIndex returning T)(other, (#_cast returning u32)(i))));
        #_skip
      };
      #_skip
    };
    result
  };
}

noir_trait_impl[«std-1.0.0-beta.12».impl_93]<N: u32> «std-1.0.0-beta.12»::cmp::Eq<> for String<N: u32> where [] := {
  noir_def eq<>(self: String<N: u32>, other: String<N: u32>) -> bool := {
    let self_bytes = (#_strAsBytes returning Array<u8, N: u32>)(self);
    let other_bytes = (#_strAsBytes returning Array<u8, N: u32>)(other);
    ((Array<u8, N: u32> as «std-1.0.0-beta.12»::cmp::Eq<>)::eq<> as λ(Array<u8, N: u32>, Array<u8, N: u32>) -> bool)(self_bytes, other_bytes)
  };
}

noir_trait_impl[«std-1.0.0-beta.12».impl_94]<A: Type, B: Type> «std-1.0.0-beta.12»::cmp::Eq<> for Tuple<A, B> where [A: «std-1.0.0-beta.12»::cmp::Eq<>, B: «std-1.0.0-beta.12»::cmp::Eq<>] := {
  noir_def eq<>(self: Tuple<A, B>, other: Tuple<A, B>) -> bool := {
    (#_bAnd returning bool)(((A as «std-1.0.0-beta.12»::cmp::Eq<>)::eq<> as λ(A, A) -> bool)(self.0, other.0), ((B as «std-1.0.0-beta.12»::cmp::Eq<>)::eq<> as λ(B, B) -> bool)(self.1, other.1))
  };
}

noir_trait_impl[«std-1.0.0-beta.12».impl_95]<A: Type, B: Type, C: Type> «std-1.0.0-beta.12»::cmp::Eq<> for Tuple<A, B, C> where [A: «std-1.0.0-beta.12»::cmp::Eq<>, B: «std-1.0.0-beta.12»::cmp::Eq<>, C: «std-1.0.0-beta.12»::cmp::Eq<>] := {
  noir_def eq<>(self: Tuple<A, B, C>, other: Tuple<A, B, C>) -> bool := {
    (#_bAnd returning bool)((#_bAnd returning bool)(((A as «std-1.0.0-beta.12»::cmp::Eq<>)::eq<> as λ(A, A) -> bool)(self.0, other.0), ((B as «std-1.0.0-beta.12»::cmp::Eq<>)::eq<> as λ(B, B) -> bool)(self.1, other.1)), ((C as «std-1.0.0-beta.12»::cmp::Eq<>)::eq<> as λ(C, C) -> bool)(self.2, other.2))
  };
}

noir_trait_impl[«std-1.0.0-beta.12».impl_96]<A: Type, B: Type, C: Type, D: Type> «std-1.0.0-beta.12»::cmp::Eq<> for Tuple<A, B, C, D> where [A: «std-1.0.0-beta.12»::cmp::Eq<>, B: «std-1.0.0-beta.12»::cmp::Eq<>, C: «std-1.0.0-beta.12»::cmp::Eq<>, D: «std-1.0.0-beta.12»::cmp::Eq<>] := {
  noir_def eq<>(self: Tuple<A, B, C, D>, other: Tuple<A, B, C, D>) -> bool := {
    (#_bAnd returning bool)((#_bAnd returning bool)((#_bAnd returning bool)(((A as «std-1.0.0-beta.12»::cmp::Eq<>)::eq<> as λ(A, A) -> bool)(self.0, other.0), ((B as «std-1.0.0-beta.12»::cmp::Eq<>)::eq<> as λ(B, B) -> bool)(self.1, other.1)), ((C as «std-1.0.0-beta.12»::cmp::Eq<>)::eq<> as λ(C, C) -> bool)(self.2, other.2)), ((D as «std-1.0.0-beta.12»::cmp::Eq<>)::eq<> as λ(D, D) -> bool)(self.3, other.3))
  };
}

noir_trait_impl[«std-1.0.0-beta.12».impl_97]<A: Type, B: Type, C: Type, D: Type, E: Type> «std-1.0.0-beta.12»::cmp::Eq<> for Tuple<A, B, C, D, E> where [A: «std-1.0.0-beta.12»::cmp::Eq<>, B: «std-1.0.0-beta.12»::cmp::Eq<>, C: «std-1.0.0-beta.12»::cmp::Eq<>, D: «std-1.0.0-beta.12»::cmp::Eq<>, E: «std-1.0.0-beta.12»::cmp::Eq<>] := {
  noir_def eq<>(self: Tuple<A, B, C, D, E>, other: Tuple<A, B, C, D, E>) -> bool := {
    (#_bAnd returning bool)((#_bAnd returning bool)((#_bAnd returning bool)((#_bAnd returning bool)(((A as «std-1.0.0-beta.12»::cmp::Eq<>)::eq<> as λ(A, A) -> bool)(self.0, other.0), ((B as «std-1.0.0-beta.12»::cmp::Eq<>)::eq<> as λ(B, B) -> bool)(self.1, other.1)), ((C as «std-1.0.0-beta.12»::cmp::Eq<>)::eq<> as λ(C, C) -> bool)(self.2, other.2)), ((D as «std-1.0.0-beta.12»::cmp::Eq<>)::eq<> as λ(D, D) -> bool)(self.3, other.3)), ((E as «std-1.0.0-beta.12»::cmp::Eq<>)::eq<> as λ(E, E) -> bool)(self.4, other.4))
  };
}

noir_trait_impl[«std-1.0.0-beta.12».impl_98]<> «std-1.0.0-beta.12»::cmp::Eq<> for «std-1.0.0-beta.12»::cmp::Ordering<> where [] := {
  noir_def eq<>(self: «std-1.0.0-beta.12»::cmp::Ordering<>, other: «std-1.0.0-beta.12»::cmp::Ordering<>) -> bool := {
    (#_fEq returning bool)(self.0, other.0)
  };
}

noir_def «std-1.0.0-beta.12»::cmp::Ordering::less<>() -> «std-1.0.0-beta.12»::cmp::Ordering<> := {
  (#_makeData returning «std-1.0.0-beta.12»::cmp::Ordering<>)((0: Field))
}

noir_def «std-1.0.0-beta.12»::cmp::Ordering::equal<>() -> «std-1.0.0-beta.12»::cmp::Ordering<> := {
  (#_makeData returning «std-1.0.0-beta.12»::cmp::Ordering<>)((1: Field))
}

noir_def «std-1.0.0-beta.12»::cmp::Ordering::greater<>() -> «std-1.0.0-beta.12»::cmp::Ordering<> := {
  (#_makeData returning «std-1.0.0-beta.12»::cmp::Ordering<>)((2: Field))
}

noir_trait_impl[«std-1.0.0-beta.12».impl_99]<> «std-1.0.0-beta.12»::cmp::Ord<> for u128 where [] := {
  noir_def cmp<>(self: u128, other: u128) -> «std-1.0.0-beta.12»::cmp::Ordering<> := {
    if (#_uLt returning bool)(self, other) then {
      («std-1.0.0-beta.12»::cmp::Ordering::less<> as λ() -> «std-1.0.0-beta.12»::cmp::Ordering<>)()
    } else if (#_uGt returning bool)(self, other) then {
      («std-1.0.0-beta.12»::cmp::Ordering::greater<> as λ() -> «std-1.0.0-beta.12»::cmp::Ordering<>)()
    } else {
      («std-1.0.0-beta.12»::cmp::Ordering::equal<> as λ() -> «std-1.0.0-beta.12»::cmp::Ordering<>)()
    }
  };
}

noir_trait_impl[«std-1.0.0-beta.12».impl_100]<> «std-1.0.0-beta.12»::cmp::Ord<> for u64 where [] := {
  noir_def cmp<>(self: u64, other: u64) -> «std-1.0.0-beta.12»::cmp::Ordering<> := {
    if (#_uLt returning bool)(self, other) then {
      («std-1.0.0-beta.12»::cmp::Ordering::less<> as λ() -> «std-1.0.0-beta.12»::cmp::Ordering<>)()
    } else if (#_uGt returning bool)(self, other) then {
      («std-1.0.0-beta.12»::cmp::Ordering::greater<> as λ() -> «std-1.0.0-beta.12»::cmp::Ordering<>)()
    } else {
      («std-1.0.0-beta.12»::cmp::Ordering::equal<> as λ() -> «std-1.0.0-beta.12»::cmp::Ordering<>)()
    }
  };
}

noir_trait_impl[«std-1.0.0-beta.12».impl_101]<> «std-1.0.0-beta.12»::cmp::Ord<> for u32 where [] := {
  noir_def cmp<>(self: u32, other: u32) -> «std-1.0.0-beta.12»::cmp::Ordering<> := {
    if (#_uLt returning bool)(self, other) then {
      («std-1.0.0-beta.12»::cmp::Ordering::less<> as λ() -> «std-1.0.0-beta.12»::cmp::Ordering<>)()
    } else if (#_uGt returning bool)(self, other) then {
      («std-1.0.0-beta.12»::cmp::Ordering::greater<> as λ() -> «std-1.0.0-beta.12»::cmp::Ordering<>)()
    } else {
      («std-1.0.0-beta.12»::cmp::Ordering::equal<> as λ() -> «std-1.0.0-beta.12»::cmp::Ordering<>)()
    }
  };
}

noir_trait_impl[«std-1.0.0-beta.12».impl_102]<> «std-1.0.0-beta.12»::cmp::Ord<> for u16 where [] := {
  noir_def cmp<>(self: u16, other: u16) -> «std-1.0.0-beta.12»::cmp::Ordering<> := {
    if (#_uLt returning bool)(self, other) then {
      («std-1.0.0-beta.12»::cmp::Ordering::less<> as λ() -> «std-1.0.0-beta.12»::cmp::Ordering<>)()
    } else if (#_uGt returning bool)(self, other) then {
      («std-1.0.0-beta.12»::cmp::Ordering::greater<> as λ() -> «std-1.0.0-beta.12»::cmp::Ordering<>)()
    } else {
      («std-1.0.0-beta.12»::cmp::Ordering::equal<> as λ() -> «std-1.0.0-beta.12»::cmp::Ordering<>)()
    }
  };
}

noir_trait_impl[«std-1.0.0-beta.12».impl_103]<> «std-1.0.0-beta.12»::cmp::Ord<> for u8 where [] := {
  noir_def cmp<>(self: u8, other: u8) -> «std-1.0.0-beta.12»::cmp::Ordering<> := {
    if (#_uLt returning bool)(self, other) then {
      («std-1.0.0-beta.12»::cmp::Ordering::less<> as λ() -> «std-1.0.0-beta.12»::cmp::Ordering<>)()
    } else if (#_uGt returning bool)(self, other) then {
      («std-1.0.0-beta.12»::cmp::Ordering::greater<> as λ() -> «std-1.0.0-beta.12»::cmp::Ordering<>)()
    } else {
      («std-1.0.0-beta.12»::cmp::Ordering::equal<> as λ() -> «std-1.0.0-beta.12»::cmp::Ordering<>)()
    }
  };
}

noir_trait_impl[«std-1.0.0-beta.12».impl_104]<> «std-1.0.0-beta.12»::cmp::Ord<> for i8 where [] := {
  noir_def cmp<>(self: i8, other: i8) -> «std-1.0.0-beta.12»::cmp::Ordering<> := {
    if (#_iLt returning bool)(self, other) then {
      («std-1.0.0-beta.12»::cmp::Ordering::less<> as λ() -> «std-1.0.0-beta.12»::cmp::Ordering<>)()
    } else if (#_iGt returning bool)(self, other) then {
      («std-1.0.0-beta.12»::cmp::Ordering::greater<> as λ() -> «std-1.0.0-beta.12»::cmp::Ordering<>)()
    } else {
      («std-1.0.0-beta.12»::cmp::Ordering::equal<> as λ() -> «std-1.0.0-beta.12»::cmp::Ordering<>)()
    }
  };
}

noir_trait_impl[«std-1.0.0-beta.12».impl_105]<> «std-1.0.0-beta.12»::cmp::Ord<> for i16 where [] := {
  noir_def cmp<>(self: i16, other: i16) -> «std-1.0.0-beta.12»::cmp::Ordering<> := {
    if (#_iLt returning bool)(self, other) then {
      («std-1.0.0-beta.12»::cmp::Ordering::less<> as λ() -> «std-1.0.0-beta.12»::cmp::Ordering<>)()
    } else if (#_iGt returning bool)(self, other) then {
      («std-1.0.0-beta.12»::cmp::Ordering::greater<> as λ() -> «std-1.0.0-beta.12»::cmp::Ordering<>)()
    } else {
      («std-1.0.0-beta.12»::cmp::Ordering::equal<> as λ() -> «std-1.0.0-beta.12»::cmp::Ordering<>)()
    }
  };
}

noir_trait_impl[«std-1.0.0-beta.12».impl_106]<> «std-1.0.0-beta.12»::cmp::Ord<> for i32 where [] := {
  noir_def cmp<>(self: i32, other: i32) -> «std-1.0.0-beta.12»::cmp::Ordering<> := {
    if (#_iLt returning bool)(self, other) then {
      («std-1.0.0-beta.12»::cmp::Ordering::less<> as λ() -> «std-1.0.0-beta.12»::cmp::Ordering<>)()
    } else if (#_iGt returning bool)(self, other) then {
      («std-1.0.0-beta.12»::cmp::Ordering::greater<> as λ() -> «std-1.0.0-beta.12»::cmp::Ordering<>)()
    } else {
      («std-1.0.0-beta.12»::cmp::Ordering::equal<> as λ() -> «std-1.0.0-beta.12»::cmp::Ordering<>)()
    }
  };
}

noir_trait_impl[«std-1.0.0-beta.12».impl_107]<> «std-1.0.0-beta.12»::cmp::Ord<> for i64 where [] := {
  noir_def cmp<>(self: i64, other: i64) -> «std-1.0.0-beta.12»::cmp::Ordering<> := {
    if (#_iLt returning bool)(self, other) then {
      («std-1.0.0-beta.12»::cmp::Ordering::less<> as λ() -> «std-1.0.0-beta.12»::cmp::Ordering<>)()
    } else if (#_iGt returning bool)(self, other) then {
      («std-1.0.0-beta.12»::cmp::Ordering::greater<> as λ() -> «std-1.0.0-beta.12»::cmp::Ordering<>)()
    } else {
      («std-1.0.0-beta.12»::cmp::Ordering::equal<> as λ() -> «std-1.0.0-beta.12»::cmp::Ordering<>)()
    }
  };
}

noir_trait_impl[«std-1.0.0-beta.12».impl_108]<> «std-1.0.0-beta.12»::cmp::Ord<> for Unit where [] := {
  noir_def cmp<>(_self: Unit, _other: Unit) -> «std-1.0.0-beta.12»::cmp::Ordering<> := {
    («std-1.0.0-beta.12»::cmp::Ordering::equal<> as λ() -> «std-1.0.0-beta.12»::cmp::Ordering<>)()
  };
}

noir_trait_impl[«std-1.0.0-beta.12».impl_109]<> «std-1.0.0-beta.12»::cmp::Ord<> for bool where [] := {
  noir_def cmp<>(self: bool, other: bool) -> «std-1.0.0-beta.12»::cmp::Ordering<> := {
    if self then {
      if other then {
        («std-1.0.0-beta.12»::cmp::Ordering::equal<> as λ() -> «std-1.0.0-beta.12»::cmp::Ordering<>)()
      } else {
        («std-1.0.0-beta.12»::cmp::Ordering::greater<> as λ() -> «std-1.0.0-beta.12»::cmp::Ordering<>)()
      }
    } else if other then {
      («std-1.0.0-beta.12»::cmp::Ordering::less<> as λ() -> «std-1.0.0-beta.12»::cmp::Ordering<>)()
    } else {
      («std-1.0.0-beta.12»::cmp::Ordering::equal<> as λ() -> «std-1.0.0-beta.12»::cmp::Ordering<>)()
    }
  };
}

noir_trait_impl[«std-1.0.0-beta.12».impl_110]<N: u32, T: Type> «std-1.0.0-beta.12»::cmp::Ord<> for Array<T, N: u32> where [T: «std-1.0.0-beta.12»::cmp::Ord<>] := {
  noir_def cmp<>(self: Array<T, N: u32>, other: Array<T, N: u32>) -> «std-1.0.0-beta.12»::cmp::Ordering<> := {
    let mut result = («std-1.0.0-beta.12»::cmp::Ordering::equal<> as λ() -> «std-1.0.0-beta.12»::cmp::Ordering<>)();
    for i in (0: u32) .. (#_arrayLen returning u32)(self) do {
      if ((«std-1.0.0-beta.12»::cmp::Ordering<> as «std-1.0.0-beta.12»::cmp::Eq<>)::eq<> as λ(«std-1.0.0-beta.12»::cmp::Ordering<>, «std-1.0.0-beta.12»::cmp::Ordering<>) -> bool)(result, («std-1.0.0-beta.12»::cmp::Ordering::equal<> as λ() -> «std-1.0.0-beta.12»::cmp::Ordering<>)()) then {
        result = ((T as «std-1.0.0-beta.12»::cmp::Ord<>)::cmp<> as λ(T, T) -> «std-1.0.0-beta.12»::cmp::Ordering<>)((#_arrayIndex returning T)(self, (#_cast returning u32)(i)), (#_arrayIndex returning T)(other, (#_cast returning u32)(i)));
        #_skip
      }
    };
    result
  };
}

noir_trait_impl[«std-1.0.0-beta.12».impl_111]<T: Type> «std-1.0.0-beta.12»::cmp::Ord<> for Slice<T> where [T: «std-1.0.0-beta.12»::cmp::Ord<>] := {
  noir_def cmp<>(self: Slice<T>, other: Slice<T>) -> «std-1.0.0-beta.12»::cmp::Ordering<> := {
    let self_len = (#_arrayLen returning u32)(self);
    let other_len = (#_arrayLen returning u32)(other);
    let min_len = if (#_uLt returning bool)(self_len, other_len) then {
      self_len
    } else {
      other_len
    };
    let mut result = («std-1.0.0-beta.12»::cmp::Ordering::equal<> as λ() -> «std-1.0.0-beta.12»::cmp::Ordering<>)();
    for i in (0: u32) .. min_len do {
      if ((«std-1.0.0-beta.12»::cmp::Ordering<> as «std-1.0.0-beta.12»::cmp::Eq<>)::eq<> as λ(«std-1.0.0-beta.12»::cmp::Ordering<>, «std-1.0.0-beta.12»::cmp::Ordering<>) -> bool)(result, («std-1.0.0-beta.12»::cmp::Ordering::equal<> as λ() -> «std-1.0.0-beta.12»::cmp::Ordering<>)()) then {
        result = ((T as «std-1.0.0-beta.12»::cmp::Ord<>)::cmp<> as λ(T, T) -> «std-1.0.0-beta.12»::cmp::Ordering<>)((#_sliceIndex returning T)(self, (#_cast returning u32)(i)), (#_sliceIndex returning T)(other, (#_cast returning u32)(i)));
        #_skip
      }
    };
    if ((«std-1.0.0-beta.12»::cmp::Ordering<> as «std-1.0.0-beta.12»::cmp::Eq<>)::eq<> as λ(«std-1.0.0-beta.12»::cmp::Ordering<>, «std-1.0.0-beta.12»::cmp::Ordering<>) -> bool)(result, («std-1.0.0-beta.12»::cmp::Ordering::equal<> as λ() -> «std-1.0.0-beta.12»::cmp::Ordering<>)()) then {
      result
    } else {
      ((u32 as «std-1.0.0-beta.12»::cmp::Ord<>)::cmp<> as λ(u32, u32) -> «std-1.0.0-beta.12»::cmp::Ordering<>)(self_len, other_len)
    }
  };
}

noir_trait_impl[«std-1.0.0-beta.12».impl_112]<A: Type, B: Type> «std-1.0.0-beta.12»::cmp::Ord<> for Tuple<A, B> where [A: «std-1.0.0-beta.12»::cmp::Ord<>, B: «std-1.0.0-beta.12»::cmp::Ord<>] := {
  noir_def cmp<>(self: Tuple<A, B>, other: Tuple<A, B>) -> «std-1.0.0-beta.12»::cmp::Ordering<> := {
    let result = ((A as «std-1.0.0-beta.12»::cmp::Ord<>)::cmp<> as λ(A, A) -> «std-1.0.0-beta.12»::cmp::Ordering<>)(self.0, other.0);
    if ((«std-1.0.0-beta.12»::cmp::Ordering<> as «std-1.0.0-beta.12»::cmp::Eq<>)::eq<> as λ(«std-1.0.0-beta.12»::cmp::Ordering<>, «std-1.0.0-beta.12»::cmp::Ordering<>) -> bool)(result, («std-1.0.0-beta.12»::cmp::Ordering::equal<> as λ() -> «std-1.0.0-beta.12»::cmp::Ordering<>)()) then {
      result
    } else {
      ((B as «std-1.0.0-beta.12»::cmp::Ord<>)::cmp<> as λ(B, B) -> «std-1.0.0-beta.12»::cmp::Ordering<>)(self.1, other.1)
    }
  };
}

noir_trait_impl[«std-1.0.0-beta.12».impl_113]<A: Type, B: Type, C: Type> «std-1.0.0-beta.12»::cmp::Ord<> for Tuple<A, B, C> where [A: «std-1.0.0-beta.12»::cmp::Ord<>, B: «std-1.0.0-beta.12»::cmp::Ord<>, C: «std-1.0.0-beta.12»::cmp::Ord<>] := {
  noir_def cmp<>(self: Tuple<A, B, C>, other: Tuple<A, B, C>) -> «std-1.0.0-beta.12»::cmp::Ordering<> := {
    let mut result = ((A as «std-1.0.0-beta.12»::cmp::Ord<>)::cmp<> as λ(A, A) -> «std-1.0.0-beta.12»::cmp::Ordering<>)(self.0, other.0);
    if ((«std-1.0.0-beta.12»::cmp::Ordering<> as «std-1.0.0-beta.12»::cmp::Eq<>)::eq<> as λ(«std-1.0.0-beta.12»::cmp::Ordering<>, «std-1.0.0-beta.12»::cmp::Ordering<>) -> bool)(result, («std-1.0.0-beta.12»::cmp::Ordering::equal<> as λ() -> «std-1.0.0-beta.12»::cmp::Ordering<>)()) then {
      result = ((B as «std-1.0.0-beta.12»::cmp::Ord<>)::cmp<> as λ(B, B) -> «std-1.0.0-beta.12»::cmp::Ordering<>)(self.1, other.1);
      #_skip
    };
    if ((«std-1.0.0-beta.12»::cmp::Ordering<> as «std-1.0.0-beta.12»::cmp::Eq<>)::eq<> as λ(«std-1.0.0-beta.12»::cmp::Ordering<>, «std-1.0.0-beta.12»::cmp::Ordering<>) -> bool)(result, («std-1.0.0-beta.12»::cmp::Ordering::equal<> as λ() -> «std-1.0.0-beta.12»::cmp::Ordering<>)()) then {
      result = ((C as «std-1.0.0-beta.12»::cmp::Ord<>)::cmp<> as λ(C, C) -> «std-1.0.0-beta.12»::cmp::Ordering<>)(self.2, other.2);
      #_skip
    };
    result
  };
}

noir_trait_impl[«std-1.0.0-beta.12».impl_114]<A: Type, B: Type, C: Type, D: Type> «std-1.0.0-beta.12»::cmp::Ord<> for Tuple<A, B, C, D> where [A: «std-1.0.0-beta.12»::cmp::Ord<>, B: «std-1.0.0-beta.12»::cmp::Ord<>, C: «std-1.0.0-beta.12»::cmp::Ord<>, D: «std-1.0.0-beta.12»::cmp::Ord<>] := {
  noir_def cmp<>(self: Tuple<A, B, C, D>, other: Tuple<A, B, C, D>) -> «std-1.0.0-beta.12»::cmp::Ordering<> := {
    let mut result = ((A as «std-1.0.0-beta.12»::cmp::Ord<>)::cmp<> as λ(A, A) -> «std-1.0.0-beta.12»::cmp::Ordering<>)(self.0, other.0);
    if ((«std-1.0.0-beta.12»::cmp::Ordering<> as «std-1.0.0-beta.12»::cmp::Eq<>)::eq<> as λ(«std-1.0.0-beta.12»::cmp::Ordering<>, «std-1.0.0-beta.12»::cmp::Ordering<>) -> bool)(result, («std-1.0.0-beta.12»::cmp::Ordering::equal<> as λ() -> «std-1.0.0-beta.12»::cmp::Ordering<>)()) then {
      result = ((B as «std-1.0.0-beta.12»::cmp::Ord<>)::cmp<> as λ(B, B) -> «std-1.0.0-beta.12»::cmp::Ordering<>)(self.1, other.1);
      #_skip
    };
    if ((«std-1.0.0-beta.12»::cmp::Ordering<> as «std-1.0.0-beta.12»::cmp::Eq<>)::eq<> as λ(«std-1.0.0-beta.12»::cmp::Ordering<>, «std-1.0.0-beta.12»::cmp::Ordering<>) -> bool)(result, («std-1.0.0-beta.12»::cmp::Ordering::equal<> as λ() -> «std-1.0.0-beta.12»::cmp::Ordering<>)()) then {
      result = ((C as «std-1.0.0-beta.12»::cmp::Ord<>)::cmp<> as λ(C, C) -> «std-1.0.0-beta.12»::cmp::Ordering<>)(self.2, other.2);
      #_skip
    };
    if ((«std-1.0.0-beta.12»::cmp::Ordering<> as «std-1.0.0-beta.12»::cmp::Eq<>)::eq<> as λ(«std-1.0.0-beta.12»::cmp::Ordering<>, «std-1.0.0-beta.12»::cmp::Ordering<>) -> bool)(result, («std-1.0.0-beta.12»::cmp::Ordering::equal<> as λ() -> «std-1.0.0-beta.12»::cmp::Ordering<>)()) then {
      result = ((D as «std-1.0.0-beta.12»::cmp::Ord<>)::cmp<> as λ(D, D) -> «std-1.0.0-beta.12»::cmp::Ordering<>)(self.3, other.3);
      #_skip
    };
    result
  };
}

noir_trait_impl[«std-1.0.0-beta.12».impl_115]<A: Type, B: Type, C: Type, D: Type, E: Type> «std-1.0.0-beta.12»::cmp::Ord<> for Tuple<A, B, C, D, E> where [A: «std-1.0.0-beta.12»::cmp::Ord<>, B: «std-1.0.0-beta.12»::cmp::Ord<>, C: «std-1.0.0-beta.12»::cmp::Ord<>, D: «std-1.0.0-beta.12»::cmp::Ord<>, E: «std-1.0.0-beta.12»::cmp::Ord<>] := {
  noir_def cmp<>(self: Tuple<A, B, C, D, E>, other: Tuple<A, B, C, D, E>) -> «std-1.0.0-beta.12»::cmp::Ordering<> := {
    let mut result = ((A as «std-1.0.0-beta.12»::cmp::Ord<>)::cmp<> as λ(A, A) -> «std-1.0.0-beta.12»::cmp::Ordering<>)(self.0, other.0);
    if ((«std-1.0.0-beta.12»::cmp::Ordering<> as «std-1.0.0-beta.12»::cmp::Eq<>)::eq<> as λ(«std-1.0.0-beta.12»::cmp::Ordering<>, «std-1.0.0-beta.12»::cmp::Ordering<>) -> bool)(result, («std-1.0.0-beta.12»::cmp::Ordering::equal<> as λ() -> «std-1.0.0-beta.12»::cmp::Ordering<>)()) then {
      result = ((B as «std-1.0.0-beta.12»::cmp::Ord<>)::cmp<> as λ(B, B) -> «std-1.0.0-beta.12»::cmp::Ordering<>)(self.1, other.1);
      #_skip
    };
    if ((«std-1.0.0-beta.12»::cmp::Ordering<> as «std-1.0.0-beta.12»::cmp::Eq<>)::eq<> as λ(«std-1.0.0-beta.12»::cmp::Ordering<>, «std-1.0.0-beta.12»::cmp::Ordering<>) -> bool)(result, («std-1.0.0-beta.12»::cmp::Ordering::equal<> as λ() -> «std-1.0.0-beta.12»::cmp::Ordering<>)()) then {
      result = ((C as «std-1.0.0-beta.12»::cmp::Ord<>)::cmp<> as λ(C, C) -> «std-1.0.0-beta.12»::cmp::Ordering<>)(self.2, other.2);
      #_skip
    };
    if ((«std-1.0.0-beta.12»::cmp::Ordering<> as «std-1.0.0-beta.12»::cmp::Eq<>)::eq<> as λ(«std-1.0.0-beta.12»::cmp::Ordering<>, «std-1.0.0-beta.12»::cmp::Ordering<>) -> bool)(result, («std-1.0.0-beta.12»::cmp::Ordering::equal<> as λ() -> «std-1.0.0-beta.12»::cmp::Ordering<>)()) then {
      result = ((D as «std-1.0.0-beta.12»::cmp::Ord<>)::cmp<> as λ(D, D) -> «std-1.0.0-beta.12»::cmp::Ordering<>)(self.3, other.3);
      #_skip
    };
    if ((«std-1.0.0-beta.12»::cmp::Ordering<> as «std-1.0.0-beta.12»::cmp::Eq<>)::eq<> as λ(«std-1.0.0-beta.12»::cmp::Ordering<>, «std-1.0.0-beta.12»::cmp::Ordering<>) -> bool)(result, («std-1.0.0-beta.12»::cmp::Ordering::equal<> as λ() -> «std-1.0.0-beta.12»::cmp::Ordering<>)()) then {
      result = ((E as «std-1.0.0-beta.12»::cmp::Ord<>)::cmp<> as λ(E, E) -> «std-1.0.0-beta.12»::cmp::Ordering<>)(self.4, other.4);
      #_skip
    };
    result
  };
}

noir_def «std-1.0.0-beta.12»::cmp::max<T: Type>(v1: T, v2: T) -> T := {
  if ((T as «std-1.0.0-beta.12»::cmp::Ord<>)::cmp<> as λ(T, T) -> bool)(v1, v2) then {
    v1
  } else {
    v2
  }
}

noir_def «std-1.0.0-beta.12»::cmp::min<T: Type>(v1: T, v2: T) -> T := {
  if ((T as «std-1.0.0-beta.12»::cmp::Ord<>)::cmp<> as λ(T, T) -> bool)(v1, v2) then {
    v2
  } else {
    v1
  }
}

noir_def «std-1.0.0-beta.12»::cmp::cmp_tests::sanity_check_min<>() -> Unit := {
  (#_assert returning Unit)((#_uEq returning bool)((«std-1.0.0-beta.12»::cmp::min<u64> as λ(u64, u64) -> u64)((0: u64), (1: u64)), (0: u64)));
  (#_assert returning Unit)((#_uEq returning bool)((«std-1.0.0-beta.12»::cmp::min<u64> as λ(u64, u64) -> u64)((0: u64), (0: u64)), (0: u64)));
  (#_assert returning Unit)((#_uEq returning bool)((«std-1.0.0-beta.12»::cmp::min<u64> as λ(u64, u64) -> u64)((1: u64), (1: u64)), (1: u64)));
  (#_assert returning Unit)((#_uEq returning bool)((«std-1.0.0-beta.12»::cmp::min<u8> as λ(u8, u8) -> u8)((255: u8), (0: u8)), (0: u8)));
  #_skip
}

noir_def «std-1.0.0-beta.12»::cmp::cmp_tests::sanity_check_max<>() -> Unit := {
  (#_assert returning Unit)((#_uEq returning bool)((«std-1.0.0-beta.12»::cmp::max<u64> as λ(u64, u64) -> u64)((0: u64), (1: u64)), (1: u64)));
  (#_assert returning Unit)((#_uEq returning bool)((«std-1.0.0-beta.12»::cmp::max<u64> as λ(u64, u64) -> u64)((0: u64), (0: u64)), (0: u64)));
  (#_assert returning Unit)((#_uEq returning bool)((«std-1.0.0-beta.12»::cmp::max<u64> as λ(u64, u64) -> u64)((1: u64), (1: u64)), (1: u64)));
  (#_assert returning Unit)((#_uEq returning bool)((«std-1.0.0-beta.12»::cmp::max<u8> as λ(u8, u8) -> u8)((255: u8), (0: u8)), (255: u8)));
  #_skip
}

noir_def «std-1.0.0-beta.12»::cmp::cmp_tests::correctly_handles_unequal_length_slices<>() -> Unit := {
  let slice_1 = (#_mkSlice returning Slice<Field>)((0: Field), (1: Field), (2: Field), (3: Field));
  let slice_2 = (#_mkSlice returning Slice<Field>)((0: Field), (1: Field), (2: Field));
  (#_assert returning Unit)((#_bNot returning bool)(((Slice<Field> as «std-1.0.0-beta.12»::cmp::Eq<>)::eq<> as λ(Slice<Field>, Slice<Field>) -> bool)(slice_1, slice_2)));
  #_skip
}

noir_def «std-1.0.0-beta.12»::cmp::cmp_tests::lexicographic_ordering_for_slices<>() -> Unit := {
  (#_assert returning Unit)(((«std-1.0.0-beta.12»::cmp::Ordering<> as «std-1.0.0-beta.12»::cmp::Eq<>)::eq<> as λ(«std-1.0.0-beta.12»::cmp::Ordering<>, «std-1.0.0-beta.12»::cmp::Ordering<>) -> bool)(((Slice<u32> as «std-1.0.0-beta.12»::cmp::Ord<>)::cmp<> as λ(Slice<u32>, Slice<u32>) -> «std-1.0.0-beta.12»::cmp::Ordering<>)((#_mkSlice returning Slice<u32>)((2: u32)), (#_mkSlice returning Slice<u32>)((1: u32), (1: u32), (1: u32))), («std-1.0.0-beta.12»::cmp::Ordering::greater<> as λ() -> «std-1.0.0-beta.12»::cmp::Ordering<>)()));
  (#_assert returning Unit)(((«std-1.0.0-beta.12»::cmp::Ordering<> as «std-1.0.0-beta.12»::cmp::Eq<>)::eq<> as λ(«std-1.0.0-beta.12»::cmp::Ordering<>, «std-1.0.0-beta.12»::cmp::Ordering<>) -> bool)(((Slice<u32> as «std-1.0.0-beta.12»::cmp::Ord<>)::cmp<> as λ(Slice<u32>, Slice<u32>) -> «std-1.0.0-beta.12»::cmp::Ordering<>)((#_mkSlice returning Slice<u32>)((1: u32), (2: u32)), (#_mkSlice returning Slice<u32>)((1: u32), (2: u32), (3: u32))), («std-1.0.0-beta.12»::cmp::Ordering::less<> as λ() -> «std-1.0.0-beta.12»::cmp::Ordering<>)()));
  #_skip
}

def «std-1.0.0-beta.12».Cmp.env : Env := Env.mk
  [«std-1.0.0-beta.12::cmp::Ordering::less», «std-1.0.0-beta.12::cmp::Ordering::equal», «std-1.0.0-beta.12::cmp::Ordering::greater», «std-1.0.0-beta.12::cmp::max», «std-1.0.0-beta.12::cmp::min», «std-1.0.0-beta.12::cmp::cmp_tests::sanity_check_min», «std-1.0.0-beta.12::cmp::cmp_tests::sanity_check_max», «std-1.0.0-beta.12::cmp::cmp_tests::correctly_handles_unequal_length_slices», «std-1.0.0-beta.12::cmp::cmp_tests::lexicographic_ordering_for_slices»]
  [impl_78, impl_79, impl_80, impl_81, impl_82, impl_83, impl_84, impl_85, impl_86, impl_87, impl_88, impl_89, impl_90, impl_91, impl_92, impl_93, impl_94, impl_95, impl_96, impl_97, impl_98, impl_99, impl_100, impl_101, impl_102, impl_103, impl_104, impl_105, impl_106, impl_107, impl_108, impl_109, impl_110, impl_111, impl_112, impl_113, impl_114, impl_115]
