-- Generated by lampe

import «std-1.0.0-beta.12».Extracted.GeneratedTypes
import Lampe

open Lampe

noir_def «std-1.0.0-beta.12»::print_oracle<T: Type>(with_newline: bool, input: T) -> Unit := {
  (#_fresh returning Unit)()
}

noir_def «std-1.0.0-beta.12»::print_unconstrained<T: Type>(with_newline: bool, input: T) -> Unit := {
  (#_fresh returning Unit)()
}

noir_def «std-1.0.0-beta.12»::println<T: Type>(input: T) -> Unit := {
  («std-1.0.0-beta.12»::print_unconstrained<T> as λ(bool, T) -> Unit)(#_true, input);
  #_skip
}

noir_def «std-1.0.0-beta.12»::print<T: Type>(input: T) -> Unit := {
  («std-1.0.0-beta.12»::print_unconstrained<T> as λ(bool, T) -> Unit)(#_false, input);
  #_skip
}

noir_def «std-1.0.0-beta.12»::verify_proof_with_type<N: u32, M: u32, K: u32>(verification_key: Array<Field, N: u32>, proof: Array<Field, M: u32>, public_inputs: Array<Field, K: u32>, key_hash: Field, proof_type: u32) -> Unit := {
  if (#_bNot returning bool)((#_isUnconstrained returning bool)()) then {
    (#_assertConstant returning Unit)(proof_type);
    #_skip
  };
  (#_recursiveAggregation returning Unit)(verification_key, proof, public_inputs, key_hash, proof_type);
  #_skip
}

[[deprecated "wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_add(y)"]]
noir_def «std-1.0.0-beta.12»::wrapping_add<T: Type>(x: T, y: T) -> T := {
  ((Field as «std-1.0.0-beta.12»::convert::AsPrimitive<T>)::as_<> as λ(Field) -> T)((#_fAdd returning Field)(((T as «std-1.0.0-beta.12»::convert::AsPrimitive<Field>)::as_<> as λ(T) -> Field)(x), ((T as «std-1.0.0-beta.12»::convert::AsPrimitive<Field>)::as_<> as λ(T) -> Field)(y)))
}

[[deprecated "wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_sub(y)"]]
noir_def «std-1.0.0-beta.12»::wrapping_sub<T: Type>(x: T, y: T) -> T := {
  ((Field as «std-1.0.0-beta.12»::convert::AsPrimitive<T>)::as_<> as λ(Field) -> T)((#_fSub returning Field)((#_fAdd returning Field)(((T as «std-1.0.0-beta.12»::convert::AsPrimitive<Field>)::as_<> as λ(T) -> Field)(x), (340282366920938463463374607431768211456: Field)), ((T as «std-1.0.0-beta.12»::convert::AsPrimitive<Field>)::as_<> as λ(T) -> Field)(y)))
}

[[deprecated "wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_mul(y)"]]
noir_def «std-1.0.0-beta.12»::wrapping_mul<T: Type>(x: T, y: T) -> T := {
  ((Field as «std-1.0.0-beta.12»::convert::AsPrimitive<T>)::as_<> as λ(Field) -> T)((#_fMul returning Field)(((T as «std-1.0.0-beta.12»::convert::AsPrimitive<Field>)::as_<> as λ(T) -> Field)(x), ((T as «std-1.0.0-beta.12»::convert::AsPrimitive<Field>)::as_<> as λ(T) -> Field)(y)))
}

noir_def «std-1.0.0-beta.12»::tests::test_static_assert_custom_message<>() -> Unit := {
  (#_staticAssert returning Unit)((#_fEq returning bool)((1: Field), (2: Field)), "custom message");
  #_skip
}

noir_def «std-1.0.0-beta.12»::tests::test_wrapping_mul<>() -> Unit := {
  let zero = (0: u128);
  let one = (1: u128);
  let two_pow_64 = (18446744073709551616: u128);
  let u128_max = (340282366920938463463374607431768211455: u128);
  (#_assert returning Unit)((#_uEq returning bool)(zero, ((u128 as «std-1.0.0-beta.12»::ops::arith::WrappingMul<>)::wrapping_mul<> as λ(u128, u128) -> u128)(zero, one)));
  (#_assert returning Unit)((#_uEq returning bool)(zero, ((u128 as «std-1.0.0-beta.12»::ops::arith::WrappingMul<>)::wrapping_mul<> as λ(u128, u128) -> u128)(one, zero)));
  (#_assert returning Unit)((#_uEq returning bool)(one, ((u128 as «std-1.0.0-beta.12»::ops::arith::WrappingMul<>)::wrapping_mul<> as λ(u128, u128) -> u128)(one, one)));
  (#_assert returning Unit)((#_uEq returning bool)(zero, ((u128 as «std-1.0.0-beta.12»::ops::arith::WrappingMul<>)::wrapping_mul<> as λ(u128, u128) -> u128)(zero, two_pow_64)));
  (#_assert returning Unit)((#_uEq returning bool)(zero, ((u128 as «std-1.0.0-beta.12»::ops::arith::WrappingMul<>)::wrapping_mul<> as λ(u128, u128) -> u128)(two_pow_64, zero)));
  (#_assert returning Unit)((#_uEq returning bool)(two_pow_64, ((u128 as «std-1.0.0-beta.12»::ops::arith::WrappingMul<>)::wrapping_mul<> as λ(u128, u128) -> u128)(two_pow_64, one)));
  (#_assert returning Unit)((#_uEq returning bool)(two_pow_64, ((u128 as «std-1.0.0-beta.12»::ops::arith::WrappingMul<>)::wrapping_mul<> as λ(u128, u128) -> u128)(one, two_pow_64)));
  (#_assert returning Unit)((#_uEq returning bool)(zero, ((u128 as «std-1.0.0-beta.12»::ops::arith::WrappingMul<>)::wrapping_mul<> as λ(u128, u128) -> u128)(two_pow_64, two_pow_64)));
  (#_assert returning Unit)((#_uEq returning bool)(one, ((u128 as «std-1.0.0-beta.12»::ops::arith::WrappingMul<>)::wrapping_mul<> as λ(u128, u128) -> u128)(u128_max, u128_max)));
  #_skip
}

def «std-1.0.0-beta.12».Lib.env : Env := Env.mk
  [«std-1.0.0-beta.12::print_oracle», «std-1.0.0-beta.12::print_unconstrained», «std-1.0.0-beta.12::println», «std-1.0.0-beta.12::print», «std-1.0.0-beta.12::verify_proof_with_type», «std-1.0.0-beta.12::tests::test_static_assert_custom_message», «std-1.0.0-beta.12::tests::test_wrapping_mul»]
  []
