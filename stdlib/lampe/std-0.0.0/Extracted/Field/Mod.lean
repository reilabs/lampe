-- Generated by lampe

import «std-0.0.0».Extracted.GeneratedTypes
import Lampe

open Lampe

namespace «std-0.0.0»
namespace Extracted

nr_def «field»::«__assert_max_bit_size»<>(value : Field, bit_size : u32) -> Unit {

}

nr_def «field»::«__to_le_radix»<@N : u32>(value : Field, radix : u32) -> [u8; N] {

}

nr_def «field»::«__to_be_radix»<@N : u32>(value : Field, radix : u32) -> [u8; N] {

}

nr_def «field»::«__to_le_bits»<@N : u32>(value : Field) -> [u1; N] {

}

nr_def «field»::«__to_be_bits»<@N : u32>(value : Field) -> [u1; N] {

}

nr_def «field»::«__field_less_than»<>(x : Field, y : Field) -> bool {
    #fresh() : bool
}

nr_def «field»::«field_less_than»<>(x : Field, y : Field) -> bool {
    #fresh() : bool
}

nr_def «field»::«bytes32_to_field»<>(bytes32 : [u8; 32]) -> Field {
    let mut v = 1 : Field;
    let mut high = #cast(0 : Field) : Field;
    let mut low = #cast(0 : Field) : Field;
    for i in 0 : u32 .. 16 : u32 {
            high = #fAdd(high, #fMul(#cast(#arrayIndex(bytes32, #cast(#uSub(15 : u32, i) : u32) : u32) : u8) : Field, v) : Field) : Field;
        low = #fAdd(low, #fMul(#cast(#arrayIndex(bytes32, #cast(#uSub(#uAdd(16 : u32, 15 : u32) : u32, i) : u32) : u32) : u8) : Field, v) : Field) : Field;
        v = #fMul(v, 256 : Field) : Field;
        skip;
    };
    #fAdd(low, #fMul(high, v) : Field) : Field;
}

nr_def «field»::«lt_fallback»<>(x : Field, y : Field) -> bool {
    if (@std::runtime::is_unconstrained<  > as λ() → bool)() {
                (@std::field::field_less_than<  > as λ(Field, Field) → bool)(x, y);
    } else {
            let x_bytes = (@Field::to_le_bytes< 32 : u32 > as λ(Field) → [u8; 32])(x);
        let y_bytes = (@Field::to_le_bytes< 32 : u32 > as λ(Field) → [u8; 32])(y);
        let mut x_is_lt = false;
        let mut done = false;
        for i in 0 : u32 .. 32 : u32 {
                if #bNot(done) : bool {
                    let x_byte = #cast(#arrayIndex(x_bytes, #cast(#uSub(#uSub(32 : u32, 1 : u32) : u32, i) : u32) : u32) : u8) : u8;
                let y_byte = #cast(#arrayIndex(y_bytes, #cast(#uSub(#uSub(32 : u32, 1 : u32) : u32, i) : u32) : u32) : u8) : u8;
                let bytes_match = #uEq(x_byte, y_byte) : bool;
                if #bNot(bytes_match) : bool {
                        x_is_lt = #uLt(x_byte, y_byte) : bool;
                    done = true;
                    skip;
                };
            };
        };
        x_is_lt;
    };
}

nr_def «field»::«tests»::«test_to_be_bits»<>() -> Unit {
    let field = 2 : Field;
    let bits = (@Field::to_be_bits< 8 : u32 > as λ(Field) → [u1; 8])(field);
    #assert((([u1; 8] as Eq<  >)::eq<  > as λ([u1; 8], [u1; 8]) → bool)(bits, #mkArray(0 : u1, 0 : u1, 0 : u1, 0 : u1, 0 : u1, 0 : u1, 1 : u1, 0 : u1) : [u1; 8])) : Unit;
}

nr_def «field»::«tests»::«test_to_le_bits»<>() -> Unit {
    let field = 2 : Field;
    let bits = (@Field::to_le_bits< 8 : u32 > as λ(Field) → [u1; 8])(field);
    #assert((([u1; 8] as Eq<  >)::eq<  > as λ([u1; 8], [u1; 8]) → bool)(bits, #mkArray(0 : u1, 1 : u1, 0 : u1, 0 : u1, 0 : u1, 0 : u1, 0 : u1, 0 : u1) : [u1; 8])) : Unit;
}

nr_def «field»::«tests»::«test_to_be_bytes»<>() -> Unit {
    let field = 2 : Field;
    let bytes = (@Field::to_be_bytes< 8 : u32 > as λ(Field) → [u8; 8])(field);
    #assert((([u8; 8] as Eq<  >)::eq<  > as λ([u8; 8], [u8; 8]) → bool)(bytes, #mkArray(0 : u8, 0 : u8, 0 : u8, 0 : u8, 0 : u8, 0 : u8, 0 : u8, 2 : u8) : [u8; 8])) : Unit;
    #assert(#fEq((@Field::from_be_bytes< 8 : u32 > as λ([u8; 8]) → Field)(bytes), field) : bool) : Unit;
}

nr_def «field»::«tests»::«test_to_le_bytes»<>() -> Unit {
    let field = 2 : Field;
    let bytes = (@Field::to_le_bytes< 8 : u32 > as λ(Field) → [u8; 8])(field);
    #assert((([u8; 8] as Eq<  >)::eq<  > as λ([u8; 8], [u8; 8]) → bool)(bytes, #mkArray(2 : u8, 0 : u8, 0 : u8, 0 : u8, 0 : u8, 0 : u8, 0 : u8, 0 : u8) : [u8; 8])) : Unit;
    #assert(#fEq((@Field::from_le_bytes< 8 : u32 > as λ([u8; 8]) → Field)(bytes), field) : bool) : Unit;
}

nr_def «field»::«tests»::«test_to_be_radix»<>() -> Unit {
    let field = 259 : Field;
    let bytes = (@Field::to_be_radix< 8 : u32 > as λ(Field, u32) → [u8; 8])(field, 256 : u32);
    #assert((([u8; 8] as Eq<  >)::eq<  > as λ([u8; 8], [u8; 8]) → bool)(bytes, #mkArray(0 : u8, 0 : u8, 0 : u8, 0 : u8, 0 : u8, 0 : u8, 1 : u8, 3 : u8) : [u8; 8])) : Unit;
    #assert(#fEq((@Field::from_be_bytes< 8 : u32 > as λ([u8; 8]) → Field)(bytes), field) : bool) : Unit;
}

nr_def «field»::«tests»::«test_to_le_radix»<>() -> Unit {
    let field = 259 : Field;
    let bytes = (@Field::to_le_radix< 8 : u32 > as λ(Field, u32) → [u8; 8])(field, 256 : u32);
    #assert((([u8; 8] as Eq<  >)::eq<  > as λ([u8; 8], [u8; 8]) → bool)(bytes, #mkArray(3 : u8, 1 : u8, 0 : u8, 0 : u8, 0 : u8, 0 : u8, 0 : u8, 0 : u8) : [u8; 8])) : Unit;
    #assert(#fEq((@Field::from_le_bytes< 8 : u32 > as λ([u8; 8]) → Field)(bytes), field) : bool) : Unit;
}

nr_def «field»::«tests»::«test_to_le_radix_1»<>() -> Unit {
    if #bNot((@std::runtime::is_unconstrained<  > as λ() → bool)()) : bool {
            let field = 2 : Field;
        let _? = (@Field::to_le_radix< 8 : u32 > as λ(Field, u32) → [u8; 8])(field, 1 : u32);
    } else {
            (@std::panic::panic< `(), Unit, 28 : u32 > as λ(fmtstr<28, ()>) → Unit)(#format("radix must be greater than 1", ));
    };
}

nr_def «field»::«tests»::«test_to_le_radix_3»<>() -> Unit {
    if #bNot((@std::runtime::is_unconstrained<  > as λ() → bool)()) : bool {
            let field = 2 : Field;
        let _? = (@Field::to_le_radix< 8 : u32 > as λ(Field, u32) → [u8; 8])(field, 3 : u32);
    } else {
            (@std::panic::panic< `(), Unit, 26 : u32 > as λ(fmtstr<26, ()>) → Unit)(#format("radix must be a power of 2", ));
    };
}

nr_def «field»::«tests»::«test_to_le_radix_brillig_3»<>() -> Unit {
    if (@std::runtime::is_unconstrained<  > as λ() → bool)() {
            let field = 1 : Field;
        let out = (@Field::to_le_radix< 8 : u32 > as λ(Field, u32) → [u8; 8])(field, 3 : u32);
        let mut expected = [0 : u8 ; 8];
        expected[#cast(0 : u32) : u32] = 1 : u8;
        #assert((([u8; 8] as Eq<  >)::eq<  > as λ([u8; 8], [u8; 8]) → bool)(out, expected)) : Unit;
    };
}

nr_def «field»::«tests»::«test_to_le_radix_512»<>() -> Unit {
    if #bNot((@std::runtime::is_unconstrained<  > as λ() → bool)()) : bool {
            let field = 2 : Field;
        let _? = (@Field::to_le_radix< 8 : u32 > as λ(Field, u32) → [u8; 8])(field, 512 : u32);
    } else {
            (@std::panic::panic< `(), Unit, 39 : u32 > as λ(fmtstr<39, ()>) → Unit)(#format("radix must be less than or equal to 256", ));
    };
}

nr_def «field»::«tests»::«test_field_less_than»<>() -> Unit {
    #fresh() : Unit
}


def Field.Mod.env := Lampe.Env.mk [«field::__assert_max_bit_size», «field::__field_less_than», «field::__to_be_bits», «field::__to_be_radix», «field::__to_le_bits», «field::__to_le_radix», «field::bytes32_to_field», «field::field_less_than», «field::lt_fallback», «field::tests::test_field_less_than», «field::tests::test_to_be_bits», «field::tests::test_to_be_bytes», «field::tests::test_to_be_radix», «field::tests::test_to_le_bits», «field::tests::test_to_le_bytes», «field::tests::test_to_le_radix_1», «field::tests::test_to_le_radix_3», «field::tests::test_to_le_radix_512», «field::tests::test_to_le_radix_brillig_3», «field::tests::test_to_le_radix»] []