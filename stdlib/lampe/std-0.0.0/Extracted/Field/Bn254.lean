-- Generated by lampe

import «std-0.0.0».Extracted.GeneratedTypes
import Lampe

open Lampe

namespace «std-0.0.0»
namespace Extracted

nr_def «PLO»<>() -> Field {
    53438638232309528389504892708671455233 : Field
}

nr_def «PHI»<>() -> Field {
    64323764613183177041862057485226039389 : Field
}

nr_def «TWO_POW_128»<>() -> Field {
    340282366920938463463374607431768211456 : Field
}

nr_def «field»::«bn254»::«compute_decomposition»<>(x : Field) -> `(Field, Field) {
    let low = #cast(#cast(x) : u128) : Field;
    let high = #fDiv(#fSub(x, low) : Field, (@TWO_POW_128<  > as λ() → Field)()) : Field;
    `(low, high);
}

nr_def «field»::«bn254»::«decompose_hint»<>(x : Field) -> `(Field, Field) {
    #fresh() : `(Field, Field)
}

nr_def «field»::«bn254»::«lte_hint»<>(x : Field, y : Field) -> bool {
    #fresh() : bool
}

nr_def «field»::«bn254»::«assert_gt_limbs»<>(a : `(Field, Field), b : `(Field, Field)) -> Unit {
    let π0 = a;
    let alo = π0.0;
    let ahi = π0.1;
    let π0 = b;
    let blo = π0.0;
    let bhi = π0.1;
        let borrow = (@std::field::bn254::lte_hint<  > as λ(Field, Field) → bool)(alo, blo);
        let rlo = #fAdd(#fSub(#fSub(alo, blo) : Field, 1 : Field) : Field, #fMul(#cast(borrow) : Field, (@TWO_POW_128<  > as λ() → Field)()) : Field) : Field;
        let rhi = #fSub(#fSub(ahi, bhi) : Field, #cast(borrow) : Field) : Field;
        (@Field::assert_max_bit_size< 128 : u32 > as λ(Field) → Unit)(rlo);
        (@Field::assert_max_bit_size< 128 : u32 > as λ(Field) → Unit)(rhi);
}

nr_def «field»::«bn254»::«decompose»<>(x : Field) -> `(Field, Field) {
    if (@std::runtime::is_unconstrained<  > as λ() → bool)() {
            (@std::field::bn254::compute_decomposition<  > as λ(Field) → `(Field, Field))(x);
    } else {
                let π0 = (@std::field::bn254::decompose_hint<  > as λ(Field) → `(Field, Field))(x);
            let xlo = π0.0;
            let xhi = π0.1;
            (@Field::assert_max_bit_size< 128 : u32 > as λ(Field) → Unit)(xlo);
            (@Field::assert_max_bit_size< 128 : u32 > as λ(Field) → Unit)(xhi);
            #assert(#fEq(x, #fAdd(xlo, #fMul((@TWO_POW_128<  > as λ() → Field)(), xhi) : Field) : Field) : bool) : Unit;
            (@std::field::bn254::assert_gt_limbs<  > as λ(`(Field, Field), `(Field, Field)) → Unit)(`((@PLO<  > as λ() → Field)(), (@PHI<  > as λ() → Field)()), `(xlo, xhi));
            `(xlo, xhi);
    };
}

nr_def «field»::«bn254»::«assert_gt»<>(a : Field, b : Field) -> Unit {
    if (@std::runtime::is_unconstrained<  > as λ() → bool)() {
            #assert(    (@std::field::field_less_than<  > as λ(Field, Field) → bool)(b, a);) : Unit;
    } else {
            let a_limbs = (@std::field::bn254::decompose<  > as λ(Field) → `(Field, Field))(a);
        let b_limbs = (@std::field::bn254::decompose<  > as λ(Field) → `(Field, Field))(b);
        (@std::field::bn254::assert_gt_limbs<  > as λ(`(Field, Field), `(Field, Field)) → Unit)(a_limbs, b_limbs);
    };
}

nr_def «field»::«bn254»::«assert_lt»<>(a : Field, b : Field) -> Unit {
    (@std::field::bn254::assert_gt<  > as λ(Field, Field) → Unit)(b, a);
}

nr_def «field»::«bn254»::«gt»<>(a : Field, b : Field) -> bool {
    if (@std::runtime::is_unconstrained<  > as λ() → bool)() {
                (@std::field::field_less_than<  > as λ(Field, Field) → bool)(b, a);
    } else {
        if #fEq(a, b) : bool {
            false;
    } else {
                if (@std::field::field_less_than<  > as λ(Field, Field) → bool)(a, b) {
                    (@std::field::bn254::assert_gt<  > as λ(Field, Field) → Unit)(b, a);
                false;
            } else {
                    (@std::field::bn254::assert_gt<  > as λ(Field, Field) → Unit)(a, b);
                true;
            };
    }
    };
}

nr_def «field»::«bn254»::«lt»<>(a : Field, b : Field) -> bool {
    (@std::field::bn254::gt<  > as λ(Field, Field) → bool)(b, a);
}

nr_def «field»::«bn254»::«tests»::«check_decompose»<>() -> Unit {
    #assert(((`(Field, Field) as Eq<  >)::eq<  > as λ(`(Field, Field), `(Field, Field)) → bool)(`(Field, Field), `(Field, Field))) : Unit;
    #assert(((`(Field, Field) as Eq<  >)::eq<  > as λ(`(Field, Field), `(Field, Field)) → bool)(`(Field, Field), `(Field, Field))) : Unit;
    #assert(((`(Field, Field) as Eq<  >)::eq<  > as λ(`(Field, Field), `(Field, Field)) → bool)(`(Field, Field), `(Field, Field))) : Unit;
}

nr_def «field»::«bn254»::«tests»::«check_decompose_unconstrained»<>() -> Unit {
    #fresh() : Unit
}

nr_def «field»::«bn254»::«tests»::«check_lte_hint»<>() -> Unit {
    #fresh() : Unit
}

nr_def «field»::«bn254»::«tests»::«check_assert_gt»<>() -> Unit {
    (@std::field::bn254::assert_gt<  > as λ(Field, Field) → Unit)(1 : Field, 0 : Field);
    (@std::field::bn254::assert_gt<  > as λ(Field, Field) → Unit)(256 : Field, 0 : Field);
    (@std::field::bn254::assert_gt<  > as λ(Field, Field) → Unit)(#fSub(0 : Field, 1 : Field) : Field, #fSub(0 : Field, 2 : Field) : Field);
    (@std::field::bn254::assert_gt<  > as λ(Field, Field) → Unit)((@TWO_POW_128<  > as λ() → Field)(), 0 : Field);
    (@std::field::bn254::assert_gt<  > as λ(Field, Field) → Unit)(#fSub(0 : Field, 1 : Field) : Field, 0 : Field);
}

nr_def «field»::«bn254»::«tests»::«check_assert_gt_unconstrained»<>() -> Unit {
    #fresh() : Unit
}

nr_def «field»::«bn254»::«tests»::«check_gt»<>() -> Unit {
    #assert((@std::field::bn254::gt<  > as λ(Field, Field) → bool)(1 : Field, 0 : Field)) : Unit;
    #assert((@std::field::bn254::gt<  > as λ(Field, Field) → bool)(256 : Field, 0 : Field)) : Unit;
    #assert((@std::field::bn254::gt<  > as λ(Field, Field) → bool)(#fSub(0 : Field, 1 : Field) : Field, #fSub(0 : Field, 2 : Field) : Field)) : Unit;
    #assert((@std::field::bn254::gt<  > as λ(Field, Field) → bool)((@TWO_POW_128<  > as λ() → Field)(), 0 : Field)) : Unit;
    #assert(#bNot((@std::field::bn254::gt<  > as λ(Field, Field) → bool)(0 : Field, 0 : Field)) : bool) : Unit;
    #assert(#bNot((@std::field::bn254::gt<  > as λ(Field, Field) → bool)(0 : Field, 256 : Field)) : bool) : Unit;
    #assert((@std::field::bn254::gt<  > as λ(Field, Field) → bool)(#fSub(0 : Field, 1 : Field) : Field, #fSub(0 : Field, 2 : Field) : Field)) : Unit;
    #assert(#bNot((@std::field::bn254::gt<  > as λ(Field, Field) → bool)(#fSub(0 : Field, 2 : Field) : Field, #fSub(0 : Field, 1 : Field) : Field)) : bool) : Unit;
}

nr_def «field»::«bn254»::«tests»::«check_gt_unconstrained»<>() -> Unit {
    #fresh() : Unit
}

nr_def «field»::«bn254»::«tests»::«check_plo_phi»<>() -> Unit {
    #assert(#fEq(#fAdd((@PLO<  > as λ() → Field)(), #fMul((@PHI<  > as λ() → Field)(), (@TWO_POW_128<  > as λ() → Field)()) : Field) : Field, 0 : Field) : bool) : Unit;
    let p_bytes = (@std::field::modulus_le_bytes<  > as λ() → [u8])();
    let mut p_low = 0 : Field;
    let mut p_high = 0 : Field;
    let mut offset = 1 : Field;
    for i in 0 : u32 .. 16 : u32 {
            p_low = #fAdd(p_low, #fMul(#cast(#sliceIndex(p_bytes, #cast(i) : u32) : u8) : Field, offset) : Field) : Field;
        p_high = #fAdd(p_high, #fMul(#cast(#sliceIndex(p_bytes, #cast(#uAdd(i, 16 : u32) : u32) : u32) : u8) : Field, offset) : Field) : Field;
        offset = #fMul(offset, 256 : Field) : Field;
        skip;
    };
    #assert(#fEq(p_low, (@PLO<  > as λ() → Field)()) : bool) : Unit;
    #assert(#fEq(p_high, (@PHI<  > as λ() → Field)()) : bool) : Unit;
}


def Field.Bn254.env := Lampe.Env.mk [«PHI», «PLO», «TWO_POW_128», «field::bn254::assert_gt_limbs», «field::bn254::assert_gt», «field::bn254::assert_lt», «field::bn254::compute_decomposition», «field::bn254::decompose_hint», «field::bn254::decompose», «field::bn254::gt», «field::bn254::lte_hint», «field::bn254::lt», «field::bn254::tests::check_assert_gt_unconstrained», «field::bn254::tests::check_assert_gt», «field::bn254::tests::check_decompose_unconstrained», «field::bn254::tests::check_decompose», «field::bn254::tests::check_gt_unconstrained», «field::bn254::tests::check_gt», «field::bn254::tests::check_lte_hint», «field::bn254::tests::check_plo_phi»] []