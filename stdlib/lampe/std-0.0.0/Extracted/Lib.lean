-- Generated by lampe

import «std-0.0.0».Extracted.GeneratedTypes
import Lampe

open Lampe

namespace «std-0.0.0»
namespace Extracted

nr_def «print_oracle»<T>(with_newline : bool, input : T) -> Unit {
    #fresh() : Unit
}

nr_def «print_unconstrained»<T>(with_newline : bool, input : T) -> Unit {
    #fresh() : Unit
}

nr_def «println»<T>(input : T) -> Unit {
        (@std::::print_unconstrained<T> as λ(bool, T) → Unit)(true, input);
}

nr_def «print»<T>(input : T) -> Unit {
        (@std::::print_unconstrained<T> as λ(bool, T) → Unit)(false, input);
}

nr_def «verify_proof»<@N : u32, @M : u32, @K : u32>(verification_key : [Field; N], proof : [Field; M], public_inputs : [Field; K], key_hash : Field) -> Unit {
    (@std::::verify_proof_internal<N, M, K> as λ([Field; N], [Field; M], [Field; K], Field, u32) → Unit)(verification_key, proof, public_inputs, key_hash, 0 : u32);
}

nr_def «verify_proof_with_type»<@N : u32, @M : u32, @K : u32>(verification_key : [Field; N], proof : [Field; M], public_inputs : [Field; K], key_hash : Field, proof_type : u32) -> Unit {
    if #bNot((@std::runtime::is_unconstrained<> as λ() → bool)()) : bool {
            (@std::::assert_constant<u32> as λ(u32) → Unit)(proof_type);
    };
    (@std::::verify_proof_internal<N, M, K> as λ([Field; N], [Field; M], [Field; K], Field, u32) → Unit)(verification_key, proof, public_inputs, key_hash, proof_type);
}

nr_def «verify_proof_internal»<@N : u32, @M : u32, @K : u32>(verification_key : [Field; N], proof : [Field; M], public_inputs : [Field; K], key_hash : Field, proof_type : u32) -> Unit {

}

nr_def «assert_constant»<T>(x : T) -> Unit {

}

nr_def «static_assert»<T>(predicate : bool, message : T) -> Unit {

}

nr_def «wrapping_add»<T>(x : T, y : T) -> T {
    ((Field as std::convert::AsPrimitive<T>)::as_<> as λ(Field) → T)(#fAdd(((T as std::convert::AsPrimitive<Field>)::as_<> as λ(T) → Field)(x), ((T as std::convert::AsPrimitive<Field>)::as_<> as λ(T) → Field)(y)) : Field);
}

nr_def «wrapping_sub»<T>(x : T, y : T) -> T {
    ((Field as std::convert::AsPrimitive<T>)::as_<> as λ(Field) → T)(#fSub(#fAdd(((T as std::convert::AsPrimitive<Field>)::as_<> as λ(T) → Field)(x), 340282366920938463463374607431768211456 : Field) : Field, ((T as std::convert::AsPrimitive<Field>)::as_<> as λ(T) → Field)(y)) : Field);
}

nr_def «wrapping_mul»<T>(x : T, y : T) -> T {
    ((Field as std::convert::AsPrimitive<T>)::as_<> as λ(Field) → T)(#fMul(((T as std::convert::AsPrimitive<Field>)::as_<> as λ(T) → Field)(x), ((T as std::convert::AsPrimitive<Field>)::as_<> as λ(T) → Field)(y)) : Field);
}

nr_def «as_witness»<>(x : Field) -> Unit {

}

nr_def «tests»::«test_static_assert_custom_message»<>() -> Unit {
    (@std::::static_assert<str<14>> as λ(bool, str<14>) → Unit)(#fEq(1 : Field, 2 : Field) : bool, "custom message");
}

nr_def «tests»::«test_wrapping_mul»<>() -> Unit {
    let zero = 0 : u128;
    let one = 1 : u128;
    let two_pow_64 = 18446744073709551616 : u128;
    let u128_max = 340282366920938463463374607431768211455 : u128;
    #assert(#uEq(zero, ((u128 as std::ops::arith::WrappingMul<>)::wrapping_mul<> as λ(u128, u128) → u128)(zero, one)) : bool) : Unit;
    #assert(#uEq(zero, ((u128 as std::ops::arith::WrappingMul<>)::wrapping_mul<> as λ(u128, u128) → u128)(one, zero)) : bool) : Unit;
    #assert(#uEq(one, ((u128 as std::ops::arith::WrappingMul<>)::wrapping_mul<> as λ(u128, u128) → u128)(one, one)) : bool) : Unit;
    #assert(#uEq(zero, ((u128 as std::ops::arith::WrappingMul<>)::wrapping_mul<> as λ(u128, u128) → u128)(zero, two_pow_64)) : bool) : Unit;
    #assert(#uEq(zero, ((u128 as std::ops::arith::WrappingMul<>)::wrapping_mul<> as λ(u128, u128) → u128)(two_pow_64, zero)) : bool) : Unit;
    #assert(#uEq(two_pow_64, ((u128 as std::ops::arith::WrappingMul<>)::wrapping_mul<> as λ(u128, u128) → u128)(two_pow_64, one)) : bool) : Unit;
    #assert(#uEq(two_pow_64, ((u128 as std::ops::arith::WrappingMul<>)::wrapping_mul<> as λ(u128, u128) → u128)(one, two_pow_64)) : bool) : Unit;
    #assert(#uEq(zero, ((u128 as std::ops::arith::WrappingMul<>)::wrapping_mul<> as λ(u128, u128) → u128)(two_pow_64, two_pow_64)) : bool) : Unit;
    #assert(#uEq(one, ((u128 as std::ops::arith::WrappingMul<>)::wrapping_mul<> as λ(u128, u128) → u128)(u128_max, u128_max)) : bool) : Unit;
}


def Lib.env := Lampe.Env.mk [«as_witness», «assert_constant», «print_oracle», «print_unconstrained», «println», «print», «static_assert», «tests::test_static_assert_custom_message», «tests::test_wrapping_mul», «verify_proof_internal», «verify_proof_with_type», «verify_proof», «wrapping_add», «wrapping_mul», «wrapping_sub»] []