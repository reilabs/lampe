-- Generated by lampe

import «std-0.0.0».Extracted.GeneratedTypes
import Lampe

open Lampe

namespace «std-0.0.0»
namespace Extracted

nr_def «hash»::«sha256_compression»<>(input : [u32; 16], state : [u32; 8]) -> [u32; 8] {

}

nr_def «hash»::«keccakf1600»<>(input : [u64; 25]) -> [u64; 25] {

}

nr_def «hash»::«keccak»::«keccakf1600»<>(input : [u64; 25]) -> [u64; 25] {
    (@std::hash::keccakf1600<  > as λ([u64; 25]) → [u64; 25])(input);
}

nr_def «hash»::«blake2s»<@N : u32>(input : [u8; N]) -> [u8; 32] {

}

nr_def «hash»::«blake3»<@N : u32>(input : [u8; N]) -> [u8; 32] {
    if (@std::runtime::is_unconstrained<  > as λ() → bool)() {
            (@std::static_assert< str<74> > as λ(bool, str<74>) → Unit)(#uLeq(u@N, 1024 : u32) : bool, "Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes");
    };
    (@std::hash::__blake3< N:u32 > as λ([u8; N]) → [u8; 32])(input);
}

nr_def «hash»::«__blake3»<@N : u32>(input : [u8; N]) -> [u8; 32] {

}

nr_def «hash»::«pedersen_commitment»<@N : u32>(input : [Field; N]) -> embedded_curve_ops::EmbeddedCurvePoint<  > {
    (@std::hash::pedersen_commitment_with_separator< N:u32 > as λ([Field; N], u32) → embedded_curve_ops::EmbeddedCurvePoint<  >)(input, 0 : u32);
}

nr_def «hash»::«pedersen_commitment_with_separator»<@N : u32>(input : [Field; N], separator : u32) -> embedded_curve_ops::EmbeddedCurvePoint<  > {
    let mut points = [embedded_curve_ops::EmbeddedCurveScalar<  > { 0 : Field, 0 : Field } ; N];
    for i in 0 : u32 .. u@N {
            points[#cast(i) : u32] = (@std::hash::from_field_unsafe<  > as λ(Field) → embedded_curve_ops::EmbeddedCurveScalar<  >)(#arrayIndex(input, #cast(i) : u32) : Field);
        skip;
    };
    let generators = (@std::hash::derive_generators< N:u32, 24 : u32 > as λ([u8; 24], u32) → [embedded_curve_ops::EmbeddedCurvePoint<  >; N])((@str::as_bytes< 24 : u32 > as λ(str<24>) → [u8; 24])("DEFAULT_DOMAIN_SEPARATOR"), separator);
    (@std::embedded_curve_ops::multi_scalar_mul< N:u32 > as λ([embedded_curve_ops::EmbeddedCurvePoint<  >; N], [embedded_curve_ops::EmbeddedCurveScalar<  >; N]) → embedded_curve_ops::EmbeddedCurvePoint<  >)(generators, points);
}

nr_def «hash»::«pedersen_hash»<@N : u32>(input : [Field; N]) -> Field {
    (@std::hash::pedersen_hash_with_separator< N:u32 > as λ([Field; N], u32) → Field)(input, 0 : u32);
}

nr_def «hash»::«pedersen_hash_with_separator»<@N : u32>(input : [Field; N], separator : u32) -> Field {
    let mut scalars = [embedded_curve_ops::EmbeddedCurveScalar<  > { 0 : Field, 0 : Field } ; (N + 1)];
    let mut generators = [(@embedded_curve_ops::EmbeddedCurvePoint::point_at_infinity<  > as λ() → embedded_curve_ops::EmbeddedCurvePoint<  >)() ; (N + 1)];
    let domain_generators = (@std::hash::derive_generators< N:u32, 24 : u32 > as λ([u8; 24], u32) → [embedded_curve_ops::EmbeddedCurvePoint<  >; N])((@str::as_bytes< 24 : u32 > as λ(str<24>) → [u8; 24])("DEFAULT_DOMAIN_SEPARATOR"), separator);
    for i in 0 : u32 .. u@N {
            scalars[#cast(i) : u32] = (@std::hash::from_field_unsafe<  > as λ(Field) → embedded_curve_ops::EmbeddedCurveScalar<  >)(#arrayIndex(input, #cast(i) : u32) : Field);
        generators[#cast(i) : u32] = #arrayIndex(domain_generators, #cast(i) : u32) : embedded_curve_ops::EmbeddedCurvePoint<  >;
        skip;
    };
    scalars[#cast(u@N) : u32] = embedded_curve_ops::EmbeddedCurveScalar<  > { #cast(u@N) : Field, #cast(0 : Field) : Field };
    let length_generator = (@std::hash::derive_generators< 1 : u32, 20 : u32 > as λ([u8; 20], u32) → [embedded_curve_ops::EmbeddedCurvePoint<  >; 1])((@str::as_bytes< 20 : u32 > as λ(str<20>) → [u8; 20])("pedersen_hash_length"), 0 : u32);
    generators[#cast(u@N) : u32] = #arrayIndex(length_generator, #cast(0 : u32) : u32) : embedded_curve_ops::EmbeddedCurvePoint<  >;
    (#arrayIndex((@std::embedded_curve_ops::multi_scalar_mul_array_return< (N + 1) > as λ([embedded_curve_ops::EmbeddedCurvePoint<  >; (N + 1)], [embedded_curve_ops::EmbeddedCurveScalar<  >; (N + 1)]) → [embedded_curve_ops::EmbeddedCurvePoint<  >; 1])(generators, scalars), #cast(0 : u32) : u32) : embedded_curve_ops::EmbeddedCurvePoint<  > as embedded_curve_ops::EmbeddedCurvePoint<  >).x;
}

nr_def «hash»::«derive_generators»<@N : u32, @M : u32>(domain_separator_bytes : [u8; M], starting_index : u32) -> [embedded_curve_ops::EmbeddedCurvePoint<  >; N] {
    (@std::assert_constant< [u8; M] > as λ([u8; M]) → Unit)(domain_separator_bytes);
    (@std::hash::__derive_generators< N:u32, M:u32 > as λ([u8; M], u32) → [embedded_curve_ops::EmbeddedCurvePoint<  >; N])(domain_separator_bytes, starting_index);
}

nr_def «hash»::«__derive_generators»<@N : u32, @M : u32>(domain_separator_bytes : [u8; M], starting_index : u32) -> [embedded_curve_ops::EmbeddedCurvePoint<  >; N] {

}

nr_def «hash»::«from_field_unsafe»<>(scalar : Field) -> embedded_curve_ops::EmbeddedCurveScalar<  > {
    let π0 =     (@std::field::bn254::decompose_hint<  > as λ(Field) → `(Field, Field))(scalar);;
    let xlo = π0.0;
    let xhi = π0.1;
    #assert(#fEq(scalar, #fAdd(xlo, #fMul((@TWO_POW_128<  > as λ() → Field)(), xhi) : Field) : Field) : bool) : Unit;
    embedded_curve_ops::EmbeddedCurveScalar<  > { xlo, xhi };
}

nr_def «hash»::«hash_to_field»<>(inputs : [Field]) -> Field {
    let mut sum = 0 : Field;
        let ζi0 = inputs;
        for ζi1 in 0 : u32 .. (@std::slice::len< Field > as λ([Field]) → u32)(ζi0) {
                let input = #sliceIndex(ζi0, #cast(ζi1) : u32) : Field;
                let input_bytes = (@Field::to_le_bytes< 32 : u32 > as λ(Field) → [u8; 32])(input);
                sum = #fAdd(sum, (@std::field::bytes32_to_field<  > as λ([u8; 32]) → Field)((@std::hash::blake2s< 32 : u32 > as λ([u8; 32]) → [u8; 32])(input_bytes))) : Field;
                skip;
        };
    sum;
}

nr_def «hash»::«poseidon2_permutation»<@N : u32>(_input : [Field; N], _state_length : u32) -> [Field; N] {

}

nr_trait_impl[impl_2] <H> std::hash::BuildHasher<  > for hash::BuildHasherDefault< H > where H : Hasher<>, H : Default<> {
    fn «build_hasher»<> (_self : hash::BuildHasherDefault< H >) -> H {
        ((H as std::default::Default<  >)::default<  > as λ() → H)();
}
}

nr_trait_impl[impl_3] <H> std::default::Default<  > for hash::BuildHasherDefault< H > where H : Hasher<>, H : Default<> {
    fn «default»<> () -> hash::BuildHasherDefault< H > {
        hash::BuildHasherDefault< H > {  };
}
}

nr_trait_impl[impl_4] <> std::hash::Hash<  > for Field where  {
    fn «hash»<H> (self : Field, state : &H) -> Unit {
        ((H as std::hash::Hasher<  >)::write<  > as λ(&H, Field) → Unit)(state, self);
}
}

nr_trait_impl[impl_5] <> std::hash::Hash<  > for u1 where  {
    fn «hash»<H> (self : u1, state : &H) -> Unit {
        ((H as std::hash::Hasher<  >)::write<  > as λ(&H, Field) → Unit)(state, #cast(self) : Field);
}
}

nr_trait_impl[impl_6] <> std::hash::Hash<  > for u8 where  {
    fn «hash»<H> (self : u8, state : &H) -> Unit {
        ((H as std::hash::Hasher<  >)::write<  > as λ(&H, Field) → Unit)(state, #cast(self) : Field);
}
}

nr_trait_impl[impl_7] <> std::hash::Hash<  > for u16 where  {
    fn «hash»<H> (self : u16, state : &H) -> Unit {
        ((H as std::hash::Hasher<  >)::write<  > as λ(&H, Field) → Unit)(state, #cast(self) : Field);
}
}

nr_trait_impl[impl_8] <> std::hash::Hash<  > for u32 where  {
    fn «hash»<H> (self : u32, state : &H) -> Unit {
        ((H as std::hash::Hasher<  >)::write<  > as λ(&H, Field) → Unit)(state, #cast(self) : Field);
}
}

nr_trait_impl[impl_9] <> std::hash::Hash<  > for u64 where  {
    fn «hash»<H> (self : u64, state : &H) -> Unit {
        ((H as std::hash::Hasher<  >)::write<  > as λ(&H, Field) → Unit)(state, #cast(self) : Field);
}
}

nr_trait_impl[impl_10] <> std::hash::Hash<  > for u128 where  {
    fn «hash»<H> (self : u128, state : &H) -> Unit {
        ((H as std::hash::Hasher<  >)::write<  > as λ(&H, Field) → Unit)(state, #cast(self) : Field);
}
}

nr_trait_impl[impl_11] <> std::hash::Hash<  > for i8 where  {
    fn «hash»<H> (self : i8, state : &H) -> Unit {
        ((H as std::hash::Hasher<  >)::write<  > as λ(&H, Field) → Unit)(state, #cast(self) : Field);
}
}

nr_trait_impl[impl_12] <> std::hash::Hash<  > for i16 where  {
    fn «hash»<H> (self : i16, state : &H) -> Unit {
        ((H as std::hash::Hasher<  >)::write<  > as λ(&H, Field) → Unit)(state, #cast(self) : Field);
}
}

nr_trait_impl[impl_13] <> std::hash::Hash<  > for i32 where  {
    fn «hash»<H> (self : i32, state : &H) -> Unit {
        ((H as std::hash::Hasher<  >)::write<  > as λ(&H, Field) → Unit)(state, #cast(self) : Field);
}
}

nr_trait_impl[impl_14] <> std::hash::Hash<  > for i64 where  {
    fn «hash»<H> (self : i64, state : &H) -> Unit {
        ((H as std::hash::Hasher<  >)::write<  > as λ(&H, Field) → Unit)(state, #cast(self) : Field);
}
}

nr_trait_impl[impl_15] <> std::hash::Hash<  > for bool where  {
    fn «hash»<H> (self : bool, state : &H) -> Unit {
        ((H as std::hash::Hasher<  >)::write<  > as λ(&H, Field) → Unit)(state, #cast(self) : Field);
}
}

nr_trait_impl[impl_16] <> std::hash::Hash<  > for Unit where  {
    fn «hash»<H> (_self : Unit, _state : &H) -> Unit {

}
}

nr_trait_impl[impl_17] <N> std::hash::Hash<  > for [T; N] where T : Hash<> {
    fn «hash»<H> (self : [T; N], state : &H) -> Unit {
                let ζi0 = self;
                for ζi1 in 0 : u32 .. (@std::array::len< T, N:u32 > as λ([T; N]) → u32)(ζi0) {
                            let elem = #arrayIndex(ζi0, #cast(ζi1) : u32) : T;
                                ((T as std::hash::Hash<  >)::hash<  > as λ(T, &H) → Unit)(elem, state);
                };
}
}

nr_trait_impl[impl_18] <T> std::hash::Hash<  > for [T] where T : Hash<> {
    fn «hash»<H> (self : [T], state : &H) -> Unit {
        ((u32 as std::hash::Hash<  >)::hash<  > as λ(u32, &H) → Unit)((@std::slice::len< T > as λ([T]) → u32)(self), state);
                let ζi0 = self;
                for ζi1 in 0 : u32 .. (@std::slice::len< T > as λ([T]) → u32)(ζi0) {
                            let elem = #sliceIndex(ζi0, #cast(ζi1) : u32) : T;
                                ((T as std::hash::Hash<  >)::hash<  > as λ(T, &H) → Unit)(elem, state);
                };
}
}

nr_trait_impl[impl_19] <A, B> std::hash::Hash<  > for `(A, B) where A : Hash<>, B : Hash<> {
    fn «hash»<H> (self : `(A, B), state : &H) -> Unit {
        ((A as std::hash::Hash<  >)::hash<  > as λ(A, &H) → Unit)(self.0, state);
        ((B as std::hash::Hash<  >)::hash<  > as λ(B, &H) → Unit)(self.1, state);
}
}

nr_trait_impl[impl_20] <C, A, B> std::hash::Hash<  > for `(A, B, C) where A : Hash<>, B : Hash<>, C : Hash<> {
    fn «hash»<H> (self : `(A, B, C), state : &H) -> Unit {
        ((A as std::hash::Hash<  >)::hash<  > as λ(A, &H) → Unit)(self.0, state);
        ((B as std::hash::Hash<  >)::hash<  > as λ(B, &H) → Unit)(self.1, state);
        ((C as std::hash::Hash<  >)::hash<  > as λ(C, &H) → Unit)(self.2, state);
}
}

nr_trait_impl[impl_21] <A, D, B, C> std::hash::Hash<  > for `(A, B, C, D) where A : Hash<>, B : Hash<>, C : Hash<>, D : Hash<> {
    fn «hash»<H> (self : `(A, B, C, D), state : &H) -> Unit {
        ((A as std::hash::Hash<  >)::hash<  > as λ(A, &H) → Unit)(self.0, state);
        ((B as std::hash::Hash<  >)::hash<  > as λ(B, &H) → Unit)(self.1, state);
        ((C as std::hash::Hash<  >)::hash<  > as λ(C, &H) → Unit)(self.2, state);
        ((D as std::hash::Hash<  >)::hash<  > as λ(D, &H) → Unit)(self.3, state);
}
}

nr_trait_impl[impl_22] <A, C, D, B, E> std::hash::Hash<  > for `(A, B, C, D, E) where A : Hash<>, B : Hash<>, C : Hash<>, D : Hash<>, E : Hash<> {
    fn «hash»<H> (self : `(A, B, C, D, E), state : &H) -> Unit {
        ((A as std::hash::Hash<  >)::hash<  > as λ(A, &H) → Unit)(self.0, state);
        ((B as std::hash::Hash<  >)::hash<  > as λ(B, &H) → Unit)(self.1, state);
        ((C as std::hash::Hash<  >)::hash<  > as λ(C, &H) → Unit)(self.2, state);
        ((D as std::hash::Hash<  >)::hash<  > as λ(D, &H) → Unit)(self.3, state);
        ((E as std::hash::Hash<  >)::hash<  > as λ(E, &H) → Unit)(self.4, state);
}
}

nr_def «hash»::«assert_pedersen»<>() -> Unit {
    #assert(#fEq((@std::hash::pedersen_hash_with_separator< 1 : u32 > as λ([Field; 1], u32) → Field)(#mkArray(1 : Field) : [Field; 1], 1 : u32), -9563966249275741675388072609438711537348680428347819854678797696612266004386 : Field) : bool) : Unit;
    #assert(((embedded_curve_ops::EmbeddedCurvePoint<  > as Eq<  >)::eq<  > as λ(embedded_curve_ops::EmbeddedCurvePoint<  >, embedded_curve_ops::EmbeddedCurvePoint<  >) → bool)((@std::hash::pedersen_commitment_with_separator< 1 : u32 > as λ([Field; 1], u32) → embedded_curve_ops::EmbeddedCurvePoint<  >)(#mkArray(1 : Field) : [Field; 1], 1 : u32), embedded_curve_ops::EmbeddedCurvePoint<  > { 2393473289045184898987089634332637236754766663897650125720167164137088869378 : Field, -7135402912423807765050323395026152633898511180575289670895350565966806597339 : Field, false })) : Unit;
    #assert(#fEq((@std::hash::pedersen_hash_with_separator< 2 : u32 > as λ([Field; 2], u32) → Field)(#mkArray(1 : Field, 2 : Field) : [Field; 2], 2 : u32), -4514641934080458214240751313245257091597283372119704256508270041112972328364 : Field) : bool) : Unit;
    #assert(((embedded_curve_ops::EmbeddedCurvePoint<  > as Eq<  >)::eq<  > as λ(embedded_curve_ops::EmbeddedCurvePoint<  >, embedded_curve_ops::EmbeddedCurvePoint<  >) → bool)((@std::hash::pedersen_commitment_with_separator< 2 : u32 > as λ([Field; 2], u32) → embedded_curve_ops::EmbeddedCurvePoint<  >)(#mkArray(1 : Field, 2 : Field) : [Field; 2], 2 : u32), embedded_curve_ops::EmbeddedCurvePoint<  > { -1005469533000889117657666498472954572857833872027279582301287737791321798830 : Field, -197930408253518363600434091261593976805802346006803044607495721019065268361 : Field, false })) : Unit;
    #assert(#fEq((@std::hash::pedersen_hash_with_separator< 3 : u32 > as λ([Field; 3], u32) → Field)(#mkArray(1 : Field, 2 : Field, 3 : Field) : [Field; 3], 3 : u32), 5326303462429251635333445553787815334884504473158538697533567972354818497508 : Field) : bool) : Unit;
    #assert(((embedded_curve_ops::EmbeddedCurvePoint<  > as Eq<  >)::eq<  > as λ(embedded_curve_ops::EmbeddedCurvePoint<  >, embedded_curve_ops::EmbeddedCurvePoint<  >) → bool)((@std::hash::pedersen_commitment_with_separator< 3 : u32 > as λ([Field; 3], u32) → embedded_curve_ops::EmbeddedCurvePoint<  >)(#mkArray(1 : Field, 2 : Field, 3 : Field) : [Field; 3], 3 : u32), embedded_curve_ops::EmbeddedCurvePoint<  > { -7445492827528947374509602945629683494533192071041804482180938699494227714940 : Field, -346969586742294743999106690738565516862306986837138292504091779330690805808 : Field, false })) : Unit;
    #assert(#fEq((@std::hash::pedersen_hash_with_separator< 4 : u32 > as λ([Field; 4], u32) → Field)(#mkArray(1 : Field, 2 : Field, 3 : Field, 4 : Field) : [Field; 4], 4 : u32), 386725976317305842536127973743796063021078557104668993698335256486699462108 : Field) : bool) : Unit;
    #assert(((embedded_curve_ops::EmbeddedCurvePoint<  > as Eq<  >)::eq<  > as λ(embedded_curve_ops::EmbeddedCurvePoint<  >, embedded_curve_ops::EmbeddedCurvePoint<  >) → bool)((@std::hash::pedersen_commitment_with_separator< 4 : u32 > as λ([Field; 4], u32) → embedded_curve_ops::EmbeddedCurvePoint<  >)(#mkArray(1 : Field, 2 : Field, 3 : Field, 4 : Field) : [Field; 4], 4 : u32), embedded_curve_ops::EmbeddedCurvePoint<  > { 3474050104565946163748262682994355436071725368663608454945085151569694677961 : Field, 4969143737471383592015577254419974288705429190161323890019554309538525237268 : Field, false })) : Unit;
    #assert(#fEq((@std::hash::pedersen_hash_with_separator< 5 : u32 > as λ([Field; 5], u32) → Field)(#mkArray(1 : Field, 2 : Field, 3 : Field, 4 : Field, 5 : Field) : [Field; 5], 5 : u32), 445627510378474786942205982382342880084933256779806571759234109296077544482 : Field) : bool) : Unit;
    #assert(((embedded_curve_ops::EmbeddedCurvePoint<  > as Eq<  >)::eq<  > as λ(embedded_curve_ops::EmbeddedCurvePoint<  >, embedded_curve_ops::EmbeddedCurvePoint<  >) → bool)((@std::hash::pedersen_commitment_with_separator< 5 : u32 > as λ([Field; 5], u32) → embedded_curve_ops::EmbeddedCurvePoint<  >)(#mkArray(1 : Field, 2 : Field, 3 : Field, 4 : Field, 5 : Field) : [Field; 5], 5 : u32), embedded_curve_ops::EmbeddedCurvePoint<  > { 10552833461612204383225982278685649771700648236894998952452362214619168226089 : Field, -1251131729610909206337824637802607977413231765663205492654376476649374713610 : Field, false })) : Unit;
    #assert(#fEq((@std::hash::pedersen_hash_with_separator< 6 : u32 > as λ([Field; 6], u32) → Field)(#mkArray(1 : Field, 2 : Field, 3 : Field, 4 : Field, 5 : Field, 6 : Field) : [Field; 6], 6 : u32), 10217545977856619241380062255630350521414270790482717416408002401121937565042 : Field) : bool) : Unit;
    #assert(((embedded_curve_ops::EmbeddedCurvePoint<  > as Eq<  >)::eq<  > as λ(embedded_curve_ops::EmbeddedCurvePoint<  >, embedded_curve_ops::EmbeddedCurvePoint<  >) → bool)((@std::hash::pedersen_commitment_with_separator< 6 : u32 > as λ([Field; 6], u32) → embedded_curve_ops::EmbeddedCurvePoint<  >)(#mkArray(1 : Field, 2 : Field, 3 : Field, 4 : Field, 5 : Field, 6 : Field) : [Field; 6], 6 : u32), embedded_curve_ops::EmbeddedCurvePoint<  > { 11335069702571578236117888955050736139682779524214984889155721704928197387927 : Field, -7733361908666485801415200275635877656445756448956549185022038133647049615622 : Field, false })) : Unit;
    #assert(#fEq((@std::hash::pedersen_hash_with_separator< 7 : u32 > as λ([Field; 7], u32) → Field)(#mkArray(1 : Field, 2 : Field, 3 : Field, 4 : Field, 5 : Field, 6 : Field, 7 : Field) : [Field; 7], 7 : u32), 8389099894375185114295483291630893019224023442848409888108611454294869536227 : Field) : bool) : Unit;
    #assert(((embedded_curve_ops::EmbeddedCurvePoint<  > as Eq<  >)::eq<  > as λ(embedded_curve_ops::EmbeddedCurvePoint<  >, embedded_curve_ops::EmbeddedCurvePoint<  >) → bool)((@std::hash::pedersen_commitment_with_separator< 7 : u32 > as λ([Field; 7], u32) → embedded_curve_ops::EmbeddedCurvePoint<  >)(#mkArray(1 : Field, 2 : Field, 3 : Field, 4 : Field, 5 : Field, 6 : Field, 7 : Field) : [Field; 7], 7 : u32), embedded_curve_ops::EmbeddedCurvePoint<  > { 601182919381464537093882307577577658521785998356796832152269409048770009401 : Field, -8704984668101593449807889537070046830501821124601109099832679891796819531525 : Field, false })) : Unit;
    #assert(#fEq((@std::hash::pedersen_hash_with_separator< 8 : u32 > as λ([Field; 8], u32) → Field)(#mkArray(1 : Field, 2 : Field, 3 : Field, 4 : Field, 5 : Field, 6 : Field, 7 : Field, 8 : Field) : [Field; 8], 8 : u32), -364414833671337260860436705614307386127212237115043515297237560718972836517 : Field) : bool) : Unit;
    #assert(((embedded_curve_ops::EmbeddedCurvePoint<  > as Eq<  >)::eq<  > as λ(embedded_curve_ops::EmbeddedCurvePoint<  >, embedded_curve_ops::EmbeddedCurvePoint<  >) → bool)((@std::hash::pedersen_commitment_with_separator< 8 : u32 > as λ([Field; 8], u32) → embedded_curve_ops::EmbeddedCurvePoint<  >)(#mkArray(1 : Field, 2 : Field, 3 : Field, 4 : Field, 5 : Field, 6 : Field, 7 : Field, 8 : Field) : [Field; 8], 8 : u32), embedded_curve_ops::EmbeddedCurvePoint<  > { 10105395258059943854471547573391327707179901153940064586773125525172385465411 : Field, -7764172381957047914625405480055519449068901615240110013280942913930205438090 : Field, false })) : Unit;
    #assert(#fEq((@std::hash::pedersen_hash_with_separator< 9 : u32 > as λ([Field; 9], u32) → Field)(#mkArray(1 : Field, 2 : Field, 3 : Field, 4 : Field, 5 : Field, 6 : Field, 7 : Field, 8 : Field, 9 : Field) : [Field; 9], 9 : u32), 5694292929090063810102755351119629986122166830204542196709417013467308391399 : Field) : bool) : Unit;
    #assert(((embedded_curve_ops::EmbeddedCurvePoint<  > as Eq<  >)::eq<  > as λ(embedded_curve_ops::EmbeddedCurvePoint<  >, embedded_curve_ops::EmbeddedCurvePoint<  >) → bool)((@std::hash::pedersen_commitment_with_separator< 9 : u32 > as λ([Field; 9], u32) → embedded_curve_ops::EmbeddedCurvePoint<  >)(#mkArray(1 : Field, 2 : Field, 3 : Field, 4 : Field, 5 : Field, 6 : Field, 7 : Field, 8 : Field, 9 : Field) : [Field; 9], 9 : u32), embedded_curve_ops::EmbeddedCurvePoint<  > { 4630760469979870165820917922898436050077118370325830990580986530746633543789 : Field, 445421188486227550820408419830973545028032672242093648088931561027838255858 : Field, false })) : Unit;
    #assert(#fEq((@std::hash::pedersen_hash_with_separator< 10 : u32 > as λ([Field; 10], u32) → Field)(#mkArray(1 : Field, 2 : Field, 3 : Field, 4 : Field, 5 : Field, 6 : Field, 7 : Field, 8 : Field, 9 : Field, 10 : Field) : [Field; 10], 10 : u32), -1612865150156425111011383725280441289912228955196006102547487828548180279661 : Field) : bool) : Unit;
    #assert(((embedded_curve_ops::EmbeddedCurvePoint<  > as Eq<  >)::eq<  > as λ(embedded_curve_ops::EmbeddedCurvePoint<  >, embedded_curve_ops::EmbeddedCurvePoint<  >) → bool)((@std::hash::pedersen_commitment_with_separator< 10 : u32 > as λ([Field; 10], u32) → embedded_curve_ops::EmbeddedCurvePoint<  >)(#mkArray(1 : Field, 2 : Field, 3 : Field, 4 : Field, 5 : Field, 6 : Field, 7 : Field, 8 : Field, 9 : Field, 10 : Field) : [Field; 10], 10 : u32), embedded_curve_ops::EmbeddedCurvePoint<  > { -311556882567474412576811669014419164866085063813982345701073780395111226613 : Field, -163948955461070038478898748306472919392980231474444415480716967232318545340 : Field, false })) : Unit;
}


def Hash.Mod.env := Lampe.Env.mk [«hash::__blake3», «hash::__derive_generators», «hash::assert_pedersen», «hash::blake2s», «hash::blake3», «hash::derive_generators», «hash::from_field_unsafe», «hash::hash_to_field», «hash::keccak::keccakf1600», «hash::keccakf1600», «hash::pedersen_commitment_with_separator», «hash::pedersen_commitment», «hash::pedersen_hash_with_separator», «hash::pedersen_hash», «hash::poseidon2_permutation», «hash::sha256_compression»] [impl_10, impl_11, impl_12, impl_13, impl_14, impl_15, impl_16, impl_17, impl_18, impl_19, impl_2, impl_20, impl_21, impl_22, impl_3, impl_4, impl_5, impl_6, impl_7, impl_8, impl_9]