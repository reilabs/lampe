-- Generated by lampe

import «std-0.0.0».Extracted.GeneratedTypes
import Lampe

open Lampe

namespace «std-0.0.0»
namespace Extracted

nr_def «hash»::«sha256_compression»<>(input : [u32; 16], state : [u32; 8]) -> [u32; 8] {

}

nr_def «hash»::«keccakf1600»<>(input : [u64; 25]) -> [u64; 25] {

}

nr_def «hash»::«keccak»::«keccakf1600»<>(input : [u64; 25]) -> [u64; 25] {
    (@std::hash::keccakf1600<  > as λ([u64; 25]) → [u64; 25])(input);
}

nr_def «hash»::«blake2s»<@N : u32>(input : [u8; N]) -> [u8; 32] {

}

nr_def «hash»::«blake3»<@N : u32>(input : [u8; N]) -> [u8; 32] {
    if (@std::runtime::is_unconstrained<  > as λ() → bool)() {
            (@std::static_assert< str<74> > as λ(bool, str<74>) → Unit)(#uLeq(u@N, 1024 : u32) : bool, "Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes");
    };
    (@std::hash::__blake3< N:u32 > as λ([u8; N]) → [u8; 32])(input);
}

nr_def «hash»::«__blake3»<@N : u32>(input : [u8; N]) -> [u8; 32] {

}

nr_def «hash»::«pedersen_commitment»<@N : u32>(input : [Field; N]) -> embedded_curve_ops::EmbeddedCurvePoint<  > {
    (@std::hash::pedersen_commitment_with_separator< N:u32 > as λ([Field; N], u32) → embedded_curve_ops::EmbeddedCurvePoint<  >)(input, 0 : u32);
}

nr_def «hash»::«pedersen_commitment_with_separator»<@N : u32>(input : [Field; N], separator : u32) -> embedded_curve_ops::EmbeddedCurvePoint<  > {
    let mut points = [embedded_curve_ops::EmbeddedCurveScalar<  > { 0 : Field, 0 : Field } ; N];
    for i in 0 : u32 .. u@N {
            points[#cast(i) : u32] = (@std::hash::from_field_unsafe<  > as λ(Field) → embedded_curve_ops::EmbeddedCurveScalar<  >)(#arrayIndex(input, #cast(i) : u32) : Field);
        skip;
    };
    let generators = (@std::hash::derive_generators< N:u32, 24 : u32 > as λ([u8; 24], u32) → [embedded_curve_ops::EmbeddedCurvePoint<  >; N])((@str::as_bytes< 24 : u32 > as λ(str<24>) → [u8; 24])("DEFAULT_DOMAIN_SEPARATOR"), separator);
    (@std::embedded_curve_ops::multi_scalar_mul< N:u32 > as λ([embedded_curve_ops::EmbeddedCurvePoint<  >; N], [embedded_curve_ops::EmbeddedCurveScalar<  >; N]) → embedded_curve_ops::EmbeddedCurvePoint<  >)(generators, points);
}

nr_def «hash»::«pedersen_hash»<@N : u32>(input : [Field; N]) -> Field {
    (@std::hash::pedersen_hash_with_separator< N:u32 > as λ([Field; N], u32) → Field)(input, 0 : u32);
}

nr_def «hash»::«pedersen_hash_with_separator»<@N : u32>(input : [Field; N], separator : u32) -> Field {
    let mut scalars = [embedded_curve_ops::EmbeddedCurveScalar<  > { 0 : Field, 0 : Field } ; (N + 1)];
    let mut generators = [(@embedded_curve_ops::EmbeddedCurvePoint::point_at_infinity<  > as λ() → embedded_curve_ops::EmbeddedCurvePoint<  >)() ; (N + 1)];
    let domain_generators = (@std::hash::derive_generators< N:u32, 24 : u32 > as λ([u8; 24], u32) → [embedded_curve_ops::EmbeddedCurvePoint<  >; N])((@str::as_bytes< 24 : u32 > as λ(str<24>) → [u8; 24])("DEFAULT_DOMAIN_SEPARATOR"), separator);
    for i in 0 : u32 .. u@N {
            scalars[#cast(i) : u32] = (@std::hash::from_field_unsafe<  > as λ(Field) → embedded_curve_ops::EmbeddedCurveScalar<  >)(#arrayIndex(input, #cast(i) : u32) : Field);
        generators[#cast(i) : u32] = #arrayIndex(domain_generators, #cast(i) : u32) : embedded_curve_ops::EmbeddedCurvePoint<  >;
        skip;
    };
    scalars[#cast(u@N) : u32] = embedded_curve_ops::EmbeddedCurveScalar<  > { #cast(u@N) : Field, #cast(0 : Field) : Field };
    let length_generator = (@std::hash::derive_generators< 1 : u32, 20 : u32 > as λ([u8; 20], u32) → [embedded_curve_ops::EmbeddedCurvePoint<  >; 1])((@str::as_bytes< 20 : u32 > as λ(str<20>) → [u8; 20])("pedersen_hash_length"), 0 : u32);
    generators[#cast(u@N) : u32] = #arrayIndex(length_generator, #cast(0 : u32) : u32) : embedded_curve_ops::EmbeddedCurvePoint<  >;
    (#arrayIndex((@std::embedded_curve_ops::multi_scalar_mul_array_return< (N + 1) > as λ([embedded_curve_ops::EmbeddedCurvePoint<  >; (N + 1)], [embedded_curve_ops::EmbeddedCurveScalar<  >; (N + 1)]) → [embedded_curve_ops::EmbeddedCurvePoint<  >; 1])(generators, scalars), #cast(0 : u32) : u32) : embedded_curve_ops::EmbeddedCurvePoint<  > as embedded_curve_ops::EmbeddedCurvePoint<  >).x;
}

nr_def «hash»::«derive_generators»<@N : u32, @M : u32>(domain_separator_bytes : [u8; M], starting_index : u32) -> [embedded_curve_ops::EmbeddedCurvePoint<  >; N] {
    (@std::assert_constant< [u8; M] > as λ([u8; M]) → Unit)(domain_separator_bytes);
    (@std::hash::__derive_generators< N:u32, M:u32 > as λ([u8; M], u32) → [embedded_curve_ops::EmbeddedCurvePoint<  >; N])(domain_separator_bytes, starting_index);
}

nr_def «hash»::«__derive_generators»<@N : u32, @M : u32>(domain_separator_bytes : [u8; M], starting_index : u32) -> [embedded_curve_ops::EmbeddedCurvePoint<  >; N] {

}

nr_def «hash»::«from_field_unsafe»<>(scalar : Field) -> embedded_curve_ops::EmbeddedCurveScalar<  > {
    let π0 =     (@std::field::bn254::decompose_hint<  > as λ(Field) → `(Field, Field))(scalar);;
    let xlo = π0.0;
    let xhi = π0.1;
    #assert(#fEq(scalar, #fAdd(xlo, #fMul((@TWO_POW_128<  > as λ() → Field)(), xhi) : Field) : Field) : bool) : Unit;
    embedded_curve_ops::EmbeddedCurveScalar<  > { xlo, xhi };
}

nr_def «hash»::«hash_to_field»<>(inputs : [Field]) -> Field {
    let mut sum = 0 : Field;
        let ζi0 = inputs;
        for ζi1 in 0 : u32 .. #sliceLen(ζi0) : u32 {
                let input = #sliceIndex(ζi0, #cast(ζi1) : u32) : Field;
                let input_bytes = (@Field::to_le_bytes< 32 : u32 > as λ(Field) → [u8; 32])(input);
                sum = #fAdd(sum, (@std::field::bytes32_to_field<  > as λ([u8; 32]) → Field)((@std::hash::blake2s< 32 : u32 > as λ([u8; 32]) → [u8; 32])(input_bytes))) : Field;
                skip;
        };
    sum;
}

nr_def «hash»::«poseidon2_permutation»<@N : u32>(_input : [Field; N], _state_length : u32) -> [Field; N] {

}

nr_trait_impl[impl_2] <H> std::hash::BuildHasher<  > for hash::BuildHasherDefault< H > where H : Hasher<>, H : Default<> {
    fn «build_hasher»<> (_self : hash::BuildHasherDefault< H >) -> H {
        ((H as std::default::Default<  >)::default<  > as λ() → H)();
}
}

nr_trait_impl[impl_3] <H> std::default::Default<  > for hash::BuildHasherDefault< H > where H : Hasher<>, H : Default<> {
    fn «default»<> () -> hash::BuildHasherDefault< H > {
        hash::BuildHasherDefault< H > {  };
}
}

nr_trait_impl[impl_4] <> std::hash::Hash<  > for Field where  {
    fn «hash»<H> (self : Field, state : &H) -> Unit {
        ((H as std::hash::Hasher<  >)::write<  > as λ(&H, Field) → Unit)(state, self);
}
}

nr_trait_impl[impl_5] <> std::hash::Hash<  > for u1 where  {
    fn «hash»<H> (self : u1, state : &H) -> Unit {
        ((H as std::hash::Hasher<  >)::write<  > as λ(&H, Field) → Unit)(state, #cast(self) : Field);
}
}

nr_trait_impl[impl_6] <> std::hash::Hash<  > for u8 where  {
    fn «hash»<H> (self : u8, state : &H) -> Unit {
        ((H as std::hash::Hasher<  >)::write<  > as λ(&H, Field) → Unit)(state, #cast(self) : Field);
}
}

nr_trait_impl[impl_7] <> std::hash::Hash<  > for u16 where  {
    fn «hash»<H> (self : u16, state : &H) -> Unit {
        ((H as std::hash::Hasher<  >)::write<  > as λ(&H, Field) → Unit)(state, #cast(self) : Field);
}
}

nr_trait_impl[impl_8] <> std::hash::Hash<  > for u32 where  {
    fn «hash»<H> (self : u32, state : &H) -> Unit {
        ((H as std::hash::Hasher<  >)::write<  > as λ(&H, Field) → Unit)(state, #cast(self) : Field);
}
}

nr_trait_impl[impl_9] <> std::hash::Hash<  > for u64 where  {
    fn «hash»<H> (self : u64, state : &H) -> Unit {
        ((H as std::hash::Hasher<  >)::write<  > as λ(&H, Field) → Unit)(state, #cast(self) : Field);
}
}

nr_trait_impl[impl_10] <> std::hash::Hash<  > for u128 where  {
    fn «hash»<H> (self : u128, state : &H) -> Unit {
        ((H as std::hash::Hasher<  >)::write<  > as λ(&H, Field) → Unit)(state, #cast(self) : Field);
}
}

nr_trait_impl[impl_11] <> std::hash::Hash<  > for i8 where  {
    fn «hash»<H> (self : i8, state : &H) -> Unit {
        ((H as std::hash::Hasher<  >)::write<  > as λ(&H, Field) → Unit)(state, #cast(self) : Field);
}
}

nr_trait_impl[impl_12] <> std::hash::Hash<  > for i16 where  {
    fn «hash»<H> (self : i16, state : &H) -> Unit {
        ((H as std::hash::Hasher<  >)::write<  > as λ(&H, Field) → Unit)(state, #cast(self) : Field);
}
}

nr_trait_impl[impl_13] <> std::hash::Hash<  > for i32 where  {
    fn «hash»<H> (self : i32, state : &H) -> Unit {
        ((H as std::hash::Hasher<  >)::write<  > as λ(&H, Field) → Unit)(state, #cast(self) : Field);
}
}

nr_trait_impl[impl_14] <> std::hash::Hash<  > for i64 where  {
    fn «hash»<H> (self : i64, state : &H) -> Unit {
        ((H as std::hash::Hasher<  >)::write<  > as λ(&H, Field) → Unit)(state, #cast(self) : Field);
}
}

nr_trait_impl[impl_15] <> std::hash::Hash<  > for bool where  {
    fn «hash»<H> (self : bool, state : &H) -> Unit {
        ((H as std::hash::Hasher<  >)::write<  > as λ(&H, Field) → Unit)(state, #cast(self) : Field);
}
}

nr_trait_impl[impl_16] <> std::hash::Hash<  > for Unit where  {
    fn «hash»<H> (_self : Unit, _state : &H) -> Unit {

}
}

nr_trait_impl[impl_17] <N> std::hash::Hash<  > for [T; N] where T : Hash<> {
    fn «hash»<H> (self : [T; N], state : &H) -> Unit {
                let ζi0 = self;
                for ζi1 in 0 : u32 .. #arrayLen(ζi0) : u32 {
                            let elem = #arrayIndex(ζi0, #cast(ζi1) : u32) : T;
                                ((T as std::hash::Hash<  >)::hash<  > as λ(T, &H) → Unit)(elem, state);
                };
}
}

nr_trait_impl[impl_18] <T> std::hash::Hash<  > for [T] where T : Hash<> {
    fn «hash»<H> (self : [T], state : &H) -> Unit {
        ((u32 as std::hash::Hash<  >)::hash<  > as λ(u32, &H) → Unit)(#sliceLen(self) : u32, state);
                let ζi0 = self;
                for ζi1 in 0 : u32 .. #sliceLen(ζi0) : u32 {
                            let elem = #sliceIndex(ζi0, #cast(ζi1) : u32) : T;
                                ((T as std::hash::Hash<  >)::hash<  > as λ(T, &H) → Unit)(elem, state);
                };
}
}

nr_trait_impl[impl_19] <A, B> std::hash::Hash<  > for `(A, B) where A : Hash<>, B : Hash<> {
    fn «hash»<H> (self : `(A, B), state : &H) -> Unit {
        ((A as std::hash::Hash<  >)::hash<  > as λ(A, &H) → Unit)(self.0, state);
        ((B as std::hash::Hash<  >)::hash<  > as λ(B, &H) → Unit)(self.1, state);
}
}

nr_trait_impl[impl_20] <B, A, C> std::hash::Hash<  > for `(A, B, C) where A : Hash<>, B : Hash<>, C : Hash<> {
    fn «hash»<H> (self : `(A, B, C), state : &H) -> Unit {
        ((A as std::hash::Hash<  >)::hash<  > as λ(A, &H) → Unit)(self.0, state);
        ((B as std::hash::Hash<  >)::hash<  > as λ(B, &H) → Unit)(self.1, state);
        ((C as std::hash::Hash<  >)::hash<  > as λ(C, &H) → Unit)(self.2, state);
}
}

nr_trait_impl[impl_21] <B, A, D, C> std::hash::Hash<  > for `(A, B, C, D) where A : Hash<>, B : Hash<>, C : Hash<>, D : Hash<> {
    fn «hash»<H> (self : `(A, B, C, D), state : &H) -> Unit {
        ((A as std::hash::Hash<  >)::hash<  > as λ(A, &H) → Unit)(self.0, state);
        ((B as std::hash::Hash<  >)::hash<  > as λ(B, &H) → Unit)(self.1, state);
        ((C as std::hash::Hash<  >)::hash<  > as λ(C, &H) → Unit)(self.2, state);
        ((D as std::hash::Hash<  >)::hash<  > as λ(D, &H) → Unit)(self.3, state);
}
}

nr_trait_impl[impl_22] <D, B, A, C, E> std::hash::Hash<  > for `(A, B, C, D, E) where A : Hash<>, B : Hash<>, C : Hash<>, D : Hash<>, E : Hash<> {
    fn «hash»<H> (self : `(A, B, C, D, E), state : &H) -> Unit {
        ((A as std::hash::Hash<  >)::hash<  > as λ(A, &H) → Unit)(self.0, state);
        ((B as std::hash::Hash<  >)::hash<  > as λ(B, &H) → Unit)(self.1, state);
        ((C as std::hash::Hash<  >)::hash<  > as λ(C, &H) → Unit)(self.2, state);
        ((D as std::hash::Hash<  >)::hash<  > as λ(D, &H) → Unit)(self.3, state);
        ((E as std::hash::Hash<  >)::hash<  > as λ(E, &H) → Unit)(self.4, state);
}
}

nr_def «hash»::«assert_pedersen»<>() -> Unit {
    #assert(#fEq((@std::hash::pedersen_hash_with_separator< 1 : u32 > as λ([Field; 1], u32) → Field)([1 : Field], 1 : u32), -9563966249275741675388072609438711537348680428347819854678797696612266004386 : Field) : bool) : Unit;
    #assert(((embedded_curve_ops::EmbeddedCurvePoint<  > as Eq<  >)::eq<  > as λ(embedded_curve_ops::EmbeddedCurvePoint<  >, embedded_curve_ops::EmbeddedCurvePoint<  >) → bool)(embedded_curve_ops::EmbeddedCurvePoint<  >, embedded_curve_ops::EmbeddedCurvePoint<  >)) : Unit;
    #assert(#fEq((@std::hash::pedersen_hash_with_separator< 2 : u32 > as λ([Field; 2], u32) → Field)([1 : Field, 2 : Field], 2 : u32), -4514641934080458214240751313245257091597283372119704256508270041112972328364 : Field) : bool) : Unit;
    #assert(((embedded_curve_ops::EmbeddedCurvePoint<  > as Eq<  >)::eq<  > as λ(embedded_curve_ops::EmbeddedCurvePoint<  >, embedded_curve_ops::EmbeddedCurvePoint<  >) → bool)(embedded_curve_ops::EmbeddedCurvePoint<  >, embedded_curve_ops::EmbeddedCurvePoint<  >)) : Unit;
    #assert(#fEq((@std::hash::pedersen_hash_with_separator< 3 : u32 > as λ([Field; 3], u32) → Field)([1 : Field, 2 : Field, 3 : Field], 3 : u32), 5326303462429251635333445553787815334884504473158538697533567972354818497508 : Field) : bool) : Unit;
    #assert(((embedded_curve_ops::EmbeddedCurvePoint<  > as Eq<  >)::eq<  > as λ(embedded_curve_ops::EmbeddedCurvePoint<  >, embedded_curve_ops::EmbeddedCurvePoint<  >) → bool)(embedded_curve_ops::EmbeddedCurvePoint<  >, embedded_curve_ops::EmbeddedCurvePoint<  >)) : Unit;
    #assert(#fEq((@std::hash::pedersen_hash_with_separator< 4 : u32 > as λ([Field; 4], u32) → Field)([1 : Field, 2 : Field, 3 : Field, 4 : Field], 4 : u32), 386725976317305842536127973743796063021078557104668993698335256486699462108 : Field) : bool) : Unit;
    #assert(((embedded_curve_ops::EmbeddedCurvePoint<  > as Eq<  >)::eq<  > as λ(embedded_curve_ops::EmbeddedCurvePoint<  >, embedded_curve_ops::EmbeddedCurvePoint<  >) → bool)(embedded_curve_ops::EmbeddedCurvePoint<  >, embedded_curve_ops::EmbeddedCurvePoint<  >)) : Unit;
    #assert(#fEq((@std::hash::pedersen_hash_with_separator< 5 : u32 > as λ([Field; 5], u32) → Field)([1 : Field, 2 : Field, 3 : Field, 4 : Field, 5 : Field], 5 : u32), 445627510378474786942205982382342880084933256779806571759234109296077544482 : Field) : bool) : Unit;
    #assert(((embedded_curve_ops::EmbeddedCurvePoint<  > as Eq<  >)::eq<  > as λ(embedded_curve_ops::EmbeddedCurvePoint<  >, embedded_curve_ops::EmbeddedCurvePoint<  >) → bool)(embedded_curve_ops::EmbeddedCurvePoint<  >, embedded_curve_ops::EmbeddedCurvePoint<  >)) : Unit;
    #assert(#fEq((@std::hash::pedersen_hash_with_separator< 6 : u32 > as λ([Field; 6], u32) → Field)([1 : Field, 2 : Field, 3 : Field, 4 : Field, 5 : Field, 6 : Field], 6 : u32), 10217545977856619241380062255630350521414270790482717416408002401121937565042 : Field) : bool) : Unit;
    #assert(((embedded_curve_ops::EmbeddedCurvePoint<  > as Eq<  >)::eq<  > as λ(embedded_curve_ops::EmbeddedCurvePoint<  >, embedded_curve_ops::EmbeddedCurvePoint<  >) → bool)(embedded_curve_ops::EmbeddedCurvePoint<  >, embedded_curve_ops::EmbeddedCurvePoint<  >)) : Unit;
    #assert(#fEq((@std::hash::pedersen_hash_with_separator< 7 : u32 > as λ([Field; 7], u32) → Field)([1 : Field, 2 : Field, 3 : Field, 4 : Field, 5 : Field, 6 : Field, 7 : Field], 7 : u32), 8389099894375185114295483291630893019224023442848409888108611454294869536227 : Field) : bool) : Unit;
    #assert(((embedded_curve_ops::EmbeddedCurvePoint<  > as Eq<  >)::eq<  > as λ(embedded_curve_ops::EmbeddedCurvePoint<  >, embedded_curve_ops::EmbeddedCurvePoint<  >) → bool)(embedded_curve_ops::EmbeddedCurvePoint<  >, embedded_curve_ops::EmbeddedCurvePoint<  >)) : Unit;
    #assert(#fEq((@std::hash::pedersen_hash_with_separator< 8 : u32 > as λ([Field; 8], u32) → Field)([1 : Field, 2 : Field, 3 : Field, 4 : Field, 5 : Field, 6 : Field, 7 : Field, 8 : Field], 8 : u32), -364414833671337260860436705614307386127212237115043515297237560718972836517 : Field) : bool) : Unit;
    #assert(((embedded_curve_ops::EmbeddedCurvePoint<  > as Eq<  >)::eq<  > as λ(embedded_curve_ops::EmbeddedCurvePoint<  >, embedded_curve_ops::EmbeddedCurvePoint<  >) → bool)(embedded_curve_ops::EmbeddedCurvePoint<  >, embedded_curve_ops::EmbeddedCurvePoint<  >)) : Unit;
    #assert(#fEq((@std::hash::pedersen_hash_with_separator< 9 : u32 > as λ([Field; 9], u32) → Field)([1 : Field, 2 : Field, 3 : Field, 4 : Field, 5 : Field, 6 : Field, 7 : Field, 8 : Field, 9 : Field], 9 : u32), 5694292929090063810102755351119629986122166830204542196709417013467308391399 : Field) : bool) : Unit;
    #assert(((embedded_curve_ops::EmbeddedCurvePoint<  > as Eq<  >)::eq<  > as λ(embedded_curve_ops::EmbeddedCurvePoint<  >, embedded_curve_ops::EmbeddedCurvePoint<  >) → bool)(embedded_curve_ops::EmbeddedCurvePoint<  >, embedded_curve_ops::EmbeddedCurvePoint<  >)) : Unit;
    #assert(#fEq((@std::hash::pedersen_hash_with_separator< 10 : u32 > as λ([Field; 10], u32) → Field)([1 : Field, 2 : Field, 3 : Field, 4 : Field, 5 : Field, 6 : Field, 7 : Field, 8 : Field, 9 : Field, 10 : Field], 10 : u32), -1612865150156425111011383725280441289912228955196006102547487828548180279661 : Field) : bool) : Unit;
    #assert(((embedded_curve_ops::EmbeddedCurvePoint<  > as Eq<  >)::eq<  > as λ(embedded_curve_ops::EmbeddedCurvePoint<  >, embedded_curve_ops::EmbeddedCurvePoint<  >) → bool)(embedded_curve_ops::EmbeddedCurvePoint<  >, embedded_curve_ops::EmbeddedCurvePoint<  >)) : Unit;
}


def Hash.Mod.env := Lampe.Env.mk [«hash::__blake3», «hash::__derive_generators», «hash::assert_pedersen», «hash::blake2s», «hash::blake3», «hash::derive_generators», «hash::from_field_unsafe», «hash::hash_to_field», «hash::keccak::keccakf1600», «hash::keccakf1600», «hash::pedersen_commitment_with_separator», «hash::pedersen_commitment», «hash::pedersen_hash_with_separator», «hash::pedersen_hash», «hash::poseidon2_permutation», «hash::sha256_compression»] [impl_10, impl_11, impl_12, impl_13, impl_14, impl_15, impl_16, impl_17, impl_18, impl_19, impl_2, impl_20, impl_21, impl_22, impl_3, impl_4, impl_5, impl_6, impl_7, impl_8, impl_9]