-- Generated by lampe

import «std-0.0.0».Extracted.GeneratedTypes
import Lampe

open Lampe

namespace «std-0.0.0»
namespace Extracted

nr_def «hash»::«poseidon2»::«Poseidon2»::«hash»<@N : u32>(input : [Field; N], message_size : u32) -> Field {
    (@hash::poseidon2::Poseidon2::hash_internal<N:u32> as λ([Field; N], u32, bool) → Field)(input, message_size, #uNeq(message_size, u@N) : bool);
}

nr_def «hash»::«poseidon2»::«Poseidon2»::«new»<>(iv : Field) -> hash::poseidon2::Poseidon2<> {
    let mut result = hash::poseidon2::Poseidon2<> { [0 : Field ; 3], [0 : Field ; 4], 0 : u32, false };
    (result as hash::poseidon2::Poseidon2<>).state[#cast((@RATE<> as λ() → u32)()) : u32] = iv;
    result;
}

nr_def «hash»::«poseidon2»::«Poseidon2»::«perform_duplex»<>(self : &hash::poseidon2::Poseidon2<>) -> Unit {
    for i in 0 : u32 .. (@RATE<> as λ() → u32)() {
            if #uLt(i, (#readRef(self) : hash::poseidon2::Poseidon2<> as hash::poseidon2::Poseidon2<>).cache_size) : bool {
                (*(self) as hash::poseidon2::Poseidon2<>).state[#cast(i) : u32] = #fAdd(#arrayIndex((#readRef(self) : hash::poseidon2::Poseidon2<> as hash::poseidon2::Poseidon2<>).state, #cast(i) : u32) : Field, #arrayIndex((#readRef(self) : hash::poseidon2::Poseidon2<> as hash::poseidon2::Poseidon2<>).cache, #cast(i) : u32) : Field) : Field;
            skip;
        };
    };
    (*(self) as hash::poseidon2::Poseidon2<>).state = (@std::hash::poseidon2_permutation<4 : u32> as λ([Field; 4], u32) → [Field; 4])((#readRef(self) : hash::poseidon2::Poseidon2<> as hash::poseidon2::Poseidon2<>).state, 4 : u32);
    skip;
}

nr_def «hash»::«poseidon2»::«Poseidon2»::«absorb»<>(self : &hash::poseidon2::Poseidon2<>, input : Field) -> Unit {
    #assert(#bNot((#readRef(self) : hash::poseidon2::Poseidon2<> as hash::poseidon2::Poseidon2<>).squeeze_mode) : bool) : Unit;
    if #uEq((#readRef(self) : hash::poseidon2::Poseidon2<> as hash::poseidon2::Poseidon2<>).cache_size, (@RATE<> as λ() → u32)()) : bool {
            (@hash::poseidon2::Poseidon2::perform_duplex<> as λ(&hash::poseidon2::Poseidon2<>) → Unit)(self);
        (*(self) as hash::poseidon2::Poseidon2<>).cache[#cast(0 : u32) : u32] = input;
        (*(self) as hash::poseidon2::Poseidon2<>).cache_size = 1 : u32;
        skip;
    } else {
                let i_2535 = (#readRef(self) : hash::poseidon2::Poseidon2<> as hash::poseidon2::Poseidon2<>).cache_size;
            (*(self) as hash::poseidon2::Poseidon2<>).cache[#cast(i_2535) : u32] = input;
            skip;
        (*(self) as hash::poseidon2::Poseidon2<>).cache_size = #uAdd((#readRef(self) : hash::poseidon2::Poseidon2<> as hash::poseidon2::Poseidon2<>).cache_size, 1 : u32) : u32;
        skip;
    };
}

nr_def «hash»::«poseidon2»::«Poseidon2»::«squeeze»<>(self : &hash::poseidon2::Poseidon2<>) -> Field {
    #assert(#bNot((#readRef(self) : hash::poseidon2::Poseidon2<> as hash::poseidon2::Poseidon2<>).squeeze_mode) : bool) : Unit;
    (@hash::poseidon2::Poseidon2::perform_duplex<> as λ(&hash::poseidon2::Poseidon2<>) → Unit)(self);
    (*(self) as hash::poseidon2::Poseidon2<>).squeeze_mode = true;
    #arrayIndex((#readRef(self) : hash::poseidon2::Poseidon2<> as hash::poseidon2::Poseidon2<>).state, #cast(0 : u32) : u32) : Field;
}

nr_def «hash»::«poseidon2»::«Poseidon2»::«hash_internal»<@N : u32>(input : [Field; N], in_len : u32, is_variable_length : bool) -> Field {
    let two_pow_64 = 18446744073709551616 : Field;
    let iv = #fMul(#cast(in_len) : Field, two_pow_64) : Field;
    let mut sponge = (@hash::poseidon2::Poseidon2::new<> as λ(Field) → hash::poseidon2::Poseidon2<>)(iv);
    for i in 0 : u32 .. #arrayLen(input) : u32 {
            if #uLt(i, in_len) : bool {
                (@hash::poseidon2::Poseidon2::absorb<> as λ(&hash::poseidon2::Poseidon2<>, Field) → Unit)(#ref(sponge) : &hash::poseidon2::Poseidon2<>, #arrayIndex(input, #cast(i) : u32) : Field);
        };
    };
    if is_variable_length {
            (@hash::poseidon2::Poseidon2::absorb<> as λ(&hash::poseidon2::Poseidon2<>, Field) → Unit)(#ref(sponge) : &hash::poseidon2::Poseidon2<>, 1 : Field);
    };
    (@hash::poseidon2::Poseidon2::squeeze<> as λ(&hash::poseidon2::Poseidon2<>) → Field)(#ref(sponge) : &hash::poseidon2::Poseidon2<>);
}

nr_trait_impl[impl_0] <> std::hash::Hasher<> for hash::poseidon2::Poseidon2Hasher<> where  {
    fn «finish»<> (self : hash::poseidon2::Poseidon2Hasher<>) -> Field {
        let iv = #fMul(#cast(#sliceLen((self as hash::poseidon2::Poseidon2Hasher<>)._state) : u32) : Field, 18446744073709551616 : Field) : Field;
        let mut sponge = (@hash::poseidon2::Poseidon2::new<> as λ(Field) → hash::poseidon2::Poseidon2<>)(iv);
        for i in 0 : u32 .. #sliceLen((self as hash::poseidon2::Poseidon2Hasher<>)._state) : u32 {
                    (@hash::poseidon2::Poseidon2::absorb<> as λ(&hash::poseidon2::Poseidon2<>, Field) → Unit)(#ref(sponge) : &hash::poseidon2::Poseidon2<>, #sliceIndex((self as hash::poseidon2::Poseidon2Hasher<>)._state, #cast(i) : u32) : Field);
        };
        (@hash::poseidon2::Poseidon2::squeeze<> as λ(&hash::poseidon2::Poseidon2<>) → Field)(#ref(sponge) : &hash::poseidon2::Poseidon2<>);
};
fn «write»<> (self : &hash::poseidon2::Poseidon2Hasher<>, input : Field) -> Unit {
        (*(self) as hash::poseidon2::Poseidon2Hasher<>)._state = #slicePushBack((#readRef(self) : hash::poseidon2::Poseidon2Hasher<> as hash::poseidon2::Poseidon2Hasher<>)._state, input) : [Field];
        skip;
}
}

nr_trait_impl[impl_1] <> std::default::Default<> for hash::poseidon2::Poseidon2Hasher<> where  {
    fn «default»<> () -> hash::poseidon2::Poseidon2Hasher<> {
        hash::poseidon2::Poseidon2Hasher<> { &[] };
}
}


def Hash.Poseidon2.env := Lampe.Env.mk [«hash::poseidon2::Poseidon2::absorb», «hash::poseidon2::Poseidon2::hash_internal», «hash::poseidon2::Poseidon2::hash», «hash::poseidon2::Poseidon2::new», «hash::poseidon2::Poseidon2::perform_duplex», «hash::poseidon2::Poseidon2::squeeze»] [impl_0, impl_1]