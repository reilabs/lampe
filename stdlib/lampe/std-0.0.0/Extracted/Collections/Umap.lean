-- Generated by lampe

import «std-0.0.0».Extracted.GeneratedTypes
import Lampe

open Lampe

namespace «std-0.0.0»
namespace Extracted

nr_trait_impl[impl_37] <K, V> std::default::Default<  > for collections::umap::Slot< K, V > where  {
    fn «default»<> () -> collections::umap::Slot< K, V > {
        collections::umap::Slot< K,V > { (@option::Option::none< `(K, V) > as λ() → option::Option< `(K, V) >)(), false };
}
}

nr_def «collections»::«umap»::«Slot»::«is_valid»<K, V>(self : collections::umap::Slot< K, V >) -> bool {
    #bAnd(#bNot((self as collections::umap::Slot< K, V >)._is_deleted) : bool, (@option::Option::is_some< `(K, V) > as λ(option::Option< `(K, V) >) → bool)((self as collections::umap::Slot< K, V >)._key_value)) : bool;
}

nr_def «collections»::«umap»::«Slot»::«is_available»<K, V>(self : collections::umap::Slot< K, V >) -> bool {
    #bOr((self as collections::umap::Slot< K, V >)._is_deleted, (@option::Option::is_none< `(K, V) > as λ(option::Option< `(K, V) >) → bool)((self as collections::umap::Slot< K, V >)._key_value)) : bool;
}

nr_def «collections»::«umap»::«Slot»::«key_value»<K, V>(self : collections::umap::Slot< K, V >) -> option::Option< `(K, V) > {
    (self as collections::umap::Slot< K, V >)._key_value;
}

nr_def «collections»::«umap»::«Slot»::«key_value_unchecked»<K, V>(self : collections::umap::Slot< K, V >) -> `(K, V) {
    (@option::Option::unwrap_unchecked< `(K, V) > as λ(option::Option< `(K, V) >) → `(K, V))((self as collections::umap::Slot< K, V >)._key_value);
}

nr_def «collections»::«umap»::«Slot»::«set»<K, V>(self : &collections::umap::Slot< K, V >, key : K, value : V) -> Unit {
    (*(self) as collections::umap::Slot< K, V >)._key_value = (@option::Option::some< `(K, V) > as λ(`(K, V)) → option::Option< `(K, V) >)(`(key, value));
    (*(self) as collections::umap::Slot< K, V >)._is_deleted = false;
    skip;
}

nr_def «collections»::«umap»::«Slot»::«mark_deleted»<K, V>(self : &collections::umap::Slot< K, V >) -> Unit {
    (*(self) as collections::umap::Slot< K, V >)._is_deleted = true;
    skip;
}

nr_def «collections»::«umap»::«UHashMap»::«with_hasher»<K, V, B>(_build_hasher : B) -> collections::umap::UHashMap< K, V, B > {
    let _table = &[((collections::umap::Slot< K, V > as std::default::Default<  >)::default<  > as λ() → collections::umap::Slot< K, V >)()];
    let _len = 0 : u32;
    collections::umap::UHashMap< K,V,B > { _table, _len, _build_hasher };
}

nr_def «collections»::«umap»::«UHashMap»::«with_hasher_and_capacity»<K, V, B>(_build_hasher : B, capacity : u32) -> collections::umap::UHashMap< K, V, B > {
    let mut _table = &[];
    for _? in 0 : u32 .. capacity {
            _table = (@std::slice::push_back< collections::umap::Slot< K, V > > as λ([collections::umap::Slot< K, V >], collections::umap::Slot< K, V >) → [collections::umap::Slot< K, V >])(_table, ((collections::umap::Slot< K, V > as std::default::Default<  >)::default<  > as λ() → collections::umap::Slot< K, V >)());
        skip;
    };
    let _len = 0 : u32;
    collections::umap::UHashMap< K,V,B > { _table, _len, _build_hasher };
}

nr_def «collections»::«umap»::«UHashMap»::«clear»<K, V, B>(self : &collections::umap::UHashMap< K, V, B >) -> Unit {
    (*(self) as collections::umap::UHashMap< K, V, B >)._table = &[((collections::umap::Slot< K, V > as std::default::Default<  >)::default<  > as λ() → collections::umap::Slot< K, V >)()];
    (*(self) as collections::umap::UHashMap< K, V, B >)._len = 0 : u32;
    skip;
}

nr_def «collections»::«umap»::«UHashMap»::«contains_key»<K, V, B>(self : collections::umap::UHashMap< K, V, B >, key : K) -> bool {
    (@option::Option::is_some< V > as λ(option::Option< V >) → bool)(    (@collections::umap::UHashMap::get< K, V, B > as λ(collections::umap::UHashMap< K, V, B >, K) → option::Option< V >)(self, key););
}

nr_def «collections»::«umap»::«UHashMap»::«is_empty»<K, V, B>(self : collections::umap::UHashMap< K, V, B >) -> bool {
    #uEq((self as collections::umap::UHashMap< K, V, B >)._len, 0 : u32) : bool;
}

nr_def «collections»::«umap»::«UHashMap»::«entries»<K, V, B>(self : collections::umap::UHashMap< K, V, B >) -> [`(K, V)] {
    let mut entries = &[];
        let ζi0 = (self as collections::umap::UHashMap< K, V, B >)._table;
        for ζi1 in 0 : u32 .. (@std::slice::len< collections::umap::Slot< K, V > > as λ([collections::umap::Slot< K, V >]) → u32)(ζi0) {
                let slot = #sliceIndex(ζi0, #cast(ζi1) : u32) : collections::umap::Slot< K, V >;
                if (@collections::umap::Slot::is_valid< K, V > as λ(collections::umap::Slot< K, V >) → bool)(slot) {
                        let key_value = (@option::Option::unwrap_unchecked< `(K, V) > as λ(option::Option< `(K, V) >) → `(K, V))((@collections::umap::Slot::key_value< K, V > as λ(collections::umap::Slot< K, V >) → option::Option< `(K, V) >)(slot));
                    entries = (@std::slice::push_back< `(K, V) > as λ([`(K, V)], `(K, V)) → [`(K, V)])(entries, key_value);
                    skip;
                };
        };
    let self_len = (self as collections::umap::UHashMap< K, V, B >)._len;
    let entries_len = (@std::slice::len< `(K, V) > as λ([`(K, V)]) → u32)(entries);
    let msg = #format("Amount of valid elements should have been {self_len} times, but got {entries_len}.", self_len, entries_len);
    #assert(#uEq((@std::slice::len< `(K, V) > as λ([`(K, V)]) → u32)(entries), (self as collections::umap::UHashMap< K, V, B >)._len) : bool) : Unit;
    entries;
}

nr_def «collections»::«umap»::«UHashMap»::«keys»<K, V, B>(self : collections::umap::UHashMap< K, V, B >) -> [K] {
    let mut keys = &[];
        let ζi0 = (self as collections::umap::UHashMap< K, V, B >)._table;
        for ζi1 in 0 : u32 .. (@std::slice::len< collections::umap::Slot< K, V > > as λ([collections::umap::Slot< K, V >]) → u32)(ζi0) {
                let slot = #sliceIndex(ζi0, #cast(ζi1) : u32) : collections::umap::Slot< K, V >;
                if (@collections::umap::Slot::is_valid< K, V > as λ(collections::umap::Slot< K, V >) → bool)(slot) {
                        let π0 = (@collections::umap::Slot::key_value_unchecked< K, V > as λ(collections::umap::Slot< K, V >) → `(K, V))(slot);
                    let key = π0.0;
                    let _? = π0.1;
                    keys = (@std::slice::push_back< K > as λ([K], K) → [K])(keys, key);
                    skip;
                };
        };
    let self_len = (self as collections::umap::UHashMap< K, V, B >)._len;
    let keys_len = (@std::slice::len< K > as λ([K]) → u32)(keys);
    let msg = #format("Amount of valid elements should have been {self_len} times, but got {keys_len}.", self_len, keys_len);
    #assert(#uEq((@std::slice::len< K > as λ([K]) → u32)(keys), (self as collections::umap::UHashMap< K, V, B >)._len) : bool) : Unit;
    keys;
}

nr_def «collections»::«umap»::«UHashMap»::«values»<K, V, B>(self : collections::umap::UHashMap< K, V, B >) -> [V] {
    let mut values = &[];
        let ζi0 = (self as collections::umap::UHashMap< K, V, B >)._table;
        for ζi1 in 0 : u32 .. (@std::slice::len< collections::umap::Slot< K, V > > as λ([collections::umap::Slot< K, V >]) → u32)(ζi0) {
                let slot = #sliceIndex(ζi0, #cast(ζi1) : u32) : collections::umap::Slot< K, V >;
                if (@collections::umap::Slot::is_valid< K, V > as λ(collections::umap::Slot< K, V >) → bool)(slot) {
                        let π0 = (@collections::umap::Slot::key_value_unchecked< K, V > as λ(collections::umap::Slot< K, V >) → `(K, V))(slot);
                    let _? = π0.0;
                    let value = π0.1;
                    values = (@std::slice::push_back< V > as λ([V], V) → [V])(values, value);
                    skip;
                };
        };
    let self_len = (self as collections::umap::UHashMap< K, V, B >)._len;
    let values_len = (@std::slice::len< V > as λ([V]) → u32)(values);
    let msg = #format("Amount of valid elements should have been {self_len} times, but got {values_len}.", self_len, values_len);
    #assert(#uEq((@std::slice::len< V > as λ([V]) → u32)(values), (self as collections::umap::UHashMap< K, V, B >)._len) : bool) : Unit;
    values;
}

nr_def «collections»::«umap»::«UHashMap»::«iter_mut»<K, V, B>(self : &collections::umap::UHashMap< K, V, B >, f : λ(K, V) → `(K, V)) -> Unit {
    #fresh() : Unit
}

nr_def «collections»::«umap»::«UHashMap»::«iter_keys_mut»<K, V, B>(self : &collections::umap::UHashMap< K, V, B >, f : λ(K) → K) -> Unit {
    #fresh() : Unit
}

nr_def «collections»::«umap»::«UHashMap»::«iter_values_mut»<K, V, B>(self : &collections::umap::UHashMap< K, V, B >, f : λ(V) → V) -> Unit {
    for i in 0 : u32 .. (@std::slice::len< collections::umap::Slot< K, V > > as λ([collections::umap::Slot< K, V >]) → u32)((#readRef(self) : collections::umap::UHashMap< K, V, B > as collections::umap::UHashMap< K, V, B >)._table) {
            let mut slot = #sliceIndex((#readRef(self) : collections::umap::UHashMap< K, V, B > as collections::umap::UHashMap< K, V, B >)._table, #cast(i) : u32) : collections::umap::Slot< K, V >;
        if (@collections::umap::Slot::is_valid< K, V > as λ(collections::umap::Slot< K, V >) → bool)(slot) {
                let π0 = (@collections::umap::Slot::key_value_unchecked< K, V > as λ(collections::umap::Slot< K, V >) → `(K, V))(slot);
            let key = π0.0;
            let value = π0.1;
            (@collections::umap::Slot::set< K, V > as λ(&collections::umap::Slot< K, V >, K, V) → Unit)(#ref(slot) : &collections::umap::Slot< K, V >, key, f(value));
            (*(self) as collections::umap::UHashMap< K, V, B >)._table[[#cast(i) : u32]] = slot;
            skip;
        };
    };
}

nr_def «collections»::«umap»::«UHashMap»::«retain»<K, V, B>(self : &collections::umap::UHashMap< K, V, B >, f : λ(K, V) → bool) -> Unit {
    for index in 0 : u32 .. (@std::slice::len< collections::umap::Slot< K, V > > as λ([collections::umap::Slot< K, V >]) → u32)((#readRef(self) : collections::umap::UHashMap< K, V, B > as collections::umap::UHashMap< K, V, B >)._table) {
            let mut slot = #sliceIndex((#readRef(self) : collections::umap::UHashMap< K, V, B > as collections::umap::UHashMap< K, V, B >)._table, #cast(index) : u32) : collections::umap::Slot< K, V >;
        if (@collections::umap::Slot::is_valid< K, V > as λ(collections::umap::Slot< K, V >) → bool)(slot) {
                let π0 = (@collections::umap::Slot::key_value_unchecked< K, V > as λ(collections::umap::Slot< K, V >) → `(K, V))(slot);
            let key = π0.0;
            let value = π0.1;
            if #bNot(f(key, value)) : bool {
                    (@collections::umap::Slot::mark_deleted< K, V > as λ(&collections::umap::Slot< K, V >) → Unit)(#ref(slot) : &collections::umap::Slot< K, V >);
                (*(self) as collections::umap::UHashMap< K, V, B >)._len = #uSub((#readRef(self) : collections::umap::UHashMap< K, V, B > as collections::umap::UHashMap< K, V, B >)._len, 1 : u32) : u32;
                (*(self) as collections::umap::UHashMap< K, V, B >)._table[[#cast(index) : u32]] = slot;
                skip;
            };
        };
    };
}

nr_def «collections»::«umap»::«UHashMap»::«len»<K, V, B>(self : collections::umap::UHashMap< K, V, B >) -> u32 {
    (self as collections::umap::UHashMap< K, V, B >)._len;
}

nr_def «collections»::«umap»::«UHashMap»::«capacity»<K, V, B>(self : collections::umap::UHashMap< K, V, B >) -> u32 {
    (@std::slice::len< collections::umap::Slot< K, V > > as λ([collections::umap::Slot< K, V >]) → u32)((self as collections::umap::UHashMap< K, V, B >)._table);
}

nr_def «collections»::«umap»::«UHashMap»::«get»<K, V, B>(self : collections::umap::UHashMap< K, V, B >, key : K) -> option::Option< V > {
    #fresh() : option::Option< V >
}

nr_def «collections»::«umap»::«UHashMap»::«insert»<K, V, B>(self : &collections::umap::UHashMap< K, V, B >, key : K, value : V) -> Unit {
    #fresh() : Unit
}

nr_def «collections»::«umap»::«UHashMap»::«try_resize»<K, V, B>(self : &collections::umap::UHashMap< K, V, B >) -> Unit {
    #fresh() : Unit
}

nr_def «collections»::«umap»::«UHashMap»::«remove»<K, V, B>(self : &collections::umap::UHashMap< K, V, B >, key : K) -> Unit {
    #fresh() : Unit
}

nr_def «collections»::«umap»::«UHashMap»::«hash»<K, V, B>(self : collections::umap::UHashMap< K, V, B >, key : K) -> u32 {
    let mut hasher = ((B as std::hash::BuildHasher<  >)::build_hasher<  > as λ(B) → <B as BuildHasher>::H)((self as collections::umap::UHashMap< K, V, B >)._build_hasher);
    ((K as std::hash::Hash<  >)::hash<  > as λ(K, &<B as BuildHasher>::H) → Unit)(key, #ref(hasher) : &<B as BuildHasher>::H);
    #cast(((<B as BuildHasher>::H as std::hash::Hasher<  >)::finish<  > as λ(<B as BuildHasher>::H) → Field)(hasher)) : u32;
}

nr_def «collections»::«umap»::«UHashMap»::«quadratic_probe»<K, V, B>(self : collections::umap::UHashMap< K, V, B >, hash : u32, attempt : u32) -> u32 {
    #uRem(#uAdd(hash, #uDiv(#uAdd(attempt, #uMul(attempt, attempt) : u32) : u32, 2 : u32) : u32) : u32, (@std::slice::len< collections::umap::Slot< K, V > > as λ([collections::umap::Slot< K, V >]) → u32)((self as collections::umap::UHashMap< K, V, B >)._table)) : u32;
}

nr_trait_impl[impl_38] <K, B, V> std::cmp::Eq<  > for collections::umap::UHashMap< K, V, B > where K : Eq<>, K : Hash<>, V : Eq<>, B : BuildHasher<> {
    fn «eq»<> (self : collections::umap::UHashMap< K, V, B >, other : collections::umap::UHashMap< K, V, B >) -> bool {
        let mut equal = false;
        if #uEq((@collections::umap::UHashMap::len< K, V, B > as λ(collections::umap::UHashMap< K, V, B >) → u32)(self), (@collections::umap::UHashMap::len< K, V, B > as λ(collections::umap::UHashMap< K, V, B >) → u32)(other)) : bool {
                    equal = true;
                        let ζi0 = (self as collections::umap::UHashMap< K, V, B >)._table;
                        for ζi1 in 0 : u32 .. (@std::slice::len< collections::umap::Slot< K, V > > as λ([collections::umap::Slot< K, V >]) → u32)(ζi0) {
                                    let slot = #sliceIndex(ζi0, #cast(ζi1) : u32) : collections::umap::Slot< K, V >;
                                        if #bAnd(equal, (@collections::umap::Slot::is_valid< K, V > as λ(collections::umap::Slot< K, V >) → bool)(slot)) : bool {
                                                    let π0 = (@collections::umap::Slot::key_value_unchecked< K, V > as λ(collections::umap::Slot< K, V >) → `(K, V))(slot);
                                                let key = π0.0;
                                                let value = π0.1;
                                                let other_value =         (@collections::umap::UHashMap::get< K, V, B > as λ(collections::umap::UHashMap< K, V, B >, K) → option::Option< V >)(other, key);
                                                if (@option::Option::is_none< V > as λ(option::Option< V >) → bool)(other_value) {
                                                            equal = false;
                                                        skip;
                                                } else {
                                                            let other_value = (@option::Option::unwrap_unchecked< V > as λ(option::Option< V >) → V)(other_value);
                                                        if ((V as Eq<  >)::eq<  > as λ(V, V) → bool)(value, other_value) {
                                                                    equal = false;
                                                                skip;
                                                        };
                                                };
                                        };
                        };
        };
        equal;
}
}

nr_trait_impl[impl_39] <V, K, B> std::default::Default<  > for collections::umap::UHashMap< K, V, B > where B : BuildHasher<>, B : Default<> {
    fn «default»<> () -> collections::umap::UHashMap< K, V, B > {
        (@collections::umap::UHashMap::with_hasher< K, V, B > as λ(B) → collections::umap::UHashMap< K, V, B >)(((B as std::default::Default<  >)::default<  > as λ() → B)());
}
}


def Collections.Umap.env := Lampe.Env.mk [«collections::umap::Slot::is_available», «collections::umap::Slot::is_valid», «collections::umap::Slot::key_value_unchecked», «collections::umap::Slot::key_value», «collections::umap::Slot::mark_deleted», «collections::umap::Slot::set», «collections::umap::UHashMap::capacity», «collections::umap::UHashMap::clear», «collections::umap::UHashMap::contains_key», «collections::umap::UHashMap::entries», «collections::umap::UHashMap::get», «collections::umap::UHashMap::hash», «collections::umap::UHashMap::insert», «collections::umap::UHashMap::is_empty», «collections::umap::UHashMap::iter_keys_mut», «collections::umap::UHashMap::iter_mut», «collections::umap::UHashMap::iter_values_mut», «collections::umap::UHashMap::keys», «collections::umap::UHashMap::len», «collections::umap::UHashMap::quadratic_probe», «collections::umap::UHashMap::remove», «collections::umap::UHashMap::retain», «collections::umap::UHashMap::try_resize», «collections::umap::UHashMap::values», «collections::umap::UHashMap::with_hasher_and_capacity», «collections::umap::UHashMap::with_hasher»] [impl_37, impl_38, impl_39]