-- Generated by lampe

import Lampe

open Lampe

namespace «std-0.0.0»
namespace Extracted

noir_struct_def std::option::Option<T: Type> {
  bool,
  T,
}

noir_struct_def std::collections::map::Slot<K: Type, V: Type> {
  std::option::Option<Tuple<K, V> >,
  bool,
}

noir_struct_def std::collections::map::HashMap<K: Type, V: Type, N: u32, B: Type> {
  Array<std::collections::map::Slot<K, V>, N: u32>,
  u32,
  B,
}

noir_struct_def std::collections::umap::Slot<K: Type, V: Type> {
  std::option::Option<Tuple<K, V> >,
  bool,
}

noir_struct_def std::collections::umap::UHashMap<K: Type, V: Type, B: Type> {
  Slice<std::collections::umap::Slot<K, V> >,
  u32,
  B,
}

noir_struct_def std::collections::bounded_vec::BoundedVec<T: Type, MaxLen: u32> {
  Array<T, MaxLen: u32>,
  u32,
}

noir_struct_def std::embedded_curve_ops::EmbeddedCurvePoint<> {
  Field,
  Field,
  bool,
}

noir_type_alias DeriveFunction<> := λ(Unit) -> Unit;

noir_struct_def std::hash::poseidon2::Poseidon2Hasher<> {
  Slice<Field>,
}

noir_struct_def std::cmp::Ordering<> {
  Field,
}

noir_struct_def std::collections::vec::Vec<T: Type> {
  Slice<T>,
}

noir_struct_def std::embedded_curve_ops::EmbeddedCurveScalar<> {
  Field,
  Field,
}

noir_struct_def std::hash::BuildHasherDefault<H: Type> {}

noir_struct_def std::meta::op::BinaryOp<> {
  Field,
}

noir_struct_def std::meta::tests::MyOtherStruct<> {
  u32,
}

noir_struct_def std::array::check_shuffle::test::CompoundStruct<> {
  bool,
  Field,
  u64,
}

noir_struct_def std::meta::tests::Bar<> {
  Field,
  Array<Field, 2: u32>,
}

noir_struct_def std::meta::tests::MyStruct<> {
  i32,
}

noir_struct_def std::meta::op::UnaryOp<> {
  Field,
}

noir_struct_def std::hash::poseidon2::Poseidon2<> {
  Array<Field, 3: u32>,
  Array<Field, 4: u32>,
  u32,
  bool,
}

noir_struct_def std::test::OracleMock<> {
  Field,
}

noir_trait_def std::append::Append<> [] := {
  method empty<>() -> Self;
  method append<>(Self, Self) -> Self;
}

noir_trait_def std::cmp::Eq<> [] := {
  method eq<>(Self, Self) -> bool;
}

noir_trait_def std::cmp::Ord<> [] := {
  method cmp<>(Self, Self) -> std::cmp::Ordering<>;
}

noir_trait_def std::convert::AsPrimitive<T: Type> [] := {
  method as_<>(Self) -> T;
}

noir_trait_def std::convert::From<T: Type> [] := {
  method from<>(T) -> Self;
}

noir_trait_def std::convert::Into<T: Type> [] := {
  method into<>(Self) -> T;
}

noir_trait_def std::default::Default<> [] := {
  method default<>() -> Self;
}

noir_trait_def std::hash::BuildHasher<> [H: Type] := {
  method build_hasher<>(Self) -> H;
}

noir_trait_def std::hash::Hash<> [] := {
  method hash<H: Type>(Self, & H) -> Unit;
}

noir_trait_def std::hash::Hasher<> [] := {
  method finish<>(Self) -> Field;
  method write<>(& Self, Field) -> Unit;
}

noir_trait_def std::meta::ctstring::AsCtString<> [] := {
  method as_ctstring<>(Self) -> Unit;
}

noir_trait_def std::meta::tests::DoNothing<> [] := {
  method do_nothing<>(Self) -> Unit;
}

noir_trait_def std::meta::tests::FieldCount<> [] := {
  method field_count<>() -> u32;
}

noir_trait_def std::ops::arith::Add<> [] := {
  method add<>(Self, Self) -> Self;
}

noir_trait_def std::ops::arith::Div<> [] := {
  method div<>(Self, Self) -> Self;
}

noir_trait_def std::ops::arith::Mul<> [] := {
  method mul<>(Self, Self) -> Self;
}

noir_trait_def std::ops::arith::Neg<> [] := {
  method neg<>(Self) -> Self;
}

noir_trait_def std::ops::arith::Rem<> [] := {
  method rem<>(Self, Self) -> Self;
}

noir_trait_def std::ops::arith::Sub<> [] := {
  method sub<>(Self, Self) -> Self;
}

noir_trait_def std::ops::arith::WrappingAdd<> [] := {
  method wrapping_add<>(Self, Self) -> Self;
}

noir_trait_def std::ops::arith::WrappingMul<> [] := {
  method wrapping_mul<>(Self, Self) -> Self;
}

noir_trait_def std::ops::arith::WrappingSub<> [] := {
  method wrapping_sub<>(Self, Self) -> Self;
}

noir_trait_def std::ops::bit::BitAnd<> [] := {
  method bitand<>(Self, Self) -> Self;
}

noir_trait_def std::ops::bit::BitOr<> [] := {
  method bitor<>(Self, Self) -> Self;
}

noir_trait_def std::ops::bit::BitXor<> [] := {
  method bitxor<>(Self, Self) -> Self;
}

noir_trait_def std::ops::bit::Not<> [] := {
  method not<>(Self) -> Self;
}

noir_trait_def std::ops::bit::Shl<> [] := {
  method shl<>(Self, u8) -> Self;
}

noir_trait_def std::ops::bit::Shr<> [] := {
  method shr<>(Self, u8) -> Self;
}

