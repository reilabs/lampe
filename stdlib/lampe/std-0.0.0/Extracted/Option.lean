-- Generated by lampe

import «std-0.0.0».Extracted.GeneratedTypes
import Lampe

open Lampe

namespace «std-0.0.0»
namespace Extracted

nr_def «option»::«Option»::«none»<T>() -> option::Option<T> {
    option::Option<T> { false, #zeroed() : T };
}

nr_def «option»::«Option»::«some»<T>(_value : T) -> option::Option<T> {
    option::Option<T> { true, _value };
}

nr_def «option»::«Option»::«is_none»<T>(self : option::Option<T>) -> bool {
    #bNot((self as option::Option<T>)._is_some) : bool;
}

nr_def «option»::«Option»::«is_some»<T>(self : option::Option<T>) -> bool {
    (self as option::Option<T>)._is_some;
}

nr_def «option»::«Option»::«unwrap»<T>(self : option::Option<T>) -> T {
    #assert((self as option::Option<T>)._is_some) : Unit;
    (self as option::Option<T>)._value;
}

nr_def «option»::«Option»::«unwrap_unchecked»<T>(self : option::Option<T>) -> T {
    (self as option::Option<T>)._value;
}

nr_def «option»::«Option»::«unwrap_or»<T>(self : option::Option<T>, default : T) -> T {
    if (self as option::Option<T>)._is_some {
            (self as option::Option<T>)._value;
    } else {
            default;
    };
}

nr_def «option»::«Option»::«unwrap_or_else»<T, Env>(self : option::Option<T>, default : λ() → T) -> T {
    if (self as option::Option<T>)._is_some {
            (self as option::Option<T>)._value;
    } else {
            (default as λ() → T)();
    };
}

nr_def «option»::«Option»::«expect»<T, @N : u32, MessageTypes>(self : option::Option<T>, message : fmtstr<N, MessageTypes>) -> T {
    #assert((@option::Option::is_some<T> as λ(option::Option<T>) → bool)(self)) : Unit;
    (self as option::Option<T>)._value;
}

nr_def «option»::«Option»::«map»<T, U, Env>(self : option::Option<T>, f : λ(T) → U) -> option::Option<U> {
    if (self as option::Option<T>)._is_some {
            (@option::Option::some<U> as λ(U) → option::Option<U>)((f as λ(T) → U)((self as option::Option<T>)._value));
    } else {
            (@option::Option::none<U> as λ() → option::Option<U>)();
    };
}

nr_def «option»::«Option»::«map_or»<T, U, Env>(self : option::Option<T>, default : U, f : λ(T) → U) -> U {
    if (self as option::Option<T>)._is_some {
            (f as λ(T) → U)((self as option::Option<T>)._value);
    } else {
            default;
    };
}

nr_def «option»::«Option»::«map_or_else»<T, U, Env1, Env2>(self : option::Option<T>, default : λ() → U, f : λ(T) → U) -> U {
    if (self as option::Option<T>)._is_some {
            (f as λ(T) → U)((self as option::Option<T>)._value);
    } else {
            (default as λ() → U)();
    };
}

nr_def «option»::«Option»::«and»<T>(self : option::Option<T>, other : option::Option<T>) -> option::Option<T> {
    if (@option::Option::is_none<T> as λ(option::Option<T>) → bool)(self) {
            (@option::Option::none<T> as λ() → option::Option<T>)();
    } else {
            other;
    };
}

nr_def «option»::«Option»::«and_then»<T, U, Env>(self : option::Option<T>, f : λ(T) → option::Option<U>) -> option::Option<U> {
    if (self as option::Option<T>)._is_some {
            (f as λ(T) → option::Option<U>)((self as option::Option<T>)._value);
    } else {
            (@option::Option::none<U> as λ() → option::Option<U>)();
    };
}

nr_def «option»::«Option»::«or»<T>(self : option::Option<T>, other : option::Option<T>) -> option::Option<T> {
    if (self as option::Option<T>)._is_some {
            self;
    } else {
            other;
    };
}

nr_def «option»::«Option»::«or_else»<T, Env>(self : option::Option<T>, default : λ() → option::Option<T>) -> option::Option<T> {
    if (self as option::Option<T>)._is_some {
            self;
    } else {
            (default as λ() → option::Option<T>)();
    };
}

nr_def «option»::«Option»::«xor»<T>(self : option::Option<T>, other : option::Option<T>) -> option::Option<T> {
    if (self as option::Option<T>)._is_some {
            if (other as option::Option<T>)._is_some {
                (@option::Option::none<T> as λ() → option::Option<T>)();
        } else {
                self;
        };
    } else {
        if (other as option::Option<T>)._is_some {
            other;
    } else {
            (@option::Option::none<T> as λ() → option::Option<T>)();
    }
    };
}

nr_def «option»::«Option»::«filter»<T, Env>(self : option::Option<T>, predicate : λ(T) → bool) -> option::Option<T> {
    if (self as option::Option<T>)._is_some {
            if (predicate as λ(T) → bool)((self as option::Option<T>)._value) {
                self;
        } else {
                (@option::Option::none<T> as λ() → option::Option<T>)();
        };
    } else {
            (@option::Option::none<T> as λ() → option::Option<T>)();
    };
}

nr_def «option»::«Option»::«flatten»<T>(option : option::Option<option::Option<T>>) -> option::Option<T> {
    if (option as option::Option<option::Option<T>>)._is_some {
            (option as option::Option<option::Option<T>>)._value;
    } else {
            (@option::Option::none<T> as λ() → option::Option<T>)();
    };
}

nr_trait_impl[impl_62] <T> std::default::Default<> for option::Option<T> where  {
    fn «default»<> () -> option::Option<T> {
        (@option::Option::none<T> as λ() → option::Option<T>)();
}
}

nr_trait_impl[impl_63] <T> std::cmp::Eq<> for option::Option<T> where T : Eq<> {
    fn «eq»<> (self : option::Option<T>, other : option::Option<T>) -> bool {
        if #bEq((self as option::Option<T>)._is_some, (other as option::Option<T>)._is_some) : bool {
                    if (self as option::Option<T>)._is_some {
                            ((T as Eq<>)::eq<> as λ(T, T) → bool)(T, T);
                } else {
                            true;
                };
        } else {
                    false;
        };
}
}

nr_trait_impl[impl_64] <T> std::hash::Hash<> for option::Option<T> where T : Hash<> {
    fn «hash»<H> (self : option::Option<T>, state : &H) -> Unit {
        ((bool as std::hash::Hash<>)::hash<> as λ(bool, &H) → Unit)((self as option::Option<T>)._is_some, state);
        if (self as option::Option<T>)._is_some {
                    ((T as std::hash::Hash<>)::hash<> as λ(T, &H) → Unit)((self as option::Option<T>)._value, state);
        };
}
}

nr_trait_impl[impl_65] <T> std::cmp::Ord<> for option::Option<T> where T : Ord<> {
    fn «cmp»<> (self : option::Option<T>, other : option::Option<T>) -> cmp::Ordering<> {
        if (self as option::Option<T>)._is_some {
                    if (other as option::Option<T>)._is_some {
                            ((T as std::cmp::Ord<>)::cmp<> as λ(T, T) → cmp::Ordering<>)((self as option::Option<T>)._value, (other as option::Option<T>)._value);
                } else {
                            (@cmp::Ordering::greater<> as λ() → cmp::Ordering<>)();
                };
        } else {
            if (other as option::Option<T>)._is_some {
                    (@cmp::Ordering::less<> as λ() → cmp::Ordering<>)();
        } else {
                    (@cmp::Ordering::equal<> as λ() → cmp::Ordering<>)();
        }
        };
}
}


def Option.env := Lampe.Env.mk [«option::Option::and_then», «option::Option::and», «option::Option::expect», «option::Option::filter», «option::Option::flatten», «option::Option::is_none», «option::Option::is_some», «option::Option::map_or_else», «option::Option::map_or», «option::Option::map», «option::Option::none», «option::Option::or_else», «option::Option::or», «option::Option::some», «option::Option::unwrap_or_else», «option::Option::unwrap_or», «option::Option::unwrap_unchecked», «option::Option::unwrap», «option::Option::xor»] [impl_62, impl_63, impl_64, impl_65]