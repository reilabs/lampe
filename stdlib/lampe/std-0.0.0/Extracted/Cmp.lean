-- Generated by lampe

import «std-0.0.0».Extracted.GeneratedTypes
import Lampe

open Lampe

namespace «std-0.0.0»
namespace Extracted

noir_trait_impl[impl_67]<> std::cmp::Eq<> for Field where [] := {
  noir_def eq<>(self: Field, other: Field) -> bool := {
    (#_fEq returning bool)(self, other)
  };
}

noir_trait_impl[impl_68]<> std::cmp::Eq<> for u128 where [] := {
  noir_def eq<>(self: u128, other: u128) -> bool := {
    (#_uEq returning bool)(self, other)
  };
}

noir_trait_impl[impl_69]<> std::cmp::Eq<> for u64 where [] := {
  noir_def eq<>(self: u64, other: u64) -> bool := {
    (#_uEq returning bool)(self, other)
  };
}

noir_trait_impl[impl_70]<> std::cmp::Eq<> for u32 where [] := {
  noir_def eq<>(self: u32, other: u32) -> bool := {
    (#_uEq returning bool)(self, other)
  };
}

noir_trait_impl[impl_71]<> std::cmp::Eq<> for u16 where [] := {
  noir_def eq<>(self: u16, other: u16) -> bool := {
    (#_uEq returning bool)(self, other)
  };
}

noir_trait_impl[impl_72]<> std::cmp::Eq<> for u8 where [] := {
  noir_def eq<>(self: u8, other: u8) -> bool := {
    (#_uEq returning bool)(self, other)
  };
}

noir_trait_impl[impl_73]<> std::cmp::Eq<> for u1 where [] := {
  noir_def eq<>(self: u1, other: u1) -> bool := {
    (#_uEq returning bool)(self, other)
  };
}

noir_trait_impl[impl_74]<> std::cmp::Eq<> for i8 where [] := {
  noir_def eq<>(self: i8, other: i8) -> bool := {
    (#_iEq returning bool)(self, other)
  };
}

noir_trait_impl[impl_75]<> std::cmp::Eq<> for i16 where [] := {
  noir_def eq<>(self: i16, other: i16) -> bool := {
    (#_iEq returning bool)(self, other)
  };
}

noir_trait_impl[impl_76]<> std::cmp::Eq<> for i32 where [] := {
  noir_def eq<>(self: i32, other: i32) -> bool := {
    (#_iEq returning bool)(self, other)
  };
}

noir_trait_impl[impl_77]<> std::cmp::Eq<> for i64 where [] := {
  noir_def eq<>(self: i64, other: i64) -> bool := {
    (#_iEq returning bool)(self, other)
  };
}

noir_trait_impl[impl_78]<> std::cmp::Eq<> for Unit where [] := {
  noir_def eq<>(_self: Unit, _other: Unit) -> bool := {
    #_true
  };
}

noir_trait_impl[impl_79]<> std::cmp::Eq<> for bool where [] := {
  noir_def eq<>(self: bool, other: bool) -> bool := {
    (#_bEq returning bool)(self, other)
  };
}

noir_trait_impl[impl_80]<N: u32, T: Type> std::cmp::Eq<> for Array<T, N: u32> where [T: std::cmp::Eq<>] := {
  noir_def eq<>(self: Array<T, N: u32>, other: Array<T, N: u32>) -> bool := {
    let mut (result: bool) = #_true;
    for i in (0: u32) .. (std::array::len<> as λ(Array<T, N: u32>) -> u32)(self) do {
      result = (#_bAnd returning bool)(result, ((T as std::cmp::Eq<>)::eq<> as λ(T, T) -> bool)((#_arrayIndex returning T)(self, (#_cast returning u32)(i)), (#_arrayIndex returning T)(other, (#_cast returning u32)(i))));
      #_skip
    };
    result
  };
}

noir_trait_impl[impl_81]<T: Type> std::cmp::Eq<> for Slice<T> where [T: std::cmp::Eq<>] := {
  noir_def eq<>(self: Slice<T>, other: Slice<T>) -> bool := {
    let mut (result: bool) = (#_uEq returning bool)((std::slice::len<> as λ(Slice<T>) -> u32)(self), (std::slice::len<> as λ(Slice<T>) -> u32)(other));
    for i in (0: u32) .. (std::slice::len<> as λ(Slice<T>) -> u32)(self) do {
      result = (#_bAnd returning bool)(result, ((T as std::cmp::Eq<>)::eq<> as λ(T, T) -> bool)((#_sliceIndex returning T)(self, (#_cast returning u32)(i)), (#_sliceIndex returning T)(other, (#_cast returning u32)(i))));
      #_skip
    };
    result
  };
}

noir_trait_impl[impl_82]<N: u32> std::cmp::Eq<> for String<N: u32> where [] := {
  noir_def eq<>(self: String<N: u32>, other: String<N: u32>) -> bool := {
    let (self_bytes: Array<u8, N: u32>) = (std::string::as_bytes<> as λ(String<N: u32>) -> Array<u8, N: u32>)(self);
    let (other_bytes: Array<u8, N: u32>) = (std::string::as_bytes<> as λ(String<N: u32>) -> Array<u8, N: u32>)(other);
    ((Array<u8, N: u32> as Eq<>)::eq<> as λ(Array<u8, N: u32>, Array<u8, N: u32>) -> bool)(self_bytes, other_bytes)
  };
}

noir_trait_impl[impl_83]<A: Type, B: Type> std::cmp::Eq<> for Tuple<A, B> where [A: std::cmp::Eq<>, B: std::cmp::Eq<>] := {
  noir_def eq<>(self: Tuple<A, B>, other: Tuple<A, B>) -> bool := {
    (#_bAnd returning bool)(((A as std::cmp::Eq<>)::eq<> as λ(A, A) -> bool)(self.0, other.0), ((B as std::cmp::Eq<>)::eq<> as λ(B, B) -> bool)(self.1, other.1))
  };
}

noir_trait_impl[impl_84]<A: Type, B: Type, C: Type> std::cmp::Eq<> for Tuple<A, B, C> where [A: std::cmp::Eq<>, B: std::cmp::Eq<>, C: std::cmp::Eq<>] := {
  noir_def eq<>(self: Tuple<A, B, C>, other: Tuple<A, B, C>) -> bool := {
    (#_bAnd returning bool)((#_bAnd returning bool)(((A as std::cmp::Eq<>)::eq<> as λ(A, A) -> bool)(self.0, other.0), ((B as std::cmp::Eq<>)::eq<> as λ(B, B) -> bool)(self.1, other.1)), ((C as std::cmp::Eq<>)::eq<> as λ(C, C) -> bool)(self.2, other.2))
  };
}

noir_trait_impl[impl_85]<A: Type, B: Type, C: Type, D: Type> std::cmp::Eq<> for Tuple<A, B, C, D> where [A: std::cmp::Eq<>, B: std::cmp::Eq<>, C: std::cmp::Eq<>, D: std::cmp::Eq<>] := {
  noir_def eq<>(self: Tuple<A, B, C, D>, other: Tuple<A, B, C, D>) -> bool := {
    (#_bAnd returning bool)((#_bAnd returning bool)((#_bAnd returning bool)(((A as std::cmp::Eq<>)::eq<> as λ(A, A) -> bool)(self.0, other.0), ((B as std::cmp::Eq<>)::eq<> as λ(B, B) -> bool)(self.1, other.1)), ((C as std::cmp::Eq<>)::eq<> as λ(C, C) -> bool)(self.2, other.2)), ((D as std::cmp::Eq<>)::eq<> as λ(D, D) -> bool)(self.3, other.3))
  };
}

noir_trait_impl[impl_86]<A: Type, B: Type, C: Type, D: Type, E: Type> std::cmp::Eq<> for Tuple<A, B, C, D, E> where [A: std::cmp::Eq<>, B: std::cmp::Eq<>, C: std::cmp::Eq<>, D: std::cmp::Eq<>, E: std::cmp::Eq<>] := {
  noir_def eq<>(self: Tuple<A, B, C, D, E>, other: Tuple<A, B, C, D, E>) -> bool := {
    (#_bAnd returning bool)((#_bAnd returning bool)((#_bAnd returning bool)((#_bAnd returning bool)(((A as std::cmp::Eq<>)::eq<> as λ(A, A) -> bool)(self.0, other.0), ((B as std::cmp::Eq<>)::eq<> as λ(B, B) -> bool)(self.1, other.1)), ((C as std::cmp::Eq<>)::eq<> as λ(C, C) -> bool)(self.2, other.2)), ((D as std::cmp::Eq<>)::eq<> as λ(D, D) -> bool)(self.3, other.3)), ((E as std::cmp::Eq<>)::eq<> as λ(E, E) -> bool)(self.4, other.4))
  };
}

noir_trait_impl[impl_87]<> std::cmp::Eq<> for std::cmp::Ordering<> where [] := {
  noir_def eq<>(self: std::cmp::Ordering<>, other: std::cmp::Ordering<>) -> bool := {
    (#_fEq returning bool)(self.0, other.0)
  };
}

noir_def std::cmp::Ordering::less<>() -> std::cmp::Ordering<> := {
  (#_makeData returning std::cmp::Ordering<>)((0: Field))
}

noir_def std::cmp::Ordering::equal<>() -> std::cmp::Ordering<> := {
  (#_makeData returning std::cmp::Ordering<>)((1: Field))
}

noir_def std::cmp::Ordering::greater<>() -> std::cmp::Ordering<> := {
  (#_makeData returning std::cmp::Ordering<>)((2: Field))
}

noir_trait_impl[impl_88]<> std::cmp::Ord<> for u128 where [] := {
  noir_def cmp<>(self: u128, other: u128) -> std::cmp::Ordering<> := {
    if (#_uLt returning bool)(self, other) then {
      (std::cmp::Ordering::less<> as λ() -> std::cmp::Ordering<>)()
    } else if (#_uGt returning bool)(self, other) then {
      (std::cmp::Ordering::greater<> as λ() -> std::cmp::Ordering<>)()
    } else {
      (std::cmp::Ordering::equal<> as λ() -> std::cmp::Ordering<>)()
    }
  };
}

noir_trait_impl[impl_89]<> std::cmp::Ord<> for u64 where [] := {
  noir_def cmp<>(self: u64, other: u64) -> std::cmp::Ordering<> := {
    if (#_uLt returning bool)(self, other) then {
      (std::cmp::Ordering::less<> as λ() -> std::cmp::Ordering<>)()
    } else if (#_uGt returning bool)(self, other) then {
      (std::cmp::Ordering::greater<> as λ() -> std::cmp::Ordering<>)()
    } else {
      (std::cmp::Ordering::equal<> as λ() -> std::cmp::Ordering<>)()
    }
  };
}

noir_trait_impl[impl_90]<> std::cmp::Ord<> for u32 where [] := {
  noir_def cmp<>(self: u32, other: u32) -> std::cmp::Ordering<> := {
    if (#_uLt returning bool)(self, other) then {
      (std::cmp::Ordering::less<> as λ() -> std::cmp::Ordering<>)()
    } else if (#_uGt returning bool)(self, other) then {
      (std::cmp::Ordering::greater<> as λ() -> std::cmp::Ordering<>)()
    } else {
      (std::cmp::Ordering::equal<> as λ() -> std::cmp::Ordering<>)()
    }
  };
}

noir_trait_impl[impl_91]<> std::cmp::Ord<> for u16 where [] := {
  noir_def cmp<>(self: u16, other: u16) -> std::cmp::Ordering<> := {
    if (#_uLt returning bool)(self, other) then {
      (std::cmp::Ordering::less<> as λ() -> std::cmp::Ordering<>)()
    } else if (#_uGt returning bool)(self, other) then {
      (std::cmp::Ordering::greater<> as λ() -> std::cmp::Ordering<>)()
    } else {
      (std::cmp::Ordering::equal<> as λ() -> std::cmp::Ordering<>)()
    }
  };
}

noir_trait_impl[impl_92]<> std::cmp::Ord<> for u8 where [] := {
  noir_def cmp<>(self: u8, other: u8) -> std::cmp::Ordering<> := {
    if (#_uLt returning bool)(self, other) then {
      (std::cmp::Ordering::less<> as λ() -> std::cmp::Ordering<>)()
    } else if (#_uGt returning bool)(self, other) then {
      (std::cmp::Ordering::greater<> as λ() -> std::cmp::Ordering<>)()
    } else {
      (std::cmp::Ordering::equal<> as λ() -> std::cmp::Ordering<>)()
    }
  };
}

noir_trait_impl[impl_93]<> std::cmp::Ord<> for i8 where [] := {
  noir_def cmp<>(self: i8, other: i8) -> std::cmp::Ordering<> := {
    if (#_iLt returning bool)(self, other) then {
      (std::cmp::Ordering::less<> as λ() -> std::cmp::Ordering<>)()
    } else if (#_iGt returning bool)(self, other) then {
      (std::cmp::Ordering::greater<> as λ() -> std::cmp::Ordering<>)()
    } else {
      (std::cmp::Ordering::equal<> as λ() -> std::cmp::Ordering<>)()
    }
  };
}

noir_trait_impl[impl_94]<> std::cmp::Ord<> for i16 where [] := {
  noir_def cmp<>(self: i16, other: i16) -> std::cmp::Ordering<> := {
    if (#_iLt returning bool)(self, other) then {
      (std::cmp::Ordering::less<> as λ() -> std::cmp::Ordering<>)()
    } else if (#_iGt returning bool)(self, other) then {
      (std::cmp::Ordering::greater<> as λ() -> std::cmp::Ordering<>)()
    } else {
      (std::cmp::Ordering::equal<> as λ() -> std::cmp::Ordering<>)()
    }
  };
}

noir_trait_impl[impl_95]<> std::cmp::Ord<> for i32 where [] := {
  noir_def cmp<>(self: i32, other: i32) -> std::cmp::Ordering<> := {
    if (#_iLt returning bool)(self, other) then {
      (std::cmp::Ordering::less<> as λ() -> std::cmp::Ordering<>)()
    } else if (#_iGt returning bool)(self, other) then {
      (std::cmp::Ordering::greater<> as λ() -> std::cmp::Ordering<>)()
    } else {
      (std::cmp::Ordering::equal<> as λ() -> std::cmp::Ordering<>)()
    }
  };
}

noir_trait_impl[impl_96]<> std::cmp::Ord<> for i64 where [] := {
  noir_def cmp<>(self: i64, other: i64) -> std::cmp::Ordering<> := {
    if (#_iLt returning bool)(self, other) then {
      (std::cmp::Ordering::less<> as λ() -> std::cmp::Ordering<>)()
    } else if (#_iGt returning bool)(self, other) then {
      (std::cmp::Ordering::greater<> as λ() -> std::cmp::Ordering<>)()
    } else {
      (std::cmp::Ordering::equal<> as λ() -> std::cmp::Ordering<>)()
    }
  };
}

noir_trait_impl[impl_97]<> std::cmp::Ord<> for Unit where [] := {
  noir_def cmp<>(_self: Unit, _other: Unit) -> std::cmp::Ordering<> := {
    (std::cmp::Ordering::equal<> as λ() -> std::cmp::Ordering<>)()
  };
}

noir_trait_impl[impl_98]<> std::cmp::Ord<> for bool where [] := {
  noir_def cmp<>(self: bool, other: bool) -> std::cmp::Ordering<> := {
    if self then {
      if other then {
        (std::cmp::Ordering::equal<> as λ() -> std::cmp::Ordering<>)()
      } else {
        (std::cmp::Ordering::greater<> as λ() -> std::cmp::Ordering<>)()
      }
    } else if other then {
      (std::cmp::Ordering::less<> as λ() -> std::cmp::Ordering<>)()
    } else {
      (std::cmp::Ordering::equal<> as λ() -> std::cmp::Ordering<>)()
    }
  };
}

noir_trait_impl[impl_99]<N: u32, T: Type> std::cmp::Ord<> for Array<T, N: u32> where [T: std::cmp::Ord<>] := {
  noir_def cmp<>(self: Array<T, N: u32>, other: Array<T, N: u32>) -> std::cmp::Ordering<> := {
    let mut (result: std::cmp::Ordering<>) = (std::cmp::Ordering::equal<> as λ() -> std::cmp::Ordering<>)();
    for i in (0: u32) .. (std::array::len<> as λ(Array<T, N: u32>) -> u32)(self) do {
      if ((std::cmp::Ordering<> as Eq<>)::eq<> as λ(std::cmp::Ordering<>, std::cmp::Ordering<>) -> bool)(result, (std::cmp::Ordering::equal<> as λ() -> std::cmp::Ordering<>)()) then {
        result = ((T as std::cmp::Ord<>)::cmp<> as λ(T, T) -> std::cmp::Ordering<>)((#_arrayIndex returning T)(self, (#_cast returning u32)(i)), (#_arrayIndex returning T)(other, (#_cast returning u32)(i)));
        #_skip
      }
    };
    result
  };
}

noir_trait_impl[impl_100]<T: Type> std::cmp::Ord<> for Slice<T> where [T: std::cmp::Ord<>] := {
  noir_def cmp<>(self: Slice<T>, other: Slice<T>) -> std::cmp::Ordering<> := {
    let mut (result: std::cmp::Ordering<>) = ((u32 as std::cmp::Ord<>)::cmp<> as λ(u32, u32) -> std::cmp::Ordering<>)((std::slice::len<> as λ(Slice<T>) -> u32)(self), (std::slice::len<> as λ(Slice<T>) -> u32)(other));
    for i in (0: u32) .. (std::slice::len<> as λ(Slice<T>) -> u32)(self) do {
      if ((std::cmp::Ordering<> as Eq<>)::eq<> as λ(std::cmp::Ordering<>, std::cmp::Ordering<>) -> bool)(result, (std::cmp::Ordering::equal<> as λ() -> std::cmp::Ordering<>)()) then {
        result = ((T as std::cmp::Ord<>)::cmp<> as λ(T, T) -> std::cmp::Ordering<>)((#_sliceIndex returning T)(self, (#_cast returning u32)(i)), (#_sliceIndex returning T)(other, (#_cast returning u32)(i)));
        #_skip
      }
    };
    result
  };
}

noir_trait_impl[impl_101]<A: Type, B: Type> std::cmp::Ord<> for Tuple<A, B> where [A: std::cmp::Ord<>, B: std::cmp::Ord<>] := {
  noir_def cmp<>(self: Tuple<A, B>, other: Tuple<A, B>) -> std::cmp::Ordering<> := {
    let (result: std::cmp::Ordering<>) = ((A as std::cmp::Ord<>)::cmp<> as λ(A, A) -> std::cmp::Ordering<>)(self.0, other.0);
    if ((std::cmp::Ordering<> as Eq<>)::eq<> as λ(std::cmp::Ordering<>, std::cmp::Ordering<>) -> bool)(result, (std::cmp::Ordering::equal<> as λ() -> std::cmp::Ordering<>)()) then {
      result
    } else {
      ((B as std::cmp::Ord<>)::cmp<> as λ(B, B) -> std::cmp::Ordering<>)(self.1, other.1)
    }
  };
}

noir_trait_impl[impl_102]<A: Type, B: Type, C: Type> std::cmp::Ord<> for Tuple<A, B, C> where [A: std::cmp::Ord<>, B: std::cmp::Ord<>, C: std::cmp::Ord<>] := {
  noir_def cmp<>(self: Tuple<A, B, C>, other: Tuple<A, B, C>) -> std::cmp::Ordering<> := {
    let mut (result: std::cmp::Ordering<>) = ((A as std::cmp::Ord<>)::cmp<> as λ(A, A) -> std::cmp::Ordering<>)(self.0, other.0);
    if ((std::cmp::Ordering<> as Eq<>)::eq<> as λ(std::cmp::Ordering<>, std::cmp::Ordering<>) -> bool)(result, (std::cmp::Ordering::equal<> as λ() -> std::cmp::Ordering<>)()) then {
      result = ((B as std::cmp::Ord<>)::cmp<> as λ(B, B) -> std::cmp::Ordering<>)(self.1, other.1);
      #_skip
    };
    if ((std::cmp::Ordering<> as Eq<>)::eq<> as λ(std::cmp::Ordering<>, std::cmp::Ordering<>) -> bool)(result, (std::cmp::Ordering::equal<> as λ() -> std::cmp::Ordering<>)()) then {
      result = ((C as std::cmp::Ord<>)::cmp<> as λ(C, C) -> std::cmp::Ordering<>)(self.2, other.2);
      #_skip
    };
    result
  };
}

noir_trait_impl[impl_103]<A: Type, B: Type, C: Type, D: Type> std::cmp::Ord<> for Tuple<A, B, C, D> where [A: std::cmp::Ord<>, B: std::cmp::Ord<>, C: std::cmp::Ord<>, D: std::cmp::Ord<>] := {
  noir_def cmp<>(self: Tuple<A, B, C, D>, other: Tuple<A, B, C, D>) -> std::cmp::Ordering<> := {
    let mut (result: std::cmp::Ordering<>) = ((A as std::cmp::Ord<>)::cmp<> as λ(A, A) -> std::cmp::Ordering<>)(self.0, other.0);
    if ((std::cmp::Ordering<> as Eq<>)::eq<> as λ(std::cmp::Ordering<>, std::cmp::Ordering<>) -> bool)(result, (std::cmp::Ordering::equal<> as λ() -> std::cmp::Ordering<>)()) then {
      result = ((B as std::cmp::Ord<>)::cmp<> as λ(B, B) -> std::cmp::Ordering<>)(self.1, other.1);
      #_skip
    };
    if ((std::cmp::Ordering<> as Eq<>)::eq<> as λ(std::cmp::Ordering<>, std::cmp::Ordering<>) -> bool)(result, (std::cmp::Ordering::equal<> as λ() -> std::cmp::Ordering<>)()) then {
      result = ((C as std::cmp::Ord<>)::cmp<> as λ(C, C) -> std::cmp::Ordering<>)(self.2, other.2);
      #_skip
    };
    if ((std::cmp::Ordering<> as Eq<>)::eq<> as λ(std::cmp::Ordering<>, std::cmp::Ordering<>) -> bool)(result, (std::cmp::Ordering::equal<> as λ() -> std::cmp::Ordering<>)()) then {
      result = ((D as std::cmp::Ord<>)::cmp<> as λ(D, D) -> std::cmp::Ordering<>)(self.3, other.3);
      #_skip
    };
    result
  };
}

noir_trait_impl[impl_104]<A: Type, B: Type, C: Type, D: Type, E: Type> std::cmp::Ord<> for Tuple<A, B, C, D, E> where [A: std::cmp::Ord<>, B: std::cmp::Ord<>, C: std::cmp::Ord<>, D: std::cmp::Ord<>, E: std::cmp::Ord<>] := {
  noir_def cmp<>(self: Tuple<A, B, C, D, E>, other: Tuple<A, B, C, D, E>) -> std::cmp::Ordering<> := {
    let mut (result: std::cmp::Ordering<>) = ((A as std::cmp::Ord<>)::cmp<> as λ(A, A) -> std::cmp::Ordering<>)(self.0, other.0);
    if ((std::cmp::Ordering<> as Eq<>)::eq<> as λ(std::cmp::Ordering<>, std::cmp::Ordering<>) -> bool)(result, (std::cmp::Ordering::equal<> as λ() -> std::cmp::Ordering<>)()) then {
      result = ((B as std::cmp::Ord<>)::cmp<> as λ(B, B) -> std::cmp::Ordering<>)(self.1, other.1);
      #_skip
    };
    if ((std::cmp::Ordering<> as Eq<>)::eq<> as λ(std::cmp::Ordering<>, std::cmp::Ordering<>) -> bool)(result, (std::cmp::Ordering::equal<> as λ() -> std::cmp::Ordering<>)()) then {
      result = ((C as std::cmp::Ord<>)::cmp<> as λ(C, C) -> std::cmp::Ordering<>)(self.2, other.2);
      #_skip
    };
    if ((std::cmp::Ordering<> as Eq<>)::eq<> as λ(std::cmp::Ordering<>, std::cmp::Ordering<>) -> bool)(result, (std::cmp::Ordering::equal<> as λ() -> std::cmp::Ordering<>)()) then {
      result = ((D as std::cmp::Ord<>)::cmp<> as λ(D, D) -> std::cmp::Ordering<>)(self.3, other.3);
      #_skip
    };
    if ((std::cmp::Ordering<> as Eq<>)::eq<> as λ(std::cmp::Ordering<>, std::cmp::Ordering<>) -> bool)(result, (std::cmp::Ordering::equal<> as λ() -> std::cmp::Ordering<>)()) then {
      result = ((E as std::cmp::Ord<>)::cmp<> as λ(E, E) -> std::cmp::Ordering<>)(self.4, other.4);
      #_skip
    };
    result
  };
}

noir_def cmp::max<T: Type>(v1: T, v2: T) -> T := {
  if ((T as Ord<>)::cmp<> as λ(T, T) -> bool)(v1, v2) then {
    v1
  } else {
    v2
  }
}

noir_def cmp::min<T: Type>(v1: T, v2: T) -> T := {
  if ((T as Ord<>)::cmp<> as λ(T, T) -> bool)(v1, v2) then {
    v2
  } else {
    v1
  }
}

noir_def cmp::cmp_tests::sanity_check_min<>() -> Unit := {
  (#_assert returning Unit)((#_uEq returning bool)((cmp::min<u64> as λ(u64, u64) -> u64)((#_cast returning u64)((0: Field)), (#_cast returning u64)((1: Field))), (0: u64)));
  (#_assert returning Unit)((#_uEq returning bool)((cmp::min<u64> as λ(u64, u64) -> u64)((#_cast returning u64)((0: Field)), (#_cast returning u64)((0: Field))), (0: u64)));
  (#_assert returning Unit)((#_uEq returning bool)((cmp::min<u64> as λ(u64, u64) -> u64)((#_cast returning u64)((1: Field)), (#_cast returning u64)((1: Field))), (1: u64)));
  (#_assert returning Unit)((#_uEq returning bool)((cmp::min<u8> as λ(u8, u8) -> u8)((#_cast returning u8)((255: Field)), (#_cast returning u8)((0: Field))), (0: u8)));
  #_skip
}

noir_def cmp::cmp_tests::sanity_check_max<>() -> Unit := {
  (#_assert returning Unit)((#_uEq returning bool)((cmp::max<u64> as λ(u64, u64) -> u64)((#_cast returning u64)((0: Field)), (#_cast returning u64)((1: Field))), (1: u64)));
  (#_assert returning Unit)((#_uEq returning bool)((cmp::max<u64> as λ(u64, u64) -> u64)((#_cast returning u64)((0: Field)), (#_cast returning u64)((0: Field))), (0: u64)));
  (#_assert returning Unit)((#_uEq returning bool)((cmp::max<u64> as λ(u64, u64) -> u64)((#_cast returning u64)((1: Field)), (#_cast returning u64)((1: Field))), (1: u64)));
  (#_assert returning Unit)((#_uEq returning bool)((cmp::max<u8> as λ(u8, u8) -> u8)((#_cast returning u8)((255: Field)), (#_cast returning u8)((0: Field))), (255: u8)));
  #_skip
}


def Cmp.env : Env := Env.mk
  [«std::cmp::Ordering::less», «std::cmp::Ordering::equal», «std::cmp::Ordering::greater», «cmp::max», «cmp::min», «cmp::cmp_tests::sanity_check_min», «cmp::cmp_tests::sanity_check_max»]
  [impl_67, impl_68, impl_69, impl_70, impl_71, impl_72, impl_73, impl_74, impl_75, impl_76, impl_77, impl_78, impl_79, impl_80, impl_81, impl_82, impl_83, impl_84, impl_85, impl_86, impl_87, impl_88, impl_89, impl_90, impl_91, impl_92, impl_93, impl_94, impl_95, impl_96, impl_97, impl_98, impl_99, impl_100, impl_101, impl_102, impl_103, impl_104]
