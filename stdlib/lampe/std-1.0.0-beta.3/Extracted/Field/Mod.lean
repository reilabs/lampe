-- Generated by lampe

import «std-1.0.0-beta.3».Extracted.GeneratedTypes
import Lampe

open Lampe

namespace «std-1.0.0-beta.3»
namespace Extracted

noir_def field::__assert_max_bit_size<>(value: Field, bit_size: u32) -> Unit := {
  (#_apply_range_constraint returning Unit)(value, bit_size)
}

noir_def field::__to_le_radix<N: u32>(value: Field, radix: u32) -> Array<u8, N: u32> := {
  (#_to_le_radix returning Array<u8, N: u32>)(value, radix)
}

noir_def field::__to_be_radix<N: u32>(value: Field, radix: u32) -> Array<u8, N: u32> := {
  (#_to_be_radix returning Array<u8, N: u32>)(value, radix)
}

noir_def field::__to_le_bits<N: u32>(value: Field) -> Array<u1, N: u32> := {
  (#_to_le_bits returning Array<u1, N: u32>)(value)
}

noir_def field::__to_be_bits<N: u32>(value: Field) -> Array<u1, N: u32> := {
  (#_to_be_bits returning Array<u1, N: u32>)(value)
}

noir_def field::__field_less_than<>(x: Field, y: Field) -> bool := {
  (#_fresh returning bool)()
}

noir_def field::field_less_than<>(x: Field, y: Field) -> bool := {
  (#_fresh returning bool)()
}

noir_def field::bytes32_to_field<>(bytes32: Array<u8, 32: u32>) -> Field := {
  let mut (v: Field) = (1: Field);
  let mut (high: Field) = (#_cast returning Field)((0: Field));
  let mut (low: Field) = (#_cast returning Field)((0: Field));
  for i in (0: u32) .. (16: u32) do {
    high = (#_fAdd returning Field)(high, (#_fMul returning Field)((#_cast returning Field)((#_arrayIndex returning u8)(bytes32, (#_cast returning u32)((#_uSub returning u32)((15: u32), i)))), v));
    low = (#_fAdd returning Field)(low, (#_fMul returning Field)((#_cast returning Field)((#_arrayIndex returning u8)(bytes32, (#_cast returning u32)((#_uSub returning u32)((#_uAdd returning u32)((16: u32), (15: u32)), i)))), v));
    v = (#_fMul returning Field)(v, (256: Field));
    #_skip
  };
  (#_fAdd returning Field)(low, (#_fMul returning Field)(high, v))
}

noir_def field::lt_fallback<>(x: Field, y: Field) -> bool := {
  if (runtime::is_unconstrained<> as λ() -> bool)() then {
    (field::field_less_than<> as λ(Field, Field) -> bool)(x, y)
  } else {
    let (x_bytes: Array<u8, 32: u32>) = (std::field::to_le_bytes<32: u32> as λ(Field) -> Array<u8, 32: u32>)(x);
    let (y_bytes: Array<u8, 32: u32>) = (std::field::to_le_bytes<32: u32> as λ(Field) -> Array<u8, 32: u32>)(y);
    let mut (x_is_lt: bool) = #_false;
    let mut (done: bool) = #_false;
    for i in (0: u32) .. (32: u32) do {
      if (#_bNot returning bool)(done) then {
        let (x_byte: u8) = (#_cast returning u8)((#_arrayIndex returning u8)(x_bytes, (#_cast returning u32)((#_uSub returning u32)((#_uSub returning u32)((32: u32), (1: u32)), i))));
        let (y_byte: u8) = (#_cast returning u8)((#_arrayIndex returning u8)(y_bytes, (#_cast returning u32)((#_uSub returning u32)((#_uSub returning u32)((32: u32), (1: u32)), i))));
        let (bytes_match: bool) = (#_uEq returning bool)(x_byte, y_byte);
        if (#_bNot returning bool)(bytes_match) then {
          x_is_lt = (#_uLt returning bool)(x_byte, y_byte);
          done = #_true;
          #_skip
        }
      }
    };
    x_is_lt
  }
}

noir_def field::tests::test_to_be_bits<>() -> Unit := {
  let (field: Field) = (2: Field);
  let (bits: Array<u1, 8: u32>) = (std::field::to_be_bits<8: u32> as λ(Field) -> Array<u1, 8: u32>)(field);
  (#_assert returning Unit)(((Array<u1, 8: u32> as Eq<>)::eq<> as λ(Array<u1, 8: u32>, Array<u1, 8: u32>) -> bool)(bits, (#_mkArray returning Array<u1, 8: u32>)((0: u1), (0: u1), (0: u1), (0: u1), (0: u1), (0: u1), (1: u1), (0: u1))));
  #_skip
}

noir_def field::tests::test_to_le_bits<>() -> Unit := {
  let (field: Field) = (2: Field);
  let (bits: Array<u1, 8: u32>) = (std::field::to_le_bits<8: u32> as λ(Field) -> Array<u1, 8: u32>)(field);
  (#_assert returning Unit)(((Array<u1, 8: u32> as Eq<>)::eq<> as λ(Array<u1, 8: u32>, Array<u1, 8: u32>) -> bool)(bits, (#_mkArray returning Array<u1, 8: u32>)((0: u1), (1: u1), (0: u1), (0: u1), (0: u1), (0: u1), (0: u1), (0: u1))));
  #_skip
}

noir_def field::tests::test_to_be_bytes<>() -> Unit := {
  let (field: Field) = (2: Field);
  let (bytes: Array<u8, 8: u32>) = (std::field::to_be_bytes<8: u32> as λ(Field) -> Array<u8, 8: u32>)(field);
  (#_assert returning Unit)(((Array<u8, 8: u32> as Eq<>)::eq<> as λ(Array<u8, 8: u32>, Array<u8, 8: u32>) -> bool)(bytes, (#_mkArray returning Array<u8, 8: u32>)((0: u8), (0: u8), (0: u8), (0: u8), (0: u8), (0: u8), (0: u8), (2: u8))));
  (#_assert returning Unit)((#_fEq returning bool)((std::field::from_be_bytes<8: u32> as λ(Array<u8, 8: u32>) -> Field)(bytes), field));
  #_skip
}

noir_def field::tests::test_to_le_bytes<>() -> Unit := {
  let (field: Field) = (2: Field);
  let (bytes: Array<u8, 8: u32>) = (std::field::to_le_bytes<8: u32> as λ(Field) -> Array<u8, 8: u32>)(field);
  (#_assert returning Unit)(((Array<u8, 8: u32> as Eq<>)::eq<> as λ(Array<u8, 8: u32>, Array<u8, 8: u32>) -> bool)(bytes, (#_mkArray returning Array<u8, 8: u32>)((2: u8), (0: u8), (0: u8), (0: u8), (0: u8), (0: u8), (0: u8), (0: u8))));
  (#_assert returning Unit)((#_fEq returning bool)((std::field::from_le_bytes<8: u32> as λ(Array<u8, 8: u32>) -> Field)(bytes), field));
  #_skip
}

noir_def field::tests::test_to_be_radix<>() -> Unit := {
  let (field: Field) = (259: Field);
  let (bytes: Array<u8, 8: u32>) = (std::field::to_be_radix<8: u32> as λ(Field, u32) -> Array<u8, 8: u32>)(field, (256: u32));
  (#_assert returning Unit)(((Array<u8, 8: u32> as Eq<>)::eq<> as λ(Array<u8, 8: u32>, Array<u8, 8: u32>) -> bool)(bytes, (#_mkArray returning Array<u8, 8: u32>)((0: u8), (0: u8), (0: u8), (0: u8), (0: u8), (0: u8), (1: u8), (3: u8))));
  (#_assert returning Unit)((#_fEq returning bool)((std::field::from_be_bytes<8: u32> as λ(Array<u8, 8: u32>) -> Field)(bytes), field));
  #_skip
}

noir_def field::tests::test_to_le_radix<>() -> Unit := {
  let (field: Field) = (259: Field);
  let (bytes: Array<u8, 8: u32>) = (std::field::to_le_radix<8: u32> as λ(Field, u32) -> Array<u8, 8: u32>)(field, (256: u32));
  (#_assert returning Unit)(((Array<u8, 8: u32> as Eq<>)::eq<> as λ(Array<u8, 8: u32>, Array<u8, 8: u32>) -> bool)(bytes, (#_mkArray returning Array<u8, 8: u32>)((3: u8), (1: u8), (0: u8), (0: u8), (0: u8), (0: u8), (0: u8), (0: u8))));
  (#_assert returning Unit)((#_fEq returning bool)((std::field::from_le_bytes<8: u32> as λ(Array<u8, 8: u32>) -> Field)(bytes), field));
  #_skip
}

noir_def field::tests::test_to_le_radix_1<>() -> Unit := {
  if (#_bNot returning bool)((runtime::is_unconstrained<> as λ() -> bool)()) then {
    let (field: Field) = (2: Field);
    let (_: Array<u8, 8: u32>) = (std::field::to_le_radix<8: u32> as λ(Field, u32) -> Array<u8, 8: u32>)(field, (1: u32));
    #_skip
  } else {
    (panic::panic<Tuple<>, Unit, 28: u32> as λ(FmtString<28: u32, Tuple<> >) -> Unit)((#_mkFormatString returning FmtString<28: u32, Tuple<> >)("radix must be greater than 1"));
    #_skip
  }
}

noir_def field::tests::test_to_le_radix_3<>() -> Unit := {
  if (#_bNot returning bool)((runtime::is_unconstrained<> as λ() -> bool)()) then {
    let (field: Field) = (2: Field);
    let (_: Array<u8, 8: u32>) = (std::field::to_le_radix<8: u32> as λ(Field, u32) -> Array<u8, 8: u32>)(field, (3: u32));
    #_skip
  } else {
    (panic::panic<Tuple<>, Unit, 26: u32> as λ(FmtString<26: u32, Tuple<> >) -> Unit)((#_mkFormatString returning FmtString<26: u32, Tuple<> >)("radix must be a power of 2"));
    #_skip
  }
}

noir_def field::tests::test_to_le_radix_brillig_3<>() -> Unit := {
  if (runtime::is_unconstrained<> as λ() -> bool)() then {
    let (field: Field) = (1: Field);
    let (out: Array<u8, 8: u32>) = (std::field::to_le_radix<8: u32> as λ(Field, u32) -> Array<u8, 8: u32>)(field, (3: u32));
    let mut (expected: Array<u8, 8: u32>) = (#_mkRepeatedArray returning Array<u8, 8: u32>)((0: u8));
    (expected[(0: u32)]: u8) = (1: u8);
    (#_assert returning Unit)(((Array<u8, 8: u32> as Eq<>)::eq<> as λ(Array<u8, 8: u32>, Array<u8, 8: u32>) -> bool)(out, expected));
    #_skip
  }
}

noir_def field::tests::test_to_le_radix_512<>() -> Unit := {
  if (#_bNot returning bool)((runtime::is_unconstrained<> as λ() -> bool)()) then {
    let (field: Field) = (2: Field);
    let (_: Array<u8, 8: u32>) = (std::field::to_le_radix<8: u32> as λ(Field, u32) -> Array<u8, 8: u32>)(field, (512: u32));
    #_skip
  } else {
    (panic::panic<Tuple<>, Unit, 39: u32> as λ(FmtString<39: u32, Tuple<> >) -> Unit)((#_mkFormatString returning FmtString<39: u32, Tuple<> >)("radix must be less than or equal to 256"))
  }
}

noir_def field::tests::test_field_less_than<>() -> Unit := {
  (#_fresh returning Unit)()
}


def Field.Mod.env : Env := Env.mk
  [«field::__assert_max_bit_size», «field::__to_le_radix», «field::__to_be_radix», «field::__to_le_bits», «field::__to_be_bits», «field::__field_less_than», «field::field_less_than», «field::bytes32_to_field», «field::lt_fallback», «field::tests::test_to_be_bits», «field::tests::test_to_le_bits», «field::tests::test_to_be_bytes», «field::tests::test_to_le_bytes», «field::tests::test_to_be_radix», «field::tests::test_to_le_radix», «field::tests::test_to_le_radix_1», «field::tests::test_to_le_radix_3», «field::tests::test_to_le_radix_brillig_3», «field::tests::test_to_le_radix_512», «field::tests::test_field_less_than»]
  []
