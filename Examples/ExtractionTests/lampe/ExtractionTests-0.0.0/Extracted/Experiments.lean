-- Generated by lampe

import «ExtractionTests-0.0.0».Extracted.GeneratedTypes
import Lampe

open Lampe

namespace «ExtractionTests-0.0.0»
namespace Extracted

nr_def «experiments»::«my_func3»<>(a : u8) -> u8 {
    (@experiments::my_func<> as λ(u8) → u8)(a);
}

nr_def «experiments»::«my_func»<>(a : u8) -> u8 {
    #uAdd(a, 1 : u8) : u8;
}

nr_def «experiments»::«my_func2»<>(arr : [u8; 8], b : u8) -> u8 {
    #arrayIndex(arr, #cast(b) : u32) : u8;
}

nr_def «experiments»::«get_unchecked»<T>(a : experiments::Option2<T>) -> T {
    (a as experiments::Option2<T>)._value;
}

nr_def «experiments»::«my_fn»<>() -> u8 {
    #uAdd(1 : u8, 1 : u8) : u8;
}

nr_def «experiments»::«cast_test»<>(a : u8) -> u64 {
    if #uEq(a, 0 : u8) : bool {
            0 : u64;
    } else {
            #cast(a) : u64;
    };
}

nr_def «experiments»::«tuple_test»<>(a : u8) -> `(u8, u8) {
    let b = |c : u8| -> u8 #uAdd(#uAdd(c, a) : u8, 10 : u8) : u8;
    `(a, a);
}

nr_def «experiments»::«literal_test»<>() -> Unit {
    let a = 1 : Field;
    let b = true;
    let c = false;
    let d = [1 : Field ; 5];
    let e = &[1 : Field ; 5];
    let f = [1 : Field, 2 : Field, 3 : Field];
    let h = "asdf";
    let i = #format("${b}", b);
}

nr_def «experiments»::«assigns»<>(x : u8) -> Unit {
    let mut y = 3 : u8;
    y = #uAdd(y, x) : u8;
    let mut arr = [1 : Field, 2 : Field];
    arr[#cast(0 : Field) : u32] = 10 : Field;
    skip;
}

nr_def «experiments»::«uncons»<>(x : u8) -> Unit {
    #fresh() : Unit
}

nr_def «experiments»::«check»<>(x : u8) -> Unit {
    #assert(#uEq(x, 5 : u8) : bool) : Unit;
    skip;
}

nr_trait_impl[impl_406] <T> std::default::Default<> for experiments::Option2<T> where  {
    fn «experiments»::«default»<> () -> experiments::Option2<T> {
        (@experiments::Option2::none<T> as λ() → experiments::Option2<T>)();
}
}

nr_def «experiments»::«Option2»::«none»<T>() -> experiments::Option2<T> {
    experiments::Option2<T> { false, #zeroed() : T };
}

nr_def «experiments»::«Option2»::«some»<T>(_value : T) -> experiments::Option2<T> {
    experiments::Option2<T> { true, _value };
}

nr_def «experiments»::«Option2»::«is_none»<T>(self : experiments::Option2<T>) -> bool {
    #bNot((@experiments::Option2::is_some<T> as λ(experiments::Option2<T>) → bool)(self)) : bool;
}

nr_def «experiments»::«Option2»::«is_some»<T>(self : experiments::Option2<T>) -> bool {
    (self as experiments::Option2<T>)._is_some;
}

nr_trait_impl[impl_407] <T> experiments::MyTrait<> for experiments::Option2<T> where  {
    fn «experiments»::«foo»<> (self : experiments::Option2<T>) -> experiments::Option2<T> {
        self;
}
}

nr_trait_impl[impl_408] <T> experiments::MyTrait<> for `(T, bool) where T : MyTrait<> {
    fn «experiments»::«foo»<> (self : `(T, bool)) -> `(T, bool) {
        self;
}
}

nr_def «experiments»::«string_test»<>() -> str<5> {
    let x = "Hello";
    x;
}

nr_def «experiments»::«fmtstr_test»<>(x : Field, y : Field) -> Field {
    #assert(#fNeq(x, y) : bool) : Unit;
    let _a = #format("this is first:{x}  this is second:{y}", x, y);
    #fAdd(x, y) : Field;
}

nr_def «experiments»::«is_alias_some»<T>(x : @AliasedOpt<T>) -> bool {
    (@experiments::Option2::is_some<T> as λ(experiments::Option2<T>) → bool)(x);
}

nr_def «experiments»::«main»<>() -> Unit {
    let mut op1 = (@experiments::Option2::some<Field> as λ(Field) → experiments::Option2<Field>)(5 : Field);
    let op2 = ((experiments::Option2<Field> as Default<>)::default<> as λ() → experiments::Option2<Field>)();
    let op3 = ((experiments::Option2<Field> as MyTrait<>)::foo<> as λ(experiments::Option2<Field>) → experiments::Option2<Field>)(if true {
            op1;
    } else {
            op2;
    });
    (@experiments::Option2::is_some<Field> as λ(experiments::Option2<Field>) → bool)(op1);
    let mut l = [1 : Field, 2 : Field, 3 : Field];
    #arrayIndex(l, #cast(0 : Field) : u32) : Field;
    let t = `(1 : Field, true, 3 : Field);
    t.2;
    l[#cast(1 : Field) : u32] = 4 : Field;
    (op1 as experiments::Option2<Field>)._is_some = false;
    let mut tpl = `(1 : Field, true);
    tpl.0 = 2 : Field;
    skip;
}


def Experiments.env := Lampe.Env.mk [«experiments::Option2::is_none», «experiments::Option2::is_some», «experiments::Option2::none», «experiments::Option2::some», «experiments::assigns», «experiments::cast_test», «experiments::check», «experiments::fmtstr_test», «experiments::get_unchecked», «experiments::is_alias_some», «experiments::literal_test», «experiments::main», «experiments::my_fn», «experiments::my_func2», «experiments::my_func3», «experiments::my_func», «experiments::string_test», «experiments::tuple_test», «experiments::uncons»] [impl_406, impl_407, impl_408]