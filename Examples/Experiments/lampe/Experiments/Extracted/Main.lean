-- Generated by lampe

import Lampe

open Lampe

namespace Extracted

nr_struct_def Option2<T> {
    _is_some : bool,
    _value : T
}

nr_type_alias AliasedOpt<T> = Option2<T>

nr_trait_impl[impl_406] <T> MyTrait<> for Option2<T> where  {
    fn «foo»<> (self : Option2<T>) -> Option2<T> {
        self;
}
}

nr_trait_impl[impl_405] <T> std::default::Default<> for Option2<T> where  {
    fn «default»<> () -> Option2<T> {
        (@Option2::none<T> as λ() → Option2<T>)();
}
}

nr_trait_impl[impl_407] <T> MyTrait<> for `(T, bool) where T : MyTrait<> {
    fn «foo»<> (self : `(T, bool)) -> `(T, bool) {
        self;
}
}

nr_def «my_func3»<>(a : u8) -> u8 {
    (@my_func<> as λ(u8) → u8)(a);
}

nr_def «fmtstr_test»<>(x : Field, y : Field) -> Field {
    #assert(#fNeq(x, y) : bool) : Unit;
    let _a = #format("this is first:{x}  this is second:{y}", x, y);
    #fAdd(x, y) : Field;
}

nr_def «tuple_test»<>(a : u8) -> `(u8, u8) {
    let b = |c : u8| -> u8 #uAdd(#uAdd(c, a) : u8, 10 : u8) : u8;
    `(a, a);
}

nr_def «cast_test»<>(a : u8) -> u64 {
    if #uEq(a, 0 : u8) : bool {
            0 : u64;
    } else {
            #cast(a) : u64;
    };
}

nr_def «my_func»<>(a : u8) -> u8 {
    #uAdd(a, 1 : u8) : u8;
}

nr_def «Option2»::«some»<T>(_value : T) -> Option2<T> {
    Option2<T> { true, _value };
}

nr_def «get_unchecked»<T>(a : Option2<T>) -> T {
    (a as Option2<T>)._value;
}

nr_def «Option2»::«is_none»<T>(self : Option2<T>) -> bool {
    #bNot((@Option2::is_some<T> as λ(Option2<T>) → bool)(self)) : bool;
}

nr_def «my_fn»<>() -> u8 {
    #uAdd(1 : u8, 1 : u8) : u8;
}

nr_def «Option2»::«is_some»<T>(self : Option2<T>) -> bool {
    (self as Option2<T>)._is_some;
}

nr_def «is_alias_some»<T>(x : @AliasedOpt<T>) -> bool {
    (@Option2::is_some<T> as λ(Option2<T>) → bool)(x);
}

nr_def «main»<>() -> Unit {
    let mut op1 = (@Option2::some<Field> as λ(Field) → Option2<Field>)(5 : Field);
    let op2 = ((Option2<Field> as Default<>)::default<> as λ() → Option2<Field>)();
    let op3 = ((Option2<Field> as MyTrait<>)::foo<> as λ(Option2<Field>) → Option2<Field>)(if true {
            op1;
    } else {
            op2;
    });
    (@Option2::is_some<Field> as λ(Option2<Field>) → bool)(op1);
    let mut l = [1 : Field, 2 : Field, 3 : Field];
    #arrayIndex(l, #cast(0 : Field) : u32) : Field;
    let t = `(1 : Field, true, 3 : Field);
    t.2;
    l[#cast(1 : Field) : u32] = 4 : Field;
    (op1 as Option2<Field>)._is_some = false;
    let mut tpl = `(1 : Field, true);
    tpl.0 = 2 : Field;
}

nr_def «my_func2»<>(arr : [u8; 8], b : u8) -> u8 {
    #arrayIndex(arr, #cast(b) : u32) : u8;
}

nr_def «Option2»::«none»<T>() -> Option2<T> {
    Option2<T> { false, #zeroed() : T };
}

nr_def «uncons»<>(x : u8) -> Unit {
    #fresh() : Unit
}

nr_def «literal_test»<>() -> Unit {
    let a = 1 : Field;
    let b = true;
    let c = false;
    let d = [1 : Field ; 5];
    let e = &[1 : Field ; 5];
    let f = [1 : Field, 2 : Field, 3 : Field];
    let h = "asdf";
    let i = #format("${b}", b);
}

nr_def «check»<>(x : u8) -> Unit {
    #assert(#uEq(x, 5 : u8) : bool) : Unit;
}

nr_def «string_test»<>() -> str<5> {
    let x = "Hello";
    x;
}

nr_def «assigns»<>(x : u8) -> Unit {
    let mut y = 3 : u8;
    y = #uAdd(y, x) : u8;
    let mut arr = [1 : Field, 2 : Field];
    arr[#cast(0 : Field) : u32] = 10 : Field;
}


def env := Lampe.Env.mk [«my_func3», «get_unchecked», «check», «my_fn», «main», «uncons», «literal_test», «Option2::some», «fmtstr_test», «assigns», «is_alias_some», «tuple_test», «my_func2», «Option2::none», «cast_test», «string_test», «my_func», «Option2::is_some», «Option2::is_none»] [impl_407, impl_406, impl_405]